from typing import List, Union, Dict, Any
from uuid import UUID
from leeq.compiler.lbnl_qubic.circuit_list_compiler import QubiCCircuitListLPBCompiler
from leeq.core.context import ExperimentContext
from leeq.core.engine.measurement_result import MeasurementResult
from leeq.core.primitives.logical_primitives import LogicalPrimitiveBlock
from leeq.experiments.sweeper import Sweeper
from leeq.setups.setup_base import ExperimentalSetup
from leeq.utils import setup_logging

from urllib.parse import urlparse

logger = setup_logging(__name__)


class QubiCCircuitSetup(ExperimentalSetup):
    """
    The QubiCCircuitSetup class defines a setup for using the qubic system. Any setup that uses the qubic system should
    inherit from this class.
    """

    def __init__(self, name: str, fpga_config: dict, channel_configs: dict, runner: Any,
                 leeq_channel_to_qubic_channel: Dict[str, str]):
        """
        Initialize the QubiCCircuitSetup class.

        Parameters:
            name (str): The name of the setup.
            fpga_config (dict): The configuration of the FPGA for qubic systetm. Refer to QubiC documents.
            channel_configs (dict): The configuration of the channels for qubic system. Refer to QubiC documents.
            runner (Any): The runner to use. Refer to QubiC documents.
            leeq_channel_to_qubic_channel (Dict[str, str]): The mapping from leeq channel to qubic channel.
        """
        self._load_qubic_package()
        super().__init__(name)

        self._runner = runner

        self._compiler = QubiCCircuitListLPBCompiler(leeq_channel_to_qubic_channel=leeq_channel_to_qubic_channel)

        self._current_context = None
        self._measurement_results: Dict[UUID, MeasurementResult] = {}

        self._fpga_config = fpga_config
        self._channel_configs = channel_configs
        self._result = None

    @staticmethod
    def _load_qubic_package():
        """
        Validate the qubic installation by importing the packages.
        """
        try:
            # QubiC toolchain for compiling circuits
            import qubic.toolchain as tc
            # QubiC configuration management libraries
            import qubitconfig.qchip as qc
            from distproc.hwconfig import FPGAConfig, load_channel_configs
        except ImportError:
            raise ImportError(
                'Importing QubiC toolchain failed. Please install the QubiC toolchain first.'
                ' Refer to https://gitlab.com/LBL-QubiC')

        return tc, qc, FPGAConfig, load_channel_configs

    def run(self, lpb: LogicalPrimitiveBlock, sweep: Sweeper):
        """
        Run the experiment.

        The experiment run iterates all the parameters described by the sweeper. Each iteration can be break into
         four steps:

        1. Compile the measurement lpb to instructions that going to be passed to the compiler.
        2. Upload the instruction to the compiler, including changing frequencies of the generators etc. Get everything
            ready for the experiment.
        3. Fire the experiment and wait for it to finish.
        4. Collect the data from the compiler and commit it to the measurement primitives.

        So the setup should implement the following methods:
        2. `update_setup_parameters`: Update the setup parameters of the compiler. Usually this function calculates
            the frequencies of the generators etc and pass it to specific experiment setup class to further upload.
        3. `fire_experiment`: Fire the experiment and wait for it to finish.
        4. `collect_data`: Collect the data from the compiler and commit it to the measurement primitives.

        Note that the collected data will be committed to the measurement primitives by the engine, so the setup
            should not commit the data to the measurement primitives.

        The compiler should mainly implement the compile_lpb, like compiling the lpb into a format acceptable by the
        particular setup. This abstraction is to allow the compiler to be used in different setups. For example, the
        compiler can be used in a local setup, or a remote setup.

        Parameters:
            lpb (LogicalPrimitiveBlock): The logical primitive block to run.
            sweep (Sweeper): The sweeper to use.
        """
        return self._engine.run(lpb, sweep)

    def update_setup_parameters(self, context: ExperimentContext):
        """
        Update the setup parameters of the compiler. It accepts the compiled instructions from the compiler, and update
        the local cache first. then use push_instrument_settings to push the settings to the instruments.

        Parameters:
            context (Any): The context between setup and compiler. Generated by the compiler.
        """
        raise NotImplementedError()

    def fire_experiment(self, context=None):
        """
        Fire the experiment and wait for it to finish.
        """
        self._result = None
        tc, qc, FPGAConfig, load_channel_configs = self._load_qubic_package()

        compiled_instructions = tc.run_compile_stage(context.instructions, fpga_config=self._fpga_config, qchip=None)
        asm_prog = tc.run_assemble_stage(compiled_instructions, self._channel_configs)

        acquisition_type = self._status.get_parameters('Acquisition_Type')
        n_total_shots = self._status.get_parameters('Shot_Number')
        delay_per_shot = self._status.get_parameters('Shot_Period') * 1e-6

        assert acquisition_type in ['IQ', 'traces'], "Acquisition type should be either IQ or traces. Got " + \
                                                     str(acquisition_type)

        if acquisition_type == 'IQ':
            self._result = self._runner.run_circuit(
                n_total_shots=n_total_shots,
                reads_per_shot=1,  # Number of values per shot per channel to read back from accbuf.
                # Unless there is mid-circuit measurement involved this is typically 1
                # TODO: add support for mid-circuit measurement
                delay_per_shot=delay_per_shot,  # delay time (in seconds) per single shot of the circuit
                from_server=False
                # set to true if calling over RPC. If True, pack returned s11 arrays into byte objects
            )
        elif acquisition_type == 'traces':
            # load_and_run_acq is to load the program given by raw_asm_prog and acquire raw
            # (or downconverted) adc traces.
            self._result = self._runner.load_and_run_acq(
                raw_asm_prog=asm_prog,  # The compiled program
                n_total_shots=1,  # number of shots to run. Program is restarted from
                # the beginning for each new shot
                nsamples=8192,  # number of samples to read from the acq buffer
                acq_chans=['0'],  # list of channels to acquire
                # current channel mapping is:
                # '0': ADC_237_2 (main readout ADC)
                # '1': ADC_237_0 (other ADC connected in gateware)
                trig_delay=0,  # delay between trigger and start of acquisition
                # time to delay acquisition, relative to circuit start.
                # NOTE: this value, in units of clock cycles, is a 16-bit value. So, it
                # maxes out at CLK_PERIOD*(2**16) = 131.072e-6
                decimator=0,
                # decimation interval when sampling. e.g. 0 means full sample rate, 1
                # means capture every other sample, 2 means capture every third sample, etc
                from_server=False,
                # set to true if calling over RPC. If True, pack returned acq arrays into
                # byte objects.
            )

    def collect_data(self, context: ExperimentContext):
        """
        Collect the data from the compiler and commit it to the measurement primitives.
        """

        # TODO: Implement mapping from returned data to each measurement primitive

        context.results = self._result

        raise NotImplementedError()

        return context


class QubiCSingleBoardRemoteRPCSetup(QubiCCircuitSetup):

    def __init__(self, name: str, fpga_config: dict, channel_configs: dict, rpc_uri: str,
                 leeq_channel_to_qubic_channel: Dict[str, str]):

        try:
            from qubic.rpc_client import CircuitRunnerClient
        except ImportError:
            msg = 'Importing QubiC RPC client failed. Please install the QubiC toolchain first.'
            logger.error(msg)
            raise ImportError(msg)

        parsed_uri = urlparse(rpc_uri)

        runner = CircuitRunnerClient(
            ip=parsed_uri.hostname,
            port=parsed_uri.port,
        )

        super().__init__(name=name, fpga_config=fpga_config, channel_configs=channel_configs, runner=runner,
                         leeq_channel_to_qubic_channel=leeq_channel_to_qubic_channel)
