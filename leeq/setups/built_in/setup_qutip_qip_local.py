from leeq.core.primitives.logical_primitives import LogicalPrimitiveBlock
from leeq.experiments.sweeper import Sweeper
from leeq.setups.setup_base import ExperimentalSetup


class QuTipQIPLocalSetup(ExperimentalSetup):
    """
    The QuTipQIPLocalSetup class defines a local setup for for using the qutip package to simulate the experiment
    at pulse level, at the local machine.
    """

    def __init__(self):
        """
        Initialize the QuTipQIPLocalSetup class.
        """
        name = 'qutip_qip_local'
        from leeq.compiler.qutip.backend_qutip import BackendQutipQIP
        from leeq.core.engine.grid_sweep_engine import GridSerialSweepEngine
        self._backend = BackendQutipQIP()
        self._engine = GridSerialSweepEngine(backend=self._backend, setup=self, name=name + '.engine')
        self._current_context = None
        super().__init__(name)

    def run(self, lpb: LogicalPrimitiveBlock, sweep: Sweeper):
        """
        Run the experiment.

        The experiment run iterates all the parameters described by the sweeper. Each iteration can be break into
         four steps:

        1. Compile the measurement lpb to instructions that going to be passed to the compiler.
        2. Upload the instruction to the compiler, including changing frequencies of the generators etc. Get everything
            ready for the experiment.
        3. Fire the experiment and wait for it to finish.
        4. Collect the data from the compiler and commit it to the measurement primitives.

        So the setup should implement the following methods:
        2. `update_setup_parameters`: Update the setup parameters of the compiler. Usually this function calculates
            the frequencies of the generators etc and pass it to specific experiment setup class to further upload.
        3. `fire_experiment`: Fire the experiment and wait for it to finish.
        4. `collect_data`: Collect the data from the compiler and commit it to the measurement primitives.

        Note that the collected data will be committed to the measurement primitives by the engine, so the setup
            should not commit the data to the measurement primitives.

        The compiler should mainly implement the compile_lpb, like compiling the lpb into a format acceptable by the
        particular setup. This abstraction is to allow the compiler to be used in different setups. For example, the
        compiler can be used in a local setup, or a remote setup.

        Parameters:
            lpb (LogicalPrimitiveBlock): The logical primitive block to run.
            sweep (Sweeper): The sweeper to use.
        """
        return self._engine.run(lpb, sweep)

    def update_setup_parameters(self, context):
        """
        Update the setup parameters of the compiler. It accepts the compiled instructions from the compiler, and update
        the local cache first. then use push_instrument_settings to push the settings to the instruments.

        Parameters:
            context (Any): The context between setup and compiler. Generated by the compiler.
        """
        self._current_context = context

    def fire_experiment(self, context=None):
        """
        Fire the experiment and wait for it to finish.
        """

        if context is not None:
            self._current_context = context

        # TODO: Actually run the simulation here

        pass

    def collect_data(self, context):
        """
        Collect the data from the compiler and commit it to the measurement primitives.
        """

        if context is not None:
            self._current_context = context

        # TODO: actually collect the data here
