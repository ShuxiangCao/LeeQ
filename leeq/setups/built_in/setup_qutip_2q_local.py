import numpy as np

from leeq.core.context import ExperimentContext
from leeq.core.primitives.logical_primitives import LogicalPrimitiveBlock
from leeq.experiments.sweeper import Sweeper
from leeq.setups.setup_base import ExperimentalSetup
from leeq.theory.simulation.qutip.pulsed_simulator import QutipPulsedSimulator


class QuTip2QLocalSetup(ExperimentalSetup):
    """
    The QuTipLocalSetup class defines a local setup for for using the qutip package to simulate the experiment
    at pulse level, at the local machine.
    """

    def __init__(self, sampling_rate=1e4, backend=None):
        """
        Initialize the QuTipQIPLocalSetup class.

        Parameters:
            sampling_rate (float): The sampling rate of the experiment. In Msps unit.
        """
        name = 'qutip_2q_local'
        from leeq.compiler.full_sequecing.full_sequencing import FullSequencingCompiler
        from leeq.core.engine.grid_sweep_engine import GridSerialSweepEngine
        self._compiler = FullSequencingCompiler(sampling_rate={
            0: sampling_rate,
            1: sampling_rate,
            2: sampling_rate,
            3: sampling_rate,
        })
        self._engine = GridSerialSweepEngine(compiler=self._compiler, setup=self, name=name + '.engine')
        self._current_context = None
        self._sampling_rate = sampling_rate

        self._simulator = QutipPulsedSimulator()
        self._simulator.add_qubit(
            name='q0',
            frequency=4000,
            anharmonicity=-200,
            t1=100,
            t2=100,
        )
        self._simulator.add_qubit(
            name='q1',
            frequency=4100,
            anharmonicity=-200,
            t1=100,
            t2=100,
        )
        self._simulator.build_system()

        super().__init__(name)

        self._channel_to_qubit = {
            0: 'q0',
            1: 'q0_r',
            2: 'q1',
            3: 'q1_r',
        }

    def run(self, lpb: LogicalPrimitiveBlock, sweep: Sweeper):
        """
        Run the experiment.

        The experiment run iterates all the parameters described by the sweeper. Each iteration can be break into
         four steps:

        1. Compile the measurement lpb to instructions that going to be passed to the compiler.
        2. Upload the instruction to the compiler, including changing frequencies of the generators etc. Get everything
            ready for the experiment.
        3. Fire the experiment and wait for it to finish.
        4. Collect the data from the compiler and commit it to the measurement primitives.

        So the setup should implement the following methods:
        2. `update_setup_parameters`: Update the setup parameters of the compiler. Usually this function calculates
            the frequencies of the generators etc and pass it to specific experiment setup class to further upload.
        3. `fire_experiment`: Fire the experiment and wait for it to finish.
        4. `collect_data`: Collect the data from the compiler and commit it to the measurement primitives.

        Note that the collected data will be committed to the measurement primitives by the engine, so the setup
            should not commit the data to the measurement primitives.

        The compiler should mainly implement the compile_lpb, like compiling the lpb into a format acceptable by the
        particular setup. This abstraction is to allow the compiler to be used in different setups. For example, the
        compiler can be used in a local setup, or a remote setup.

        Parameters:
            lpb (LogicalPrimitiveBlock): The logical primitive block to run.
            sweep (Sweeper): The sweeper to use.
        """
        return self._engine.run(lpb, sweep)

    def update_setup_parameters(self, context: ExperimentContext):
        """
        Update the setup parameters of the compiler. It accepts the compiled instructions from the compiler, and update
        the local cache first. then use push_instrument_settings to push the settings to the instruments.

        Parameters:
            context (Any): The context between setup and compiler. Generated by the compiler.
        """
        self._current_context = context

        self._simulator.reset()

        total_time = len(list(context.instructions['pulse_sequence'].values())[-1]) / self._sampling_rate
        measurement_time = [v[0] / self._sampling_rate for v in context.instructions['measurement_sequence']]

        self._simulator.set_measurement_time(measurement_time=measurement_time)

        self._simulator.setup_clock(
            total_time=total_time,
            time_resolution=1 / self._sampling_rate,
        )

        for (channel, freq), buffer in context.instructions['pulse_sequence'].items():

            if channel not in self._channel_to_qubit:
                msg = f'Channel {channel} is not mapped to any qubit.'
                self.logger.error(msg)
                raise ValueError(msg)

            if 'r' in self._channel_to_qubit[channel]:
                # Ignore the readout signals
                continue

            pulse = np.exp(1j * 2 * np.pi * freq * np.arange(len(buffer)) / self._sampling_rate) * buffer

            self._simulator.set_drive_buffer(
                qubit_name=self._channel_to_qubit[channel],
                pulse=pulse,
            )

    def fire_experiment(self, context=None):
        """
        Fire the experiment and wait for it to finish.
        """

        if context is not None:
            self._current_context = context

        self._result = self._simulator.run()

        pass

    def collect_data(self, context):
        """
        Collect the data from the compiler and commit it to the measurement primitives.
        """

        if context is not None:
            self._current_context = context

        # TODO: actually collect the data here
