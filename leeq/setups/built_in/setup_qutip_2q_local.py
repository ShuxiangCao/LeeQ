from typing import List

import numpy as np

from leeq.core.context import ExperimentContext
from leeq.core.engine.measurement_result import MeasurementResult
from leeq.core.primitives.logical_primitives import LogicalPrimitiveBlock
from leeq.experiments.sweeper import Sweeper
from leeq.setups.setup_base import ExperimentalSetup
from leeq.theory.simulation.qutip.pulsed_simulator import QutipPulsedSimulator


class QuTip2QLocalSetup(ExperimentalSetup):
    """
    The QuTipLocalSetup class defines a local setup for for using the qutip package to simulate the experiment
    at pulse level, at the local machine.
    """

    def __init__(self, sampling_rate=1e5, backend=None):
        """
        Initialize the QuTipQIPLocalSetup class.

        Parameters:
            sampling_rate (float): The sampling rate of the experiment. In Msps unit.
        """
        name = "qutip_2q_local"
        from leeq.compiler.full_sequencing_compiler import FullSequencingCompiler
        from leeq.core.engine.grid_sweep_engine import GridSerialSweepEngine

        self._compiler = FullSequencingCompiler(
            sampling_rate={
                0: sampling_rate,
                1: sampling_rate,
                2: sampling_rate,
                3: sampling_rate,
            }
        )
        self._engine = GridSerialSweepEngine(
            compiler=self._compiler, setup=self, name=name + ".engine"
        )
        self._current_context = None
        self._sampling_rate = sampling_rate
        self._expectation_result = None
        self._sampled_results = {}
        self._measurement_results: List[MeasurementResult] = []

        self._simulator = QutipPulsedSimulator()
        self._simulator.add_qubit(
            name="q0",
            frequency=4000,
            anharmonicity=-200,
            t1=100,
            t2=100,
        )
        self._simulator.add_qubit(
            name="q1",
            frequency=4100,
            anharmonicity=-200,
            t1=100,
            t2=100,
        )
        self._simulator.build_system()

        super().__init__(name)

        self._channel_to_qubit = {
            0: "q0",
            1: "q0_r",
            2: "q1",
            3: "q1_r",
        }

    def run(self, lpb: LogicalPrimitiveBlock, sweep: Sweeper):
        """
        Run the experiment.

        The experiment run iterates all the parameters described by the sweeper. Each iteration can be break into
         four steps:

        1. Compile the measurement lpb to instructions that going to be passed to the compiler.
        2. Upload the instruction to the compiler, including changing frequencies of the generators etc. Get everything
            ready for the experiment.
        3. Fire the experiment and wait for it to finish.
        4. Collect the data from the compiler and commit it to the measurement primitives.

        So the setup should implement the following methods:
        2. `update_setup_parameters`: Update the setup parameters of the compiler. Usually this function calculates
            the frequencies of the generators etc and pass it to specific experiment setup class to further upload.
        3. `fire_experiment`: Fire the experiment and wait for it to finish.
        4. `collect_data`: Collect the data from the compiler and commit it to the measurement primitives.

        Note that the collected data will be committed to the measurement primitives by the engine, so the setup
            should not commit the data to the measurement primitives.

        The compiler should mainly implement the compile_lpb, like compiling the lpb into a format acceptable by the
        particular setup. This abstraction is to allow the compiler to be used in different setups. For example, the
        compiler can be used in a local setup, or a remote setup.

        Parameters:
            lpb (LogicalPrimitiveBlock): The logical primitive block to run.
            sweep (Sweeper): The sweeper to use.
        """
        return self._engine.run(lpb, sweep)

    def update_setup_parameters(self, context: ExperimentContext):
        """
        Update the setup parameters of the compiler. It accepts the compiled instructions from the compiler, and update
        the local cache first. then use push_instrument_settings to push the settings to the instruments.

        Parameters:
            context (Any): The context between setup and compiler. Generated by the compiler.
        """
        self._current_context = context

        self._simulator.reset()

        total_time = (
            len(list(context.instructions["pulse_sequence"].values())[-1])
            / self._sampling_rate
        )
        measurement_time = [
            v[0] / self._sampling_rate
            for v in context.instructions["measurement_sequence"]
        ]

        self._simulator.set_measurement_time(measurement_time=measurement_time)

        self._simulator.setup_clock(
            total_time=total_time,
            time_resolution=1 / self._sampling_rate,
        )

        for (
                channel, freq), buffer in context.instructions["pulse_sequence"].items():
            if channel not in self._channel_to_qubit:
                msg = f"Channel {channel} is not mapped to any qubit."
                self.logger.error(msg)
                raise ValueError(msg)

            if "r" in self._channel_to_qubit[channel]:
                # Ignore the readout signals
                continue

            pulse = (
                np.exp(
                    1j *
                    2 *
                    np.pi *
                    freq *
                    np.arange(
                        len(buffer)) /
                    self._sampling_rate) *
                buffer)

            self._simulator.set_drive_buffer(
                qubit_name=self._channel_to_qubit[channel],
                pulse=pulse,
            )

    def _collect_one_measurement(self, measurement_entry: dict):
        """
        Collect the data for one measurement.
        """
        position, (channel, freq), tags = measurement_entry
        uuid = tags["uuid"]

        results = {
            "II": self._expectation_result[0][position],
            "IZ": self._expectation_result[1][position],
            "ZI": self._expectation_result[2][position],
            "ZZ": self._expectation_result[3][position],
        }

        self._sampled_results[(uuid, position)] = results

        prob_0_q0 = (1 + results["ZI"]) / 2
        prob_same_parity = (1 + results["ZZ"]) / 2

        # shot number by default 1000
        shot_num = tags.get("shot_num", 1000)

        # Now we mock the single shot data from the expectation results
        # First we sample the data from the expectation results of ZI.
        # Then we sample the data from the expectation results of ZZ.
        # Finally we combine the two results to get the single shot data.
        sample_0_q0 = np.random.choice(
            [-1, 1], size=(shot_num,), p=[1 - prob_0_q0, prob_0_q0]
        )
        sample_same_parity = np.random.choice(
            [-1, 1], size=(shot_num,), p=[1 - prob_same_parity, prob_same_parity]
        )
        sample_0_q1 = sample_0_q0 * sample_same_parity
        sample_0_q0 = (sample_0_q0 + 1) / 2
        sample_0_q1 = (sample_0_q1 + 1) / 2

        if "q0" in self._channel_to_qubit[channel]:
            result = sample_0_q0
        else:
            result = sample_0_q0
            self._sampled_results[(uuid, position)] = sample_0_q1

        self._sampled_results[(uuid, position)] = result

    def fire_experiment(self, context=None):
        """
        Fire the experiment and wait for it to finish.
        """

        if context is not None:
            self._current_context = context

        self._sampled_results = {}

        self._expectation_result = self._simulator.run()

        for entry in context.instructions["measurement_sequence"]:
            self._collect_one_measurement(entry)

    def collect_data(self, context: ExperimentContext):
        """
        Collect the data from the compiler and commit it to the measurement primitives.
        """

        if context is not None:
            self._current_context = context

        ordered_results = {}

        for uuid, position in self._sampled_results.keys():
            if uuid in ordered_results:
                ordered_results[uuid].append(
                    (position, self._sampled_results[(uuid, position)])
                )
            else:
                ordered_results[uuid] = [
                    (position, self._sampled_results[(uuid, position)])
                ]

        for uuid, results in ordered_results.items():
            results.sort(key=lambda x: x[0])
            result_array = [v[1] for v in results]

            m_result = MeasurementResult(
                step_no=self._current_context.step_no,
                data=result_array[0],
                mprim_uuid=uuid,
            )

            for i in range(1, len(result_array)):
                m_result.append(result_array[i])

            self._measurement_results.append(m_result)

        self._current_context.results = self._measurement_results

        return context
