from __future__ import annotations
import uuid

import os
from typing import List

import dill
import numpy as np

from mllm import get_embeddings
from mllm.utils.maps import p_map
from mllm.utils.retry import standard_multi_attempts

from .recall_logger import RecallLogger, to_log_item
from .w_memory import WMemoryItem, WMemorySuppressingItem, WorkingMemory


class Idea:
    """
    Long term memory items
    """

    def __init__(self, description):
        self.description = description
        self.idea_id = uuid.uuid4().int
        self.data = None

    def get_score(self, w_memory: WorkingMemory):
        pass

    def run_idea(self, w_memory: WorkingMemory) -> IdeaResult:
        return IdeaResult(self, True)

    def __hash__(self):
        return self.idea_id

    def __eq__(self, other):
        return self.idea_id == other.idea_id

    def __repr__(self):
        return "Idea('" + self.description + "')"


class EmbedIdea(Idea):
    def __init__(self, description, embed_src: List[str]):
        super().__init__(description)
        self._embed_src = []
        self.embeddings = None
        self.add_embed_src(embed_src)

    def add_embed_src(self, src: str | List[str]):
        if isinstance(src, str):
            src = [src]
        for s in src:
            if len(s) != 0:
                self._embed_src.append(s)
        self.embeddings = get_embeddings(self._embed_src)

    def get_score(self, w_memory: WorkingMemory):
        if len(self.embeddings) == 0:
            return 0
        similarities = np.dot(np.array(self.embeddings), w_memory.stimuli_embeddings.T)
        similarities = np.max(similarities, axis=0)
        score = np.max(similarities)
        return score

    def run_idea(self, w_memory: WorkingMemory) -> IdeaResult:
        raise NotImplementedError


class IdeaResult:
    """
    Container for results generated by an idea run.

    :ivar success: True if the run was successful, False otherwise
    :ivar idea: the idea that generated this result
    :ivar new_wm_items: a list of working memory items generated by the run
    :ivar tags_to_remove: a list of working memory item tags to be removed
    """
    success: bool
    idea: Idea
    new_wm_items: List[WMemoryItem]
    tags_to_remove: List[str]

    def __init__(self, idea, success):
        self.success = success
        self.idea = idea
        self.new_wm_items = []
        self.tags_to_remove = []
        self.function_to_apply = []

    def add_new_wm_content(self, content: str, tag: str):
        self.new_wm_items.append(WMemoryItem(content, tag))

    def add_new_wm_item(self, item: WMemoryItem):
        self.new_wm_items.append(item)

    def add_suppressing_wm_item(self, lifetime=3, tag=None):
        """
        Add an item suppressing the idea for a certain amount of time
        """
        if isinstance(lifetime, list):
            # sample from the list
            lifetime = np.random.choice(lifetime)
        self.add_new_wm_item(WMemorySuppressingItem(self.idea, lifetime=lifetime))


class RecallResult:
    """
    Container for results generated by a long term memory recall.

    :ivar idea_results: a list of idea results generated in the recall
    """
    idea_results: List[IdeaResult]

    def __init__(self, idea_results: List[IdeaResult]):
        self.idea_results = idea_results

    def update_wm_from_res(self, wm: WorkingMemory):
        # remove tags
        tags_to_remove = set()
        for idea_res in self.idea_results:
            tags_to_remove.update(idea_res.tags_to_remove)
        wm.remove_item_by_tags(tags_to_remove)

        # add new items
        for idea_res in self.idea_results:
            for item in idea_res.new_wm_items:
                wm.add_item(item)

        for idea_res in self.idea_results:
            for func in idea_res.function_to_apply:
                func(wm)

        # refresh cache
        wm.refresh_cache()

    def no_success_idea(self):
        for idea_res in self.idea_results:
            if idea_res.success:
                return False
        return True


class LongTermMemory:
    def __init__(self):
        self.ideas: List[Idea] = []
        self.src_embeddings = None
        self.recall_workers = 8

    @classmethod
    def from_ideas(cls, ideas: List[Idea]):
        lt_memory = cls()
        lt_memory.ideas = ideas
        return lt_memory

    def add_idea(self, idea: Idea):
        self.ideas.append(idea)

    def get_scores(self, w_memory: WorkingMemory):
        if not self.ideas:
            raise ValueError("Idea contains no ideas")
        idea_scores = []
        for idea in self.ideas:
            idea_scores.append(idea.get_score(w_memory))
        return np.array(idea_scores)

    def get_ideas_by_score(self, w_memory: WorkingMemory, k=5,
                           excluded_idea: List[Idea] = None) -> List[Idea]:
        scores = self.get_scores(w_memory)
        if scores is None:
            return []
        highest_k_indices = np.argsort(scores)
        if excluded_idea is None:
            excluded_idea = []
        must_trigger_idea = []
        idea_list = []
        for i in range(len(highest_k_indices) - 1, -1, -1):
            this_index = highest_k_indices[i]
            if len(idea_list) >= k:
                break
            this_idea = self.ideas[this_index]
            if this_idea in excluded_idea:
                continue
            # don't add the idea if its score is lower than 0
            this_score = scores[this_index]
            if this_score < 0:
                continue
            if this_score > 1.0:
                must_trigger_idea.append(this_idea)
            else:
                idea_list.append(this_idea)
        idea_list.extend(must_trigger_idea)
        return idea_list

    def save_memory(self, save_path):
        with open(save_path, 'wb') as f:
            dill.dump(self, f)

    @staticmethod
    def load_memory(load_path):
        # if not exists, return None
        if not os.path.exists(load_path):
            return None
        with open(load_path, 'rb') as f:
            lt_memory = dill.load(f)
        return lt_memory

    #@standard_multi_attempts
    def recall_by_wm(self, w_memory: WorkingMemory, top_k=5) -> RecallResult:
        """
        Recall ideas from working memory.
        """
        if len(self.ideas) == 0:
            return RecallResult([])

        excluded_idea = w_memory.get_suppressed_ideas()
        ideas_from_score = self.get_ideas_by_score(w_memory, top_k, excluded_idea)
        ideas_from_score = list(set(ideas_from_score))

        if len(RecallLogger.active_loggers) > 0:
            old_stimuli = w_memory.stimuli
            old_wm_in_prompt = w_memory.get_in_prompt_format()

        def run_idea(idea: Idea):
            return idea.run_idea(w_memory)

        triggered_ideas = []
        new_wm_items = []
        idea_results = []

        for idea, res in p_map(run_idea, ideas_from_score, title="Recalling"):
            res: IdeaResult
            if res.success:
                idea_results.append(res)
                triggered_ideas.append(res.idea)
                new_wm_items.extend(res.new_wm_items)

        if len(RecallLogger.active_loggers) > 0:
            log = f"""
                    {to_log_item(ideas_from_score, "Idea has run")}
                    {to_log_item(triggered_ideas, "Triggered Ideas")}
                    {to_log_item(old_wm_in_prompt, "Old Working Memory")}
                    {to_log_item(old_stimuli, "Stimuli")}
                    """
            #{to_log_item(new_wm_items, "New Working Memory items")}
            RecallLogger.add_log_to_all(log)

        return RecallResult(idea_results)
