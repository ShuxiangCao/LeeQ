{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to LeeQ documentation.","text":"<p>LeeQ is a light-weight python package for orchestrating microwave pulses alongside with other related instrument, developed for quantum computing experiments with easy to use syntax.</p> <p>10 minutes quick start guide 1 hour full tutorial</p>"},{"location":"chronicle_api_quick_reference/","title":"Chronicle Session Viewer - Quick Reference","text":""},{"location":"chronicle_api_quick_reference/#launch-methods","title":"Launch Methods","text":""},{"location":"chronicle_api_quick_reference/#basic-launch","title":"Basic Launch","text":"<pre><code>from leeq.chronicle import Chronicle\nchronicle = Chronicle()\nchronicle.launch_viewer()  # Opens at http://localhost:8051\n</code></pre>"},{"location":"chronicle_api_quick_reference/#custom-port","title":"Custom Port","text":"<pre><code>chronicle.launch_viewer(port=8055)\n</code></pre>"},{"location":"chronicle_api_quick_reference/#production-mode","title":"Production Mode","text":"<pre><code>chronicle.launch_viewer(debug=False)\n</code></pre>"},{"location":"chronicle_api_quick_reference/#remote-access","title":"Remote Access","text":"<pre><code>chronicle.launch_viewer(host='0.0.0.0', port=8051)\n</code></pre>"},{"location":"chronicle_api_quick_reference/#non-blocking-launch","title":"Non-Blocking Launch","text":"<pre><code>import threading\nviewer_thread = threading.Thread(\n    target=chronicle.launch_viewer,\n    kwargs={'port': 8051, 'debug': False},\n    daemon=True\n)\nviewer_thread.start()\n</code></pre>"},{"location":"chronicle_api_quick_reference/#common-patterns","title":"Common Patterns","text":""},{"location":"chronicle_api_quick_reference/#in-calibration-script","title":"In Calibration Script","text":"<pre><code># Start of calibration\nchronicle = Chronicle()\nchronicle.launch_viewer()\nprint(\"Monitor at http://localhost:8051\")\n\n# Run experiments - they appear automatically\nrun_calibrations()\n</code></pre>"},{"location":"chronicle_api_quick_reference/#in-jupyter-notebook","title":"In Jupyter Notebook","text":"<pre><code># Cell 1: Launch viewer\nchronicle = Chronicle()\nchronicle.launch_viewer(debug=False)\n\n# Cell 2: Run experiments\nexp = QubitSpectroscopy(...)\n# Appears in viewer within 5 seconds\n</code></pre>"},{"location":"chronicle_api_quick_reference/#with-error-handling","title":"With Error Handling","text":"<pre><code>try:\n    chronicle.launch_viewer(port=8051)\nexcept OSError:\n    chronicle.launch_viewer(port=8052)  # Try alternative\n</code></pre>"},{"location":"chronicle_api_quick_reference/#troubleshooting","title":"Troubleshooting","text":""},{"location":"chronicle_api_quick_reference/#port-in-use","title":"Port In Use","text":"<pre><code># Try different port\nchronicle.launch_viewer(port=8052)\n</code></pre>"},{"location":"chronicle_api_quick_reference/#no-experiments-showing","title":"No Experiments Showing","text":"<pre><code># Check environment\nimport os\nos.environ['CHRONICLE_LOGGING'] = 'True'\n\n# Verify chronicle is active\nchronicle.get_current_session_entries()\n</code></pre>"},{"location":"chronicle_api_quick_reference/#manual-refresh","title":"Manual Refresh","text":"<ul> <li>Click \"Refresh\" button in viewer</li> <li>Or wait 5 seconds for auto-update</li> </ul>"},{"location":"chronicle_api_quick_reference/#key-differences","title":"Key Differences","text":"Feature Session Viewer Historical Viewer Launch <code>chronicle.launch_viewer()</code> <code>python chronicle_viewer.py</code> Data Live session HDF5 files Port 8051 8050 Updates Auto (5 sec) Static Use During calibration Post-analysis"},{"location":"chronicle_api_quick_reference/#parameters","title":"Parameters","text":"<pre><code>chronicle.launch_viewer(\n    debug=True,      # Debug mode with auto-reload\n    port=8051,       # Server port\n    host='127.0.0.1' # Host address\n)\n</code></pre>"},{"location":"chronicle_api_quick_reference/#related-methods","title":"Related Methods","text":"<pre><code># Chronicle session management\nchronicle.is_active()                    # Check if session active\nchronicle.get_current_session_entries()  # Get session experiments\nchronicle.start_new_session()            # Start new session\nchronicle.end_current_session()          # End current session\n</code></pre>"},{"location":"chronicle_session_viewer/","title":"Chronicle Session Viewer Documentation","text":""},{"location":"chronicle_session_viewer/#overview","title":"Overview","text":"<p>The Chronicle Session Viewer is a real-time monitoring dashboard for active Chronicle sessions in LeeQ. Unlike the historical viewer that loads completed chronicle files, the session viewer connects directly to the Chronicle singleton instance to display experiments as they complete during calibration workflows.</p>"},{"location":"chronicle_session_viewer/#purpose-and-benefits","title":"Purpose and Benefits","text":""},{"location":"chronicle_session_viewer/#what-is-the-session-viewer","title":"What is the Session Viewer?","text":"<p>The session viewer is a web-based dashboard that provides: - Real-time monitoring of experiments during active calibration sessions - Automatic updates every 5 seconds showing newly completed experiments - Direct integration with Chronicle singleton - no file loading required - Familiar interface using the same tree view and layout as the historical viewer</p>"},{"location":"chronicle_session_viewer/#how-it-differs-from-the-historical-viewer","title":"How it Differs from the Historical Viewer","text":"Feature Session Viewer Historical Viewer Data Source Live Chronicle singleton HDF5 chronicle files Use Case Active monitoring during calibration Post-session analysis Launch Method <code>chronicle.launch_viewer()</code> Standalone script or import Updates Auto-refresh every 5 seconds Static file content Default Port 8051 8050"},{"location":"chronicle_session_viewer/#installation-and-requirements","title":"Installation and Requirements","text":"<p>The session viewer is included with the LeeQ package. No additional installation is required beyond the standard LeeQ dependencies:</p> <pre><code># Standard LeeQ installation includes viewer\npip install -e .\n</code></pre> <p>Required packages (automatically installed with LeeQ): - dash &gt;= 2.0.0 - dash-bootstrap-components &gt;= 1.0.0 - plotly &gt;= 5.0.0 - h5py (for chronicle data)</p>"},{"location":"chronicle_session_viewer/#usage-patterns-and-examples","title":"Usage Patterns and Examples","text":""},{"location":"chronicle_session_viewer/#basic-usage-launching-the-viewer","title":"Basic Usage - Launching the Viewer","text":"<p>The simplest way to launch the session viewer is through the Chronicle singleton:</p> <pre><code>from leeq.chronicle import Chronicle\n\n# Get Chronicle singleton instance\nchronicle = Chronicle()\n\n# Launch the viewer dashboard\nchronicle.launch_viewer()\n</code></pre> <p>This opens a web browser to <code>http://localhost:8051</code> showing the current session.</p>"},{"location":"chronicle_session_viewer/#example-1-monitoring-during-calibration-script","title":"Example 1: Monitoring During Calibration Script","text":"<pre><code>\"\"\"calibration_session.py - Example calibration workflow with monitoring\"\"\"\n\nfrom leeq.chronicle import Chronicle\nfrom leeq.setups import setup_from_config\nimport time\n\ndef run_calibration():\n    # Initialize setup\n    setup = setup_from_config(\"config.json\")\n\n    # Launch viewer for monitoring\n    chronicle = Chronicle()\n    chronicle.launch_viewer(debug=False)  # Run in production mode\n\n    print(\"Chronicle viewer launched at http://localhost:8051\")\n    print(\"Starting calibration experiments...\")\n\n    # Run experiments - they'll appear in viewer as they complete\n    for qubit in setup.get_qubits():\n        # Resonator spectroscopy\n        exp = ResonatorSpectroscopy(qubit=qubit)\n        print(f\"Completed resonator spectroscopy for {qubit.name}\")\n        time.sleep(2)  # Viewer will update within 5 seconds\n\n        # Qubit spectroscopy  \n        exp = QubitSpectroscopy(qubit=qubit)\n        print(f\"Completed qubit spectroscopy for {qubit.name}\")\n        time.sleep(2)\n\n    print(\"Check the viewer to see all completed experiments!\")\n    input(\"Press Enter to continue...\")\n\nif __name__ == \"__main__\":\n    run_calibration()\n</code></pre>"},{"location":"chronicle_session_viewer/#example-2-interactive-jupyter-notebook-usage","title":"Example 2: Interactive Jupyter Notebook Usage","text":"<pre><code># Cell 1 - Setup and launch viewer\nfrom leeq.chronicle import Chronicle\nfrom leeq.setups import setup_from_config\n\n# Initialize\nsetup = setup_from_config(\"my_setup.json\")\nchronicle = Chronicle()\n\n# Launch viewer in background\nchronicle.launch_viewer(port=8051, debug=True)\nprint(\"Viewer running at http://localhost:8051\")\n</code></pre> <pre><code># Cell 2 - Run experiments (viewer updates automatically)\nqubit = setup.get_qubit(\"Q1\")\n\n# These experiments will appear in the viewer as they complete\nexp1 = ResonatorSpectroscopy(qubit=qubit, start=6000, stop=6200, step=2)\nexp2 = QubitSpectroscopy(qubit=qubit, start=4900, stop=5100, step=1)\n</code></pre> <pre><code># Cell 3 - Check specific experiments in viewer\nprint(\"Open http://localhost:8051 to see your experiments\")\nprint(\"The viewer refreshes every 5 seconds automatically\")\n</code></pre>"},{"location":"chronicle_session_viewer/#example-3-custom-port-and-configuration","title":"Example 3: Custom Port and Configuration","text":"<pre><code>from leeq.chronicle import Chronicle\n\nchronicle = Chronicle()\n\n# Launch with custom settings\nchronicle.launch_viewer(\n    port=8055,           # Custom port to avoid conflicts\n    debug=False,         # Production mode (no auto-reload)\n    host='0.0.0.0'      # Allow external connections\n)\n</code></pre>"},{"location":"chronicle_session_viewer/#example-4-multi-session-workflow","title":"Example 4: Multi-Session Workflow","text":"<pre><code>\"\"\"multi_session.py - Running multiple calibration sessions\"\"\"\n\nfrom leeq.chronicle import Chronicle\nimport subprocess\nimport time\n\ndef monitor_sessions():\n    chronicle = Chronicle()\n\n    # Launch viewer once\n    chronicle.launch_viewer(port=8051)\n\n    # Run multiple calibration sessions\n    sessions = [\"morning_cal.py\", \"afternoon_cal.py\", \"evening_cal.py\"]\n\n    for session_script in sessions:\n        print(f\"Starting {session_script}\")\n        subprocess.run([\"python\", session_script])\n\n        print(f\"Completed {session_script}\")\n        print(\"Check viewer for results at http://localhost:8051\")\n        time.sleep(5)  # Allow viewer to update\n\n        response = input(\"Continue to next session? (y/n): \")\n        if response.lower() != 'y':\n            break\n\nif __name__ == \"__main__\":\n    monitor_sessions()\n</code></pre>"},{"location":"chronicle_session_viewer/#configuration-options","title":"Configuration Options","text":"<p>The <code>launch_viewer()</code> method accepts several configuration parameters:</p> <pre><code>chronicle.launch_viewer(\n    debug=True,          # Enable debug mode with auto-reload (default: True)\n    port=8051,          # Port number for the server (default: 8051)\n    host='127.0.0.1',   # Host address (default: localhost only)\n    **kwargs            # Additional Dash server arguments\n)\n</code></pre>"},{"location":"chronicle_session_viewer/#configuration-parameters","title":"Configuration Parameters","text":"Parameter Type Default Description <code>debug</code> bool True Enable debug mode with auto-reload and error messages <code>port</code> int 8051 Port number for the web server <code>host</code> str '127.0.0.1' Host address ('0.0.0.0' for external access) <code>dev_tools_hot_reload</code> bool False Enable hot reload in development <code>use_reloader</code> bool True (if debug) Auto-reload on code changes"},{"location":"chronicle_session_viewer/#port-selection-guidelines","title":"Port Selection Guidelines","text":"<ul> <li>8051: Default for session viewer (recommended)</li> <li>8050: Reserved for historical chronicle viewer</li> <li>8000-8010: Common range for development</li> <li>Custom ports: Use if running multiple viewers simultaneously</li> </ul>"},{"location":"chronicle_session_viewer/#troubleshooting-guide","title":"Troubleshooting Guide","text":""},{"location":"chronicle_session_viewer/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"chronicle_session_viewer/#issue-1-address-already-in-use-error","title":"Issue 1: \"Address already in use\" Error","text":"<p>Symptom: <pre><code>OSError: [Errno 48] Address already in use\n</code></pre></p> <p>Solution: <pre><code># Use a different port\nchronicle.launch_viewer(port=8052)\n\n# Or kill the existing process\n# In terminal: lsof -i :8051\n# Then: kill -9 &lt;PID&gt;\n</code></pre></p>"},{"location":"chronicle_session_viewer/#issue-2-viewer-shows-no-experiments-in-current-session","title":"Issue 2: Viewer Shows \"No experiments in current session\"","text":"<p>Symptom: Empty viewer despite running experiments</p> <p>Possible Causes and Solutions:</p> <ol> <li> <p>Chronicle not initialized properly <pre><code># Ensure Chronicle singleton is initialized\nfrom leeq.chronicle import Chronicle\nchronicle = Chronicle()\nprint(chronicle.is_active())  # Should be True\n</code></pre></p> </li> <li> <p>Experiments not being logged <pre><code># Check chronicle logging is enabled\nimport os\nos.environ['CHRONICLE_LOGGING'] = 'True'\n</code></pre></p> </li> <li> <p>Session not active <pre><code># Start a new session if needed\nchronicle.start_new_session()\n</code></pre></p> </li> </ol>"},{"location":"chronicle_session_viewer/#issue-3-viewer-not-updating-automatically","title":"Issue 3: Viewer Not Updating Automatically","text":"<p>Symptom: New experiments don't appear without manual refresh</p> <p>Solution: <pre><code># Check browser console for errors\n# Ensure interval component is working\n# Try manual refresh button as fallback\n# Check network tab in browser dev tools\n</code></pre></p>"},{"location":"chronicle_session_viewer/#issue-4-cannot-connect-to-viewer","title":"Issue 4: Cannot Connect to Viewer","text":"<p>Symptom: Browser shows \"Unable to connect\"</p> <p>Solutions:</p> <ol> <li> <p>Check if server is running <pre><code># Check if process is listening on port\nlsof -i :8051\n</code></pre></p> </li> <li> <p>Firewall or network issues <pre><code># Try using localhost explicitly\n# Open http://127.0.0.1:8051 instead of localhost:8051\n</code></pre></p> </li> <li> <p>Remote access needed <pre><code># Allow external connections\nchronicle.launch_viewer(host='0.0.0.0', port=8051)\n</code></pre></p> </li> </ol>"},{"location":"chronicle_session_viewer/#issue-5-slow-performance-with-many-experiments","title":"Issue 5: Slow Performance with Many Experiments","text":"<p>Symptom: Dashboard becomes sluggish with 100+ experiments</p> <p>Solutions:</p> <ol> <li> <p>Increase polling interval <pre><code># Modify in session_dashboard.py if needed\n# Change interval from 5000ms to 10000ms\n</code></pre></p> </li> <li> <p>Clear old sessions <pre><code># Start fresh session\nchronicle.end_current_session()\nchronicle.start_new_session()\n</code></pre></p> </li> <li> <p>Use filtering in viewer</p> </li> <li>Focus on specific experiment types</li> <li>Collapse unused tree branches</li> </ol>"},{"location":"chronicle_session_viewer/#debug-mode-tips","title":"Debug Mode Tips","text":"<p>When running in debug mode (<code>debug=True</code>): - Server auto-reloads on code changes - Detailed error messages in browser - Console output shows all callbacks - Performance may be slower</p> <p>For production use: <pre><code>chronicle.launch_viewer(debug=False)\n</code></pre></p>"},{"location":"chronicle_session_viewer/#api-reference","title":"API Reference","text":""},{"location":"chronicle_session_viewer/#chroniclelaunch_viewer","title":"Chronicle.launch_viewer()","text":"<p>Launch the session viewer dashboard for monitoring active experiments.</p> <pre><code>def launch_viewer(self, **kwargs) -&gt; None:\n    \"\"\"\n    Launch chronicle viewer dashboard for current session.\n\n    This method launches a web-based dashboard for monitoring experiments\n    in the active Chronicle session. The dashboard polls every 5 seconds\n    to display newly completed experiments.\n\n    Args:\n        debug (bool): Whether to run in debug mode (default: True)\n        port (int): Port to run the server on (default: 8051)\n        host (str): Host address (default: '127.0.0.1')\n        **kwargs: Additional arguments passed to the Dash server\n\n    Returns:\n        None (launches server in current thread)\n\n    Raises:\n        RuntimeError: If Chronicle is not properly initialized\n        OSError: If port is already in use\n\n    Example:\n        &gt;&gt;&gt; from leeq.chronicle import Chronicle\n        &gt;&gt;&gt; chronicle = Chronicle()\n        &gt;&gt;&gt; chronicle.launch_viewer(port=8051, debug=False)\n    \"\"\"\n</code></pre>"},{"location":"chronicle_session_viewer/#session-dashboard-callbacks","title":"Session Dashboard Callbacks","text":"<p>The session viewer implements several Dash callbacks:</p>"},{"location":"chronicle_session_viewer/#update_session_view","title":"update_session_view()","text":"<p>Updates the experiment tree and display panels every 5 seconds or on manual refresh.</p>"},{"location":"chronicle_session_viewer/#toggle_tree_node","title":"toggle_tree_node()","text":"<p>Handles expanding/collapsing tree nodes for navigation.</p>"},{"location":"chronicle_session_viewer/#display_experiment_info","title":"display_experiment_info()","text":"<p>Shows experiment details when an experiment is selected.</p>"},{"location":"chronicle_session_viewer/#generate_plot","title":"generate_plot()","text":"<p>Creates visualizations when plot buttons are clicked.</p>"},{"location":"chronicle_session_viewer/#chronicle-session-methods","title":"Chronicle Session Methods","text":"<p>Related Chronicle methods for session management:</p> <pre><code># Check if session is active\nchronicle.is_active() -&gt; bool\n\n# Get current session entries\nchronicle.get_current_session_entries() -&gt; List[RecordEntry]\n\n# Start new session\nchronicle.start_new_session() -&gt; None\n\n# End current session  \nchronicle.end_current_session() -&gt; None\n</code></pre>"},{"location":"chronicle_session_viewer/#best-practices","title":"Best Practices","text":""},{"location":"chronicle_session_viewer/#1-launch-early-in-workflow","title":"1. Launch Early in Workflow","text":"<p>Start the viewer at the beginning of calibration sessions: <pre><code>def main():\n    chronicle = Chronicle()\n    chronicle.launch_viewer()  # Launch first\n\n    # Then run experiments\n    run_calibrations()\n</code></pre></p>"},{"location":"chronicle_session_viewer/#2-use-appropriate-ports","title":"2. Use Appropriate Ports","text":"<p>Keep standard port assignments: - 8051 for session viewer - 8050 for historical viewer - Custom ports for multiple instances</p>"},{"location":"chronicle_session_viewer/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<pre><code>try:\n    chronicle.launch_viewer(port=8051)\nexcept OSError as e:\n    print(f\"Port 8051 in use, trying 8052...\")\n    chronicle.launch_viewer(port=8052)\n</code></pre>"},{"location":"chronicle_session_viewer/#4-production-vs-development","title":"4. Production vs Development","text":"<pre><code># Development - with debug info\nchronicle.launch_viewer(debug=True)\n\n# Production - optimized performance  \nchronicle.launch_viewer(debug=False)\n</code></pre>"},{"location":"chronicle_session_viewer/#5-document-viewer-urls","title":"5. Document Viewer URLs","text":"<pre><code># Always inform users where to find the viewer\nport = 8051\nchronicle.launch_viewer(port=port)\nprint(f\"Chronicle viewer running at http://localhost:{port}\")\nprint(\"Open this URL in your browser to monitor experiments\")\n</code></pre>"},{"location":"chronicle_session_viewer/#integration-with-leeq-workflow","title":"Integration with LeeQ Workflow","text":"<p>The session viewer integrates seamlessly with the LeeQ calibration workflow:</p> <ol> <li>Setup Phase: Initialize hardware and Chronicle</li> <li>Launch Viewer: Start monitoring dashboard</li> <li>Run Experiments: Execute calibration routines</li> <li>Monitor Progress: View completed experiments in real-time</li> <li>Analyze Results: Use historical viewer for detailed analysis later</li> </ol> <pre><code># Complete integrated workflow\nfrom leeq.chronicle import Chronicle\nfrom leeq.setups import setup_from_config\n\n# 1. Setup\nsetup = setup_from_config(\"config.json\")\nchronicle = Chronicle()\n\n# 2. Launch monitoring\nchronicle.launch_viewer()\n\n# 3. Run calibrations\ncalibrate_resonators(setup)\ncalibrate_qubits(setup)\n\n# 4. Monitor in browser at http://localhost:8051\n\n# 5. Later analysis with historical viewer\n# python scripts/chronicle_viewer.py\n</code></pre>"},{"location":"chronicle_session_viewer/#support","title":"Support","text":"<p>For issues or questions: 1. Check this troubleshooting guide 2. Review the LeeQ GitHub Issues 3. Contact the LeeQ development team</p>"},{"location":"epii-deployment-checklist/","title":"LeeQ EPII Production Deployment Checklist","text":""},{"location":"epii-deployment-checklist/#pre-deployment-checklist","title":"Pre-Deployment Checklist","text":""},{"location":"epii-deployment-checklist/#system-requirements-verification","title":"System Requirements Verification","text":"<ul> <li>[ ] Operating system meets requirements (Ubuntu 20.04+ / RHEL 8+ / SUSE 15+)</li> <li>[ ] Minimum hardware requirements met (2 cores, 4GB RAM, 20GB storage)</li> <li>[ ] Python 3.8+ installed and available</li> <li>[ ] systemd service manager available</li> <li>[ ] Network ports 50051-50099 available</li> <li>[ ] Firewall configured to allow gRPC traffic</li> </ul>"},{"location":"epii-deployment-checklist/#security-preparation","title":"Security Preparation","text":"<ul> <li>[ ] System user <code>leeq</code> created with appropriate permissions</li> <li>[ ] File system permissions configured correctly</li> <li>[ ] Network security policies reviewed and approved</li> <li>[ ] TLS certificates prepared (for production environments)</li> <li>[ ] Access control mechanisms defined</li> </ul>"},{"location":"epii-deployment-checklist/#installation-checklist","title":"Installation Checklist","text":""},{"location":"epii-deployment-checklist/#automated-installation","title":"Automated Installation","text":"<ul> <li>[ ] LeeQ source code downloaded to <code>/opt/leeq-source</code></li> <li>[ ] Installation script executed: <code>sudo ./scripts/install-systemd-service.sh</code></li> <li>[ ] Installation completed without errors</li> <li>[ ] System directories created with correct ownership:</li> <li>[ ] <code>/opt/leeq</code> (leeq:leeq)</li> <li>[ ] <code>/etc/leeq-epii</code> (root:leeq)</li> <li>[ ] <code>/var/log/leeq-epii</code> (leeq:leeq)</li> <li>[ ] <code>/var/run/leeq-epii</code> (leeq:leeq)</li> </ul>"},{"location":"epii-deployment-checklist/#service-registration","title":"Service Registration","text":"<ul> <li>[ ] Systemd service template installed: <code>/etc/systemd/system/leeq-epii@.service</code></li> <li>[ ] Systemd daemon reloaded: <code>sudo systemctl daemon-reload</code></li> <li>[ ] Service template recognized: <code>sudo systemctl list-unit-files \"leeq-epii@*.service\"</code></li> </ul>"},{"location":"epii-deployment-checklist/#configuration-checklist","title":"Configuration Checklist","text":""},{"location":"epii-deployment-checklist/#configuration-files","title":"Configuration Files","text":"<ul> <li>[ ] Configuration files created in <code>/etc/leeq-epii/</code></li> <li>[ ] Configuration syntax validated for each setup:   <pre><code>sudo -u leeq /opt/leeq/venv/bin/python -m leeq.epii.daemon --config /etc/leeq-epii/&lt;setup&gt;.json --validate\n</code></pre></li> <li>[ ] Port assignments documented and non-conflicting</li> <li>[ ] Logging levels appropriate for environment (INFO for production)</li> <li>[ ] Resource limits set appropriately (max_workers, timeout)</li> </ul>"},{"location":"epii-deployment-checklist/#environment-configuration","title":"Environment Configuration","text":"<ul> <li>[ ] Environment variables configured:</li> <li>[ ] <code>LEEQ_EPII_CONFIG_DIR=/etc/leeq-epii</code></li> <li>[ ] <code>LEEQ_EPII_LOG_LEVEL=INFO</code></li> <li>[ ] <code>PYTHONPATH=/opt/leeq</code></li> <li>[ ] System limits configured (file descriptors, memory)</li> </ul>"},{"location":"epii-deployment-checklist/#setup-specific-configuration","title":"Setup-Specific Configuration","text":""},{"location":"epii-deployment-checklist/#for-simulation-setups","title":"For Simulation Setups:","text":"<ul> <li>[ ] Backend specified (numpy/qutip)</li> <li>[ ] Number of qubits defined</li> <li>[ ] Resource allocation appropriate for simulation complexity</li> </ul>"},{"location":"epii-deployment-checklist/#for-hardware-setups","title":"For Hardware Setups:","text":"<ul> <li>[ ] Hardware type specified correctly</li> <li>[ ] Hardware configuration files present and accessible</li> <li>[ ] Connection parameters validated</li> <li>[ ] Calibration data available</li> </ul>"},{"location":"epii-deployment-checklist/#service-deployment-checklist","title":"Service Deployment Checklist","text":""},{"location":"epii-deployment-checklist/#service-enablement","title":"Service Enablement","text":"<ul> <li>[ ] Services enabled for desired setups:   <pre><code>sudo systemctl enable leeq-epii@&lt;setup_name&gt;.service\n</code></pre></li> <li>[ ] Auto-start behavior configured as required</li> </ul>"},{"location":"epii-deployment-checklist/#service-startup","title":"Service Startup","text":"<ul> <li>[ ] Services started successfully:   <pre><code>sudo systemctl start leeq-epii@&lt;setup_name&gt;.service\n</code></pre></li> <li>[ ] Service status verified:   <pre><code>sudo systemctl status leeq-epii@&lt;setup_name&gt;.service\n</code></pre></li> <li>[ ] No error messages in startup logs</li> </ul>"},{"location":"epii-deployment-checklist/#health-verification","title":"Health Verification","text":"<ul> <li>[ ] Health checks pass for all services:   <pre><code>sudo -u leeq /opt/leeq/venv/bin/python -m leeq.epii.daemon --config /etc/leeq-epii/&lt;setup&gt;.json --health-check\n</code></pre></li> <li>[ ] Services listening on configured ports:   <pre><code>sudo ss -tlnp | grep :&lt;port&gt;\n</code></pre></li> <li>[ ] gRPC connectivity verified:   <pre><code>grpcurl -plaintext localhost:&lt;port&gt; epii.v1.ExperimentPlatformService/Ping\n</code></pre></li> </ul>"},{"location":"epii-deployment-checklist/#testing-checklist","title":"Testing Checklist","text":""},{"location":"epii-deployment-checklist/#basic-functionality-tests","title":"Basic Functionality Tests","text":"<ul> <li>[ ] Ping service responds correctly</li> <li>[ ] GetCapabilities returns expected experiment list</li> <li>[ ] ListParameters returns setup parameters</li> <li>[ ] Configuration validation passes</li> <li>[ ] Service handles invalid requests gracefully</li> </ul>"},{"location":"epii-deployment-checklist/#experiment-execution-tests","title":"Experiment Execution Tests","text":""},{"location":"epii-deployment-checklist/#for-simulation-setups_1","title":"For Simulation Setups:","text":"<ul> <li>[ ] Basic Rabi experiment executes successfully</li> <li>[ ] T1 experiment executes successfully</li> <li>[ ] Ramsey experiment executes successfully</li> <li>[ ] Results returned in expected format</li> <li>[ ] No memory leaks during repeated execution</li> </ul>"},{"location":"epii-deployment-checklist/#for-hardware-setups_1","title":"For Hardware Setups:","text":"<ul> <li>[ ] Hardware connection verified</li> <li>[ ] Basic experiment execution confirmed</li> <li>[ ] Parameter setting/getting works correctly</li> <li>[ ] Hardware safety checks functioning</li> </ul>"},{"location":"epii-deployment-checklist/#load-testing","title":"Load Testing","text":"<ul> <li>[ ] Service handles concurrent requests</li> <li>[ ] Memory usage stable under load</li> <li>[ ] Response times within acceptable limits</li> <li>[ ] No resource exhaustion under sustained load</li> </ul>"},{"location":"epii-deployment-checklist/#error-handling-tests","title":"Error Handling Tests","text":"<ul> <li>[ ] Invalid experiment parameters rejected gracefully</li> <li>[ ] Service recovers from experiment failures</li> <li>[ ] Network interruptions handled correctly</li> <li>[ ] Configuration errors reported clearly</li> </ul>"},{"location":"epii-deployment-checklist/#monitoring-setup-checklist","title":"Monitoring Setup Checklist","text":""},{"location":"epii-deployment-checklist/#logging-configuration","title":"Logging Configuration","text":"<ul> <li>[ ] Log rotation configured: <code>/etc/logrotate.d/leeq-epii</code></li> <li>[ ] Log levels appropriate for environment</li> <li>[ ] Structured logging format verified</li> <li>[ ] Log aggregation configured (if applicable)</li> </ul>"},{"location":"epii-deployment-checklist/#health-monitoring","title":"Health Monitoring","text":"<ul> <li>[ ] Service health monitoring configured</li> <li>[ ] Resource usage monitoring active</li> <li>[ ] Performance metrics collection enabled</li> <li>[ ] Alert thresholds defined</li> <li>[ ] Notification mechanisms tested</li> </ul>"},{"location":"epii-deployment-checklist/#backup-configuration","title":"Backup Configuration","text":"<ul> <li>[ ] Configuration backup strategy implemented</li> <li>[ ] Backup automation configured</li> <li>[ ] Recovery procedures documented</li> <li>[ ] Backup restoration tested</li> </ul>"},{"location":"epii-deployment-checklist/#security-validation-checklist","title":"Security Validation Checklist","text":""},{"location":"epii-deployment-checklist/#access-control","title":"Access Control","text":"<ul> <li>[ ] Service runs as non-privileged user (<code>leeq</code>)</li> <li>[ ] File permissions restrict access appropriately</li> <li>[ ] Network access limited to required ports</li> <li>[ ] API authentication implemented (if required)</li> </ul>"},{"location":"epii-deployment-checklist/#communication-security","title":"Communication Security","text":"<ul> <li>[ ] TLS encryption enabled (for production)</li> <li>[ ] Certificate validity verified</li> <li>[ ] Cipher suites appropriate for security requirements</li> <li>[ ] Man-in-the-middle protections verified</li> </ul>"},{"location":"epii-deployment-checklist/#system-security","title":"System Security","text":"<ul> <li>[ ] No unnecessary privileges granted</li> <li>[ ] Security patches applied to system</li> <li>[ ] Audit logging enabled</li> <li>[ ] Security scanning completed (if required)</li> </ul>"},{"location":"epii-deployment-checklist/#performance-optimization-checklist","title":"Performance Optimization Checklist","text":""},{"location":"epii-deployment-checklist/#system-optimization","title":"System Optimization","text":"<ul> <li>[ ] CPU affinity configured (if needed)</li> <li>[ ] NUMA topology optimized (if applicable)</li> <li>[ ] Memory allocation tuned for workload</li> <li>[ ] I/O scheduling optimized</li> </ul>"},{"location":"epii-deployment-checklist/#application-optimization","title":"Application Optimization","text":"<ul> <li>[ ] gRPC message size limits configured</li> <li>[ ] Connection pooling parameters tuned</li> <li>[ ] Worker thread counts optimized</li> <li>[ ] Timeout values appropriate for experiments</li> </ul>"},{"location":"epii-deployment-checklist/#resource-management","title":"Resource Management","text":"<ul> <li>[ ] Resource limits prevent system overload</li> <li>[ ] Memory usage patterns acceptable</li> <li>[ ] CPU utilization within expected ranges</li> <li>[ ] Network bandwidth sufficient for load</li> </ul>"},{"location":"epii-deployment-checklist/#documentation-checklist","title":"Documentation Checklist","text":""},{"location":"epii-deployment-checklist/#deployment-documentation","title":"Deployment Documentation","text":"<ul> <li>[ ] Configuration parameters documented</li> <li>[ ] Service dependencies identified</li> <li>[ ] Deployment procedure recorded</li> <li>[ ] Rollback procedure defined</li> </ul>"},{"location":"epii-deployment-checklist/#operational-documentation","title":"Operational Documentation","text":"<ul> <li>[ ] Service management procedures documented</li> <li>[ ] Monitoring and alerting procedures defined</li> <li>[ ] Troubleshooting guides created</li> <li>[ ] Maintenance schedules established</li> </ul>"},{"location":"epii-deployment-checklist/#user-documentation","title":"User Documentation","text":"<ul> <li>[ ] API documentation available and current</li> <li>[ ] Client connection examples provided</li> <li>[ ] Experiment parameter documentation complete</li> <li>[ ] Error code reference available</li> </ul>"},{"location":"epii-deployment-checklist/#post-deployment-validation","title":"Post-Deployment Validation","text":""},{"location":"epii-deployment-checklist/#operational-validation","title":"Operational Validation","text":"<ul> <li>[ ] Services running continuously for 24+ hours without issues</li> <li>[ ] Log analysis shows no unexpected errors</li> <li>[ ] Performance metrics within acceptable ranges</li> <li>[ ] Client connections successful from expected sources</li> </ul>"},{"location":"epii-deployment-checklist/#integration-testing","title":"Integration Testing","text":"<ul> <li>[ ] External orchestration systems connect successfully</li> <li>[ ] End-to-end experiment workflows complete</li> <li>[ ] Data serialization/deserialization working correctly</li> <li>[ ] Error propagation functioning as expected</li> </ul>"},{"location":"epii-deployment-checklist/#user-acceptance","title":"User Acceptance","text":"<ul> <li>[ ] User training completed (if applicable)</li> <li>[ ] User feedback collected and addressed</li> <li>[ ] Known limitations documented</li> <li>[ ] Support procedures communicated</li> </ul>"},{"location":"epii-deployment-checklist/#maintenance-preparation","title":"Maintenance Preparation","text":""},{"location":"epii-deployment-checklist/#ongoing-maintenance","title":"Ongoing Maintenance","text":"<ul> <li>[ ] Maintenance schedule defined</li> <li>[ ] Update procedures documented</li> <li>[ ] Backup and recovery tested</li> <li>[ ] Contact information for support updated</li> </ul>"},{"location":"epii-deployment-checklist/#change-management","title":"Change Management","text":"<ul> <li>[ ] Change control procedures established</li> <li>[ ] Configuration management in place</li> <li>[ ] Version control for configurations implemented</li> <li>[ ] Testing procedures for changes defined</li> </ul>"},{"location":"epii-deployment-checklist/#sign-off-checklist","title":"Sign-off Checklist","text":""},{"location":"epii-deployment-checklist/#technical-sign-off","title":"Technical Sign-off","text":"<ul> <li>[ ] System administrator approves deployment</li> <li>[ ] Security team approves configuration</li> <li>[ ] Network team confirms connectivity</li> <li>[ ] Performance testing results acceptable</li> </ul>"},{"location":"epii-deployment-checklist/#business-sign-off","title":"Business Sign-off","text":"<ul> <li>[ ] Operations team trained and ready</li> <li>[ ] Documentation reviewed and approved</li> <li>[ ] Support procedures in place</li> <li>[ ] Service level agreements defined</li> </ul>"},{"location":"epii-deployment-checklist/#go-live-authorization","title":"Go-Live Authorization","text":"<ul> <li>[ ] All checklist items completed</li> <li>[ ] Risk assessment completed and accepted</li> <li>[ ] Rollback plan confirmed and tested</li> <li>[ ] Go-live authorization obtained</li> </ul>"},{"location":"epii-deployment-checklist/#emergency-procedures","title":"Emergency Procedures","text":""},{"location":"epii-deployment-checklist/#service-failure-response","title":"Service Failure Response","text":"<ol> <li>Check service status: <code>sudo systemctl status leeq-epii@&lt;setup&gt;.service</code></li> <li>Review logs: <code>sudo journalctl -u leeq-epii@&lt;setup&gt;.service -n 50</code></li> <li>Attempt restart: <code>sudo systemctl restart leeq-epii@&lt;setup&gt;.service</code></li> <li>If restart fails, check configuration validation</li> <li>Escalate to development team if configuration is valid</li> </ol>"},{"location":"epii-deployment-checklist/#performance-degradation-response","title":"Performance Degradation Response","text":"<ol> <li>Check resource usage: <code>sudo systemctl status leeq-epii@&lt;setup&gt;.service</code></li> <li>Monitor active connections: <code>sudo ss -tlnp | grep :&lt;port&gt;</code></li> <li>Review recent logs for errors or warnings</li> <li>Consider temporary worker limit reduction</li> <li>Monitor for recovery, escalate if issues persist</li> </ol>"},{"location":"epii-deployment-checklist/#security-incident-response","title":"Security Incident Response","text":"<ol> <li>Immediately stop affected services</li> <li>Preserve logs for analysis</li> <li>Check for unauthorized access attempts</li> <li>Review and update security configurations</li> <li>Coordinate with security team for incident response</li> </ol> <p>Use this checklist to ensure comprehensive deployment validation and preparation for production operation of LeeQ EPII services.</p>"},{"location":"epii-operations-guide/","title":"LeeQ EPII Operations Guide","text":""},{"location":"epii-operations-guide/#overview","title":"Overview","text":"<p>This guide provides comprehensive instructions for deploying, managing, and monitoring the LeeQ EPII (Experiment Platform Intelligence Interface) service in production environments. The EPII service exposes LeeQ's quantum experiments through a standardized gRPC interface for integration with external orchestration systems.</p>"},{"location":"epii-operations-guide/#table-of-contents","title":"Table of Contents","text":"<ol> <li>System Requirements</li> <li>Installation</li> <li>Configuration</li> <li>Service Management</li> <li>Monitoring and Logging</li> <li>Security</li> <li>Performance Tuning</li> <li>Troubleshooting</li> <li>Backup and Recovery</li> <li>Maintenance</li> </ol>"},{"location":"epii-operations-guide/#system-requirements","title":"System Requirements","text":""},{"location":"epii-operations-guide/#hardware-requirements","title":"Hardware Requirements","text":"<p>Minimum Requirements: - CPU: 2 cores - RAM: 4 GB - Storage: 20 GB free space - Network: 100 Mbps</p> <p>Recommended for Production: - CPU: 4+ cores - RAM: 8+ GB - Storage: 100+ GB SSD - Network: 1 Gbps</p>"},{"location":"epii-operations-guide/#software-requirements","title":"Software Requirements","text":"<p>Operating System: - Ubuntu 20.04 LTS or later - RHEL/CentOS 8 or later - SUSE Linux Enterprise 15 or later</p> <p>Dependencies: - Python 3.8 or later - systemd (for service management) - gRPC runtime libraries</p> <p>Network Requirements: - Port 50051-50099 (configurable) - Firewall configured for gRPC traffic - DNS resolution for external dependencies</p>"},{"location":"epii-operations-guide/#installation","title":"Installation","text":""},{"location":"epii-operations-guide/#1-automated-installation","title":"1. Automated Installation","text":"<p>The recommended way to install LeeQ EPII in production is using the automated installer:</p> <pre><code># Clone the LeeQ repository\ngit clone https://github.com/ShuxiangCao/LeeQ.git /opt/leeq-source\ncd /opt/leeq-source\n\n# Run the installation script as root\nsudo ./scripts/install-systemd-service.sh\n</code></pre> <p>This script will: - Create system user and group (<code>leeq</code>) - Install LeeQ to <code>/opt/leeq</code> - Create configuration directories - Install systemd service templates - Set up logging directories</p>"},{"location":"epii-operations-guide/#2-manual-installation","title":"2. Manual Installation","text":"<p>For custom installations, follow these steps:</p> <pre><code># Create system user\nsudo groupadd --system leeq\nsudo useradd --system --gid leeq --shell /bin/false \\\n    --home-dir /opt/leeq --no-create-home \\\n    --comment \"LeeQ EPII daemon user\" leeq\n\n# Create directories\nsudo mkdir -p /opt/leeq /etc/leeq-epii /var/log/leeq-epii /var/run/leeq-epii\nsudo chown -R leeq:leeq /opt/leeq /etc/leeq-epii /var/log/leeq-epii /var/run/leeq-epii\nsudo chmod 755 /etc/leeq-epii\nsudo chmod 750 /var/log/leeq-epii /var/run/leeq-epii\n\n# Install LeeQ\nsudo cp -r leeq /opt/leeq/\nsudo cp -r venv /opt/leeq/  # If using virtual environment\nsudo chown -R leeq:leeq /opt/leeq\n\n# Install systemd service\nsudo cp scripts/systemd/leeq-epii@.service /etc/systemd/system/\nsudo systemctl daemon-reload\n</code></pre>"},{"location":"epii-operations-guide/#3-verification","title":"3. Verification","text":"<p>Verify the installation:</p> <pre><code># Check service template\nsudo systemctl list-unit-files \"leeq-epii@*.service\"\n\n# Validate sample configuration\nsudo -u leeq /opt/leeq/venv/bin/python -m leeq.epii.daemon \\\n    --config /etc/leeq-epii/simulation_2q.json --validate\n</code></pre>"},{"location":"epii-operations-guide/#configuration","title":"Configuration","text":""},{"location":"epii-operations-guide/#1-configuration-file-structure","title":"1. Configuration File Structure","text":"<p>Configuration files are stored in <code>/etc/leeq-epii/</code> and use JSON format:</p> <pre><code>{\n    \"setup_type\": \"simulation|hardware\",\n    \"setup_name\": \"unique_setup_identifier\",\n    \"description\": \"Human-readable description\",\n    \"port\": 50051,\n    \"max_workers\": 10,\n    \"timeout\": 300,\n    \"logging\": {\n        \"level\": \"INFO\",\n        \"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n    },\n    \"simulation\": {\n        \"backend\": \"numpy|qutip\",\n        \"qubits\": 2\n    },\n    \"hardware\": {\n        \"type\": \"qubic_lbnl\",\n        \"config_file\": \"/etc/leeq-epii/hardware/setup_config.json\"\n    }\n}\n</code></pre>"},{"location":"epii-operations-guide/#2-configuration-examples","title":"2. Configuration Examples","text":""},{"location":"epii-operations-guide/#simulation-setup","title":"Simulation Setup","text":"<pre><code>{\n    \"setup_type\": \"simulation\",\n    \"setup_name\": \"sim_2q_development\",\n    \"description\": \"2-qubit simulation for development and testing\",\n    \"port\": 50051,\n    \"max_workers\": 5,\n    \"timeout\": 300,\n    \"logging\": {\n        \"level\": \"INFO\"\n    },\n    \"simulation\": {\n        \"backend\": \"numpy\",\n        \"qubits\": 2\n    }\n}\n</code></pre>"},{"location":"epii-operations-guide/#hardware-setup","title":"Hardware Setup","text":"<pre><code>{\n    \"setup_type\": \"hardware\",\n    \"setup_name\": \"lab1_quantum_device\",\n    \"description\": \"Lab 1 quantum device with 4 qubits\",\n    \"port\": 50052,\n    \"max_workers\": 3,\n    \"timeout\": 600,\n    \"logging\": {\n        \"level\": \"WARNING\"\n    },\n    \"hardware\": {\n        \"type\": \"qubic_lbnl\",\n        \"config_file\": \"/etc/leeq-epii/hardware/lab1_config.json\"\n    }\n}\n</code></pre>"},{"location":"epii-operations-guide/#3-environment-variables","title":"3. Environment Variables","text":"<p>Configure system-wide settings using environment variables:</p> <pre><code># /etc/environment or /etc/systemd/system/leeq-epii@.service\nLEEQ_EPII_CONFIG_DIR=/etc/leeq-epii\nLEEQ_EPII_LOG_LEVEL=INFO\nLEEQ_EPII_MAX_MESSAGE_SIZE=104857600  # 100MB\nPYTHONPATH=/opt/leeq\n</code></pre>"},{"location":"epii-operations-guide/#4-port-management","title":"4. Port Management","text":"<p>Configure ports to avoid conflicts:</p> <ul> <li>50051: Default simulation setup</li> <li>50052-50059: Additional simulation instances</li> <li>50060-50069: Hardware setups</li> <li>50070-50099: Development/testing</li> </ul>"},{"location":"epii-operations-guide/#5-configuration-validation","title":"5. Configuration Validation","text":"<p>Always validate configurations before deployment:</p> <pre><code># Validate specific configuration\nsudo -u leeq /opt/leeq/venv/bin/python -m leeq.epii.daemon \\\n    --config /etc/leeq-epii/your_setup.json --validate\n\n# Validate all configurations\nfor config in /etc/leeq-epii/*.json; do\n    echo \"Validating $config...\"\n    sudo -u leeq /opt/leeq/venv/bin/python -m leeq.epii.daemon \\\n        --config \"$config\" --validate\ndone\n</code></pre>"},{"location":"epii-operations-guide/#service-management","title":"Service Management","text":""},{"location":"epii-operations-guide/#1-service-instances","title":"1. Service Instances","text":"<p>Each configuration file creates a service instance:</p> <pre><code># Enable and start simulation setup\nsudo systemctl enable leeq-epii@simulation_2q.service\nsudo systemctl start leeq-epii@simulation_2q.service\n\n# Enable and start hardware setup\nsudo systemctl enable leeq-epii@hardware_lab1.service\nsudo systemctl start leeq-epii@hardware_lab1.service\n</code></pre>"},{"location":"epii-operations-guide/#2-service-management-commands","title":"2. Service Management Commands","text":"<pre><code># Start service\nsudo systemctl start leeq-epii@&lt;setup_name&gt;.service\n\n# Stop service\nsudo systemctl stop leeq-epii@&lt;setup_name&gt;.service\n\n# Restart service\nsudo systemctl restart leeq-epii@&lt;setup_name&gt;.service\n\n# Check status\nsudo systemctl status leeq-epii@&lt;setup_name&gt;.service\n\n# Enable auto-start on boot\nsudo systemctl enable leeq-epii@&lt;setup_name&gt;.service\n\n# Disable auto-start\nsudo systemctl disable leeq-epii@&lt;setup_name&gt;.service\n\n# Reload configuration (after config changes)\nsudo systemctl reload-or-restart leeq-epii@&lt;setup_name&gt;.service\n</code></pre>"},{"location":"epii-operations-guide/#3-service-management-script","title":"3. Service Management Script","text":"<p>Use the included management script for easier operations:</p> <pre><code># List all configured services\nsudo /opt/leeq-source/scripts/leeq-epii-service.sh list\n\n# Start a service\nsudo /opt/leeq-source/scripts/leeq-epii-service.sh start simulation_2q\n\n# Check status\nsudo /opt/leeq-source/scripts/leeq-epii-service.sh status simulation_2q\n\n# View logs\nsudo /opt/leeq-source/scripts/leeq-epii-service.sh logs simulation_2q\n\n# Validate configuration\nsudo /opt/leeq-source/scripts/leeq-epii-service.sh validate simulation_2q\n</code></pre>"},{"location":"epii-operations-guide/#4-health-checks","title":"4. Health Checks","text":"<p>Monitor service health:</p> <pre><code># Built-in health check\nsudo -u leeq /opt/leeq/venv/bin/python -m leeq.epii.daemon \\\n    --config /etc/leeq-epii/simulation_2q.json --health-check\n\n# Check if service is listening\nsudo ss -tlnp | grep :50051\n\n# Test gRPC connectivity\ngrpcurl -plaintext localhost:50051 epii.v1.ExperimentPlatformService/Ping\n</code></pre>"},{"location":"epii-operations-guide/#monitoring-and-logging","title":"Monitoring and Logging","text":""},{"location":"epii-operations-guide/#1-systemd-logs","title":"1. Systemd Logs","text":"<p>View service logs using journalctl:</p> <pre><code># View recent logs\nsudo journalctl -u leeq-epii@simulation_2q.service\n\n# Follow logs in real-time\nsudo journalctl -u leeq-epii@simulation_2q.service -f\n\n# View logs since last boot\nsudo journalctl -u leeq-epii@simulation_2q.service -b\n\n# View logs for specific time range\nsudo journalctl -u leeq-epii@simulation_2q.service \\\n    --since \"2024-01-01 00:00:00\" --until \"2024-01-02 00:00:00\"\n\n# Export logs to file\nsudo journalctl -u leeq-epii@simulation_2q.service &gt; epii_logs.txt\n</code></pre>"},{"location":"epii-operations-guide/#2-log-file-management","title":"2. Log File Management","text":"<p>Configure log rotation to prevent disk space issues:</p> <pre><code># Create logrotate configuration\nsudo tee /etc/logrotate.d/leeq-epii &lt;&lt; EOF\n/var/log/leeq-epii/*.log {\n    daily\n    rotate 30\n    compress\n    delaycompress\n    missingok\n    notifempty\n    create 640 leeq leeq\n    postrotate\n        systemctl reload leeq-epii@*.service\n    endscript\n}\nEOF\n</code></pre>"},{"location":"epii-operations-guide/#3-monitoring-metrics","title":"3. Monitoring Metrics","text":"<p>Key metrics to monitor:</p> <p>Service Health: - Service uptime - Restart frequency - Memory usage - CPU usage</p> <p>gRPC Metrics: - Request rate - Response time - Error rate - Active connections</p> <p>Experiment Metrics: - Experiment success rate - Average execution time - Queue depth - Resource utilization</p>"},{"location":"epii-operations-guide/#4-monitoring-integration","title":"4. Monitoring Integration","text":""},{"location":"epii-operations-guide/#prometheus-integration","title":"Prometheus Integration","text":"<p>Create a monitoring endpoint:</p> <pre><code># Add to service configuration for metrics export\nfrom prometheus_client import start_http_server, Counter, Histogram\n\n# Metrics\nREQUEST_COUNT = Counter('epii_requests_total', 'Total requests', ['method', 'status'])\nREQUEST_DURATION = Histogram('epii_request_duration_seconds', 'Request duration')\n\n# Start metrics server on different port\nstart_http_server(8000)\n</code></pre>"},{"location":"epii-operations-guide/#grafana-dashboard","title":"Grafana Dashboard","text":"<p>Monitor key metrics with these queries:</p> <pre><code># Request rate\nrate(epii_requests_total[5m])\n\n# Error rate\nrate(epii_requests_total{status=\"error\"}[5m]) / rate(epii_requests_total[5m])\n\n# Average response time\nrate(epii_request_duration_seconds_sum[5m]) / rate(epii_request_duration_seconds_count[5m])\n</code></pre>"},{"location":"epii-operations-guide/#security","title":"Security","text":""},{"location":"epii-operations-guide/#1-network-security","title":"1. Network Security","text":"<p>Firewall Configuration:</p> <pre><code># Allow EPII ports\nsudo ufw allow 50051:50099/tcp comment \"LeeQ EPII services\"\n\n# Restrict to specific networks\nsudo ufw allow from 192.168.1.0/24 to any port 50051:50099 proto tcp\n</code></pre> <p>TLS/SSL Setup:</p> <p>For production, enable TLS encryption:</p> <pre><code># Generate certificates\nopenssl req -x509 -newkey rsa:4096 -keyout server.key -out server.crt \\\n    -days 365 -nodes -subj \"/C=US/ST=CA/L=Berkeley/O=LeeQ/CN=epii-server\"\n\n# Update service configuration\n{\n    \"tls\": {\n        \"enabled\": true,\n        \"cert_file\": \"/etc/leeq-epii/certs/server.crt\",\n        \"key_file\": \"/etc/leeq-epii/certs/server.key\"\n    }\n}\n</code></pre>"},{"location":"epii-operations-guide/#2-access-control","title":"2. Access Control","text":"<p>File Permissions:</p> <pre><code># Configuration files\nsudo chmod 640 /etc/leeq-epii/*.json\nsudo chown root:leeq /etc/leeq-epii/*.json\n\n# Log files\nsudo chmod 640 /var/log/leeq-epii/*.log\nsudo chown leeq:leeq /var/log/leeq-epii/*.log\n\n# Service files\nsudo chmod 644 /etc/systemd/system/leeq-epii@.service\nsudo chown root:root /etc/systemd/system/leeq-epii@.service\n</code></pre> <p>User Isolation:</p> <p>The service runs as the <code>leeq</code> user with minimal privileges:</p> <pre><code># Verify user configuration\nid leeq\n# Should show: uid=999(leeq) gid=999(leeq) groups=999(leeq)\n\n# Check service security\nsudo systemctl show leeq-epii@simulation_2q.service | grep -E \"User|Group|NoNewPrivileges|PrivateTmp\"\n</code></pre>"},{"location":"epii-operations-guide/#3-authentication","title":"3. Authentication","text":"<p>For production deployments, implement authentication:</p> <pre><code># Example gRPC interceptor for API key authentication\nclass AuthInterceptor(grpc.ServerInterceptor):\n    def intercept_service(self, continuation, handler_call_details):\n        metadata = dict(handler_call_details.invocation_metadata)\n        api_key = metadata.get('x-api-key')\n\n        if not self.validate_api_key(api_key):\n            context = grpc.ServicerContext()\n            context.abort(grpc.StatusCode.UNAUTHENTICATED, \"Invalid API key\")\n\n        return continuation(handler_call_details)\n</code></pre>"},{"location":"epii-operations-guide/#performance-tuning","title":"Performance Tuning","text":""},{"location":"epii-operations-guide/#1-system-optimization","title":"1. System Optimization","text":"<p>Memory Settings:</p> <pre><code># Increase shared memory for large experiments\necho \"kernel.shmmax = 134217728\" | sudo tee -a /etc/sysctl.conf\necho \"kernel.shmall = 32768\" | sudo tee -a /etc/sysctl.conf\nsudo sysctl -p\n</code></pre> <p>File Descriptor Limits:</p> <pre><code># Increase file descriptor limits\necho \"leeq soft nofile 65536\" | sudo tee -a /etc/security/limits.conf\necho \"leeq hard nofile 65536\" | sudo tee -a /etc/security/limits.conf\n</code></pre>"},{"location":"epii-operations-guide/#2-grpc-optimization","title":"2. gRPC Optimization","text":"<p>Configuration Tuning:</p> <pre><code>{\n    \"grpc\": {\n        \"max_workers\": 10,\n        \"max_message_size\": 104857600,\n        \"keepalive_time_ms\": 30000,\n        \"keepalive_timeout_ms\": 5000,\n        \"keepalive_permit_without_calls\": true\n    }\n}\n</code></pre> <p>Connection Pooling:</p> <p>For clients connecting to EPII:</p> <pre><code># Optimize client connections\nchannel = grpc.insecure_channel(\n    'localhost:50051',\n    options=[\n        ('grpc.keepalive_time_ms', 30000),\n        ('grpc.keepalive_timeout_ms', 5000),\n        ('grpc.keepalive_permit_without_calls', True),\n        ('grpc.http2.max_pings_without_data', 0),\n        ('grpc.http2.min_time_between_pings_ms', 10000),\n        ('grpc.http2.min_ping_interval_without_data_ms', 300000)\n    ]\n)\n</code></pre>"},{"location":"epii-operations-guide/#3-hardware-optimization","title":"3. Hardware Optimization","text":"<p>CPU Affinity:</p> <pre><code># Pin service to specific CPUs\nsudo systemctl edit leeq-epii@simulation_2q.service\n\n# Add in override file:\n[Service]\nExecStart=\nExecStart=/usr/bin/taskset -c 0,1 /opt/leeq/venv/bin/python -m leeq.epii.daemon --config /etc/leeq-epii/simulation_2q.json\n</code></pre> <p>NUMA Optimization:</p> <pre><code># Check NUMA topology\nnumactl --hardware\n\n# Run on specific NUMA node\nsudo systemctl edit leeq-epii@hardware_lab1.service\n\n# Add in override file:\n[Service]\nExecStart=\nExecStart=/usr/bin/numactl --cpunodebind=0 --membind=0 /opt/leeq/venv/bin/python -m leeq.epii.daemon --config /etc/leeq-epii/hardware_lab1.json\n</code></pre>"},{"location":"epii-operations-guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"epii-operations-guide/#1-common-issues","title":"1. Common Issues","text":"<p>Service Won't Start:</p> <pre><code># Check service status\nsudo systemctl status leeq-epii@simulation_2q.service\n\n# Check detailed logs\nsudo journalctl -u leeq-epii@simulation_2q.service -n 50\n\n# Validate configuration\nsudo -u leeq /opt/leeq/venv/bin/python -m leeq.epii.daemon \\\n    --config /etc/leeq-epii/simulation_2q.json --validate\n\n# Check port availability\nsudo ss -tlnp | grep :50051\n</code></pre> <p>Connection Refused:</p> <pre><code># Check if service is listening\nsudo netstat -tlnp | grep :50051\n\n# Test local connectivity\ntelnet localhost 50051\n\n# Check firewall\nsudo ufw status\n</code></pre> <p>High Memory Usage:</p> <pre><code># Monitor memory usage\nsudo systemctl status leeq-epii@simulation_2q.service | grep Memory\n\n# Check process details\nsudo ps aux | grep leeq\n\n# Monitor in real-time\nsudo htop -u leeq\n</code></pre>"},{"location":"epii-operations-guide/#2-debug-mode","title":"2. Debug Mode","text":"<p>Enable debug logging for troubleshooting:</p> <pre><code># Temporary debug mode\nsudo systemctl edit leeq-epii@simulation_2q.service\n\n# Add in override file:\n[Service]\nEnvironment=LEEQ_EPII_LOG_LEVEL=DEBUG\n</code></pre>"},{"location":"epii-operations-guide/#3-diagnostic-tools","title":"3. Diagnostic Tools","text":"<p>Generate diagnostic report:</p> <pre><code>sudo -u leeq /opt/leeq/venv/bin/python -m leeq.epii.daemon \\\n    --config /etc/leeq-epii/simulation_2q.json --diagnostic-report\n</code></pre> <p>Performance profiling:</p> <pre><code># Profile service startup\nsudo -u leeq python -m cProfile -o epii_profile.prof \\\n    -m leeq.epii.daemon --config /etc/leeq-epii/simulation_2q.json\n\n# Analyze profile\npython -c \"\nimport pstats\np = pstats.Stats('epii_profile.prof')\np.sort_stats('cumulative').print_stats(20)\n\"\n</code></pre>"},{"location":"epii-operations-guide/#4-recovery-procedures","title":"4. Recovery Procedures","text":"<p>Service Recovery:</p> <pre><code># Stop all EPII services\nsudo systemctl stop leeq-epii@*.service\n\n# Clear any stuck processes\nsudo pkill -f \"leeq.epii.daemon\"\n\n# Remove stale PID files\nsudo rm -f /var/run/leeq-epii/*.pid\n\n# Restart services\nsudo systemctl start leeq-epii@simulation_2q.service\n</code></pre> <p>Configuration Recovery:</p> <pre><code># Backup current config\nsudo cp /etc/leeq-epii/simulation_2q.json /etc/leeq-epii/simulation_2q.json.backup\n\n# Restore from backup\nsudo cp /etc/leeq-epii/simulation_2q.json.backup /etc/leeq-epii/simulation_2q.json\n\n# Regenerate default config\nsudo /opt/leeq-source/scripts/install-systemd-service.sh\n</code></pre>"},{"location":"epii-operations-guide/#backup-and-recovery","title":"Backup and Recovery","text":""},{"location":"epii-operations-guide/#1-backup-strategy","title":"1. Backup Strategy","text":"<p>Configuration Backup:</p> <pre><code>#!/bin/bash\n# /opt/leeq/scripts/backup-config.sh\n\nBACKUP_DIR=\"/backup/leeq-epii/$(date +%Y%m%d)\"\nmkdir -p \"$BACKUP_DIR\"\n\n# Backup configurations\ncp -r /etc/leeq-epii \"$BACKUP_DIR/\"\n\n# Backup service files\ncp /etc/systemd/system/leeq-epii@.service \"$BACKUP_DIR/\"\n\n# Backup logs (last 7 days)\njournalctl -u 'leeq-epii@*.service' --since \"7 days ago\" &gt; \"$BACKUP_DIR/logs.txt\"\n\n# Create archive\ntar -czf \"$BACKUP_DIR.tar.gz\" -C \"$BACKUP_DIR\" .\nrm -rf \"$BACKUP_DIR\"\n</code></pre> <p>Automated Backup:</p> <pre><code># Add to crontab\nsudo crontab -e\n\n# Daily backup at 2 AM\n0 2 * * * /opt/leeq/scripts/backup-config.sh\n</code></pre>"},{"location":"epii-operations-guide/#2-recovery-procedures","title":"2. Recovery Procedures","text":"<p>Configuration Recovery:</p> <pre><code># Extract backup\ntar -xzf /backup/leeq-epii/20240101.tar.gz -C /tmp/restore\n\n# Stop services\nsudo systemctl stop leeq-epii@*.service\n\n# Restore configuration\nsudo cp -r /tmp/restore/leeq-epii/* /etc/leeq-epii/\nsudo chown -R root:leeq /etc/leeq-epii\nsudo chmod 640 /etc/leeq-epii/*.json\n\n# Restore service file\nsudo cp /tmp/restore/leeq-epii@.service /etc/systemd/system/\nsudo systemctl daemon-reload\n\n# Restart services\nsudo systemctl start leeq-epii@*.service\n</code></pre> <p>Disaster Recovery:</p> <pre><code>#!/bin/bash\n# Complete system recovery script\n\n# 1. Reinstall LeeQ EPII\nsudo /opt/leeq-source/scripts/install-systemd-service.sh\n\n# 2. Restore configurations\nsudo tar -xzf /backup/leeq-epii/latest.tar.gz -C /\nsudo chown -R root:leeq /etc/leeq-epii\nsudo chmod 640 /etc/leeq-epii/*.json\n\n# 3. Restart services\nsudo systemctl daemon-reload\nsudo systemctl start leeq-epii@*.service\n\n# 4. Verify operation\nfor service in /etc/leeq-epii/*.json; do\n    setup_name=$(basename \"$service\" .json)\n    echo \"Testing $setup_name...\"\n    sudo systemctl status leeq-epii@$setup_name.service\ndone\n</code></pre>"},{"location":"epii-operations-guide/#maintenance","title":"Maintenance","text":""},{"location":"epii-operations-guide/#1-regular-maintenance-tasks","title":"1. Regular Maintenance Tasks","text":"<p>Weekly Tasks:</p> <pre><code>#!/bin/bash\n# Weekly maintenance script\n\n# Check service health\nsystemctl status leeq-epii@*.service\n\n# Check disk space\ndf -h /var/log/leeq-epii\n\n# Rotate logs if needed\nsudo logrotate -f /etc/logrotate.d/leeq-epii\n\n# Check for configuration changes\nsudo find /etc/leeq-epii -name \"*.json\" -mtime -7 -ls\n</code></pre> <p>Monthly Tasks:</p> <pre><code>#!/bin/bash\n# Monthly maintenance script\n\n# Update LeeQ\ncd /opt/leeq-source\nsudo git pull origin main\nsudo /opt/leeq/venv/bin/pip install -e .\n\n# Restart services to pick up updates\nsudo systemctl restart leeq-epii@*.service\n\n# Cleanup old logs\nsudo find /var/log/leeq-epii -name \"*.gz\" -mtime +30 -delete\n\n# Performance review\nsudo journalctl -u 'leeq-epii@*.service' --since \"1 month ago\" | grep -E \"ERROR|WARNING\" | wc -l\n</code></pre>"},{"location":"epii-operations-guide/#2-updates-and-upgrades","title":"2. Updates and Upgrades","text":"<p>LeeQ Updates:</p> <pre><code># Stop all services\nsudo systemctl stop leeq-epii@*.service\n\n# Backup current installation\nsudo tar -czf /backup/leeq-$(date +%Y%m%d).tar.gz -C /opt leeq\n\n# Update LeeQ\ncd /opt/leeq-source\nsudo git pull origin main\nsudo cp -r leeq /opt/leeq/\nsudo chown -R leeq:leeq /opt/leeq\n\n# Update Python dependencies\nsudo -u leeq /opt/leeq/venv/bin/pip install -r requirements.txt\n\n# Test configuration\nsudo -u leeq /opt/leeq/venv/bin/python -m leeq.epii.daemon \\\n    --config /etc/leeq-epii/simulation_2q.json --validate\n\n# Restart services\nsudo systemctl start leeq-epii@*.service\n</code></pre> <p>System Updates:</p> <pre><code># Update system packages\nsudo apt update &amp;&amp; sudo apt upgrade -y\n\n# Restart services if kernel was updated\nif [ -f /var/run/reboot-required ]; then\n    echo \"System restart required after kernel update\"\n    # Schedule restart during maintenance window\nfi\n</code></pre>"},{"location":"epii-operations-guide/#3-performance-monitoring","title":"3. Performance Monitoring","text":"<p>Resource Usage:</p> <pre><code>#!/bin/bash\n# Monitor resource usage\n\necho \"=== LeeQ EPII Resource Usage ===\"\necho \"Memory Usage:\"\nsudo systemctl status leeq-epii@*.service | grep Memory\n\necho \"CPU Usage:\"\nsudo ps -u leeq -o pid,pcpu,pmem,command\n\necho \"Network Connections:\"\nsudo ss -tlnp | grep -E \":5005[0-9]\"\n\necho \"Disk Usage:\"\ndf -h /var/log/leeq-epii /etc/leeq-epii /opt/leeq\n</code></pre> <p>Performance Baseline:</p> <pre><code># Establish performance baseline\nfor i in {1..10}; do\n    grpcurl -plaintext localhost:50051 epii.v1.ExperimentPlatformService/Ping | \\\n    jq '.timestamp' | xargs -I {} date -d @{}\n    sleep 1\ndone\n</code></pre>"},{"location":"epii-operations-guide/#4-capacity-planning","title":"4. Capacity Planning","text":"<p>Monitor these metrics for capacity planning:</p> <ul> <li>Concurrent experiments: Track number of simultaneous experiment executions</li> <li>Memory per experiment: Monitor memory usage patterns</li> <li>Experiment duration: Track typical execution times</li> <li>Queue depth: Monitor experiment request queuing</li> <li>Error rates: Track failure patterns and recovery times</li> </ul> <p>Capacity Monitoring Script:</p> <pre><code>#!/bin/bash\n# Capacity monitoring\n\necho \"=== Capacity Metrics $(date) ===\"\n\n# Active connections\necho \"Active gRPC connections:\"\nsudo ss -tn state established '( dport = :50051 or sport = :50051 )' | wc -l\n\n# Memory usage trend\necho \"Memory usage (MB):\"\nsudo ps -u leeq -o rss= | awk '{sum+=$1} END {print sum/1024}'\n\n# Service uptime\necho \"Service uptime:\"\nsudo systemctl show leeq-epii@simulation_2q.service --property=ActiveEnterTimestamp\n\n# Request rate (if metrics are available)\necho \"Request rate (last hour):\"\nsudo journalctl -u leeq-epii@simulation_2q.service --since \"1 hour ago\" | \\\ngrep \"Experiment request\" | wc -l\n</code></pre>"},{"location":"epii-operations-guide/#quick-reference","title":"Quick Reference","text":""},{"location":"epii-operations-guide/#essential-commands","title":"Essential Commands","text":"<pre><code># Service Management\nsudo systemctl {start|stop|restart|status} leeq-epii@&lt;setup&gt;.service\n\n# Configuration Validation\nsudo -u leeq /opt/leeq/venv/bin/python -m leeq.epii.daemon --config /etc/leeq-epii/&lt;setup&gt;.json --validate\n\n# Health Check\nsudo -u leeq /opt/leeq/venv/bin/python -m leeq.epii.daemon --config /etc/leeq-epii/&lt;setup&gt;.json --health-check\n\n# View Logs\nsudo journalctl -u leeq-epii@&lt;setup&gt;.service -f\n\n# Test Connectivity\ngrpcurl -plaintext localhost:&lt;port&gt; epii.v1.ExperimentPlatformService/Ping\n</code></pre>"},{"location":"epii-operations-guide/#important-paths","title":"Important Paths","text":"<ul> <li>Configuration: <code>/etc/leeq-epii/</code></li> <li>Installation: <code>/opt/leeq/</code></li> <li>Logs: <code>/var/log/leeq-epii/</code> (systemd logs via journalctl)</li> <li>Service Files: <code>/etc/systemd/system/leeq-epii@.service</code></li> <li>Runtime: <code>/var/run/leeq-epii/</code></li> </ul>"},{"location":"epii-operations-guide/#support-and-resources","title":"Support and Resources","text":"<ul> <li>Documentation: <code>/opt/leeq-source/docs/</code></li> <li>Issue Tracking: GitHub Issues</li> <li>Configuration Examples: <code>/opt/leeq-source/configs/epii/</code></li> <li>Test Scripts: <code>/opt/leeq-source/scripts/</code></li> </ul> <p>This operations guide provides comprehensive coverage of LeeQ EPII deployment and management. For additional support, consult the development team or submit issues through the project's GitHub repository.</p>"},{"location":"quick_start/","title":"Quick Start Guide: Your First Quantum Experiment in 10 Minutes","text":"<p>Get LeeQ running and execute your first quantum experiment using simulation - no hardware required! This guide will have you running a Rabi oscillation experiment in under 10 minutes.</p>"},{"location":"quick_start/#step-1-installation-2-minutes","title":"Step 1: Installation (2 minutes)","text":""},{"location":"quick_start/#install-leeq","title":"Install LeeQ","text":"<pre><code>pip install git+https://github.com/ShuxiangCao/LeeQ\n</code></pre>"},{"location":"quick_start/#verify-installation","title":"Verify Installation","text":"<pre><code>python -c \"import leeq; print('LeeQ installed successfully!')\"\n</code></pre> <p>If this command runs without errors, you're ready to proceed!</p>"},{"location":"quick_start/#step-2-set-up-simulation-environment-3-minutes","title":"Step 2: Set Up Simulation Environment (3 minutes)","text":"<p>Create a new Python file called <code>quick_start_experiment.py</code> and add this simulation setup:</p> <pre><code># quick_start_experiment.py - Your first LeeQ experiment\nimport numpy as np\nfrom leeq.core.elements.built_in.qudit_transmon import TransmonElement\nfrom leeq.setups.built_in.setup_simulation_high_level import HighLevelSimulationSetup\nfrom leeq.experiments.experiments import ExperimentManager\nfrom leeq.theory.simulation.numpy.rotated_frame_simulator import VirtualTransmon\nfrom leeq.experiments.builtin.basic.calibrations.rabi import NormalisedRabi\nfrom leeq.chronicle import Chronicle\n\ndef setup_simulation():\n    \"\"\"Set up a simulated quantum system with one qubit.\"\"\"\n\n    # Start experiment logging\n    Chronicle().start_log()\n\n    # Create experiment manager and clear any existing setups\n    manager = ExperimentManager()\n    manager.clear_setups()\n\n    # Create a virtual qubit with realistic parameters\n    virtual_qubit = VirtualTransmon(\n        name=\"QuickStartQubit\",\n        qubit_frequency=5040.4,  # MHz\n        anharmonicity=-198,      # MHz\n        t1=70,                   # microseconds\n        t2=35,                   # microseconds\n        readout_frequency=9645.4, # MHz\n        quiescent_state_distribution=np.array([0.8, 0.15, 0.04, 0.01])\n    )\n\n    # Create simulation setup\n    setup = HighLevelSimulationSetup(\n        name='QuickStartSimulation',\n        virtual_qubits={0: virtual_qubit}  # Channel 0\n    )\n\n    # Register the setup\n    manager.register_setup(setup)\n    return manager\n\n# Qubit configuration for our simulated system\nqubit_config = {\n    'hrid': 'Q0',\n    'lpb_collections': {\n        'f01': {  # 0-&gt;1 transition\n            'type': 'SimpleDriveCollection',\n            'freq': 5040.4,      # Match qubit frequency\n            'channel': 0,\n            'shape': 'blackman_drag',\n            'amp': 0.1,          # Start with small amplitude\n            'phase': 0.0,\n            'width': 0.05,       # 50 ns pulse\n            'alpha': 500,\n            'trunc': 1.2\n        }\n    },\n    'measurement_primitives': {\n        '0': {\n            'type': 'SimpleDispersiveMeasurement',\n            'freq': 9645.4,     # Match readout frequency\n            'channel': 1,\n            'shape': 'square',\n            'amp': 0.15,\n            'phase': 0.0,\n            'width': 1.0,       # 1 us readout\n            'trunc': 1.2,\n            'distinguishable_states': [0, 1]\n        }\n    }\n}\n\nif __name__ == \"__main__\":\n    # Initialize the simulation\n    manager = setup_simulation()\n    print(\"Simulation environment ready!\")\n</code></pre>"},{"location":"quick_start/#step-3-run-your-first-quantum-experiment-3-minutes","title":"Step 3: Run Your First Quantum Experiment (3 minutes)","text":"<p>Now add the experiment code to your <code>quick_start_experiment.py</code> file:</p> <pre><code># Add this to the end of quick_start_experiment.py\n\ndef run_rabi_experiment():\n    \"\"\"Run a Rabi oscillation experiment to calibrate qubit drive amplitude.\"\"\"\n\n    # Initialize simulation\n    manager = setup_simulation()\n\n    # Create the qubit element\n    qubit = TransmonElement(name=qubit_config['hrid'], parameters=qubit_config)\n\n    # Configure experiment parameters\n    from leeq.experiments import setup\n    setup().status().set_param(\"Shot_Number\", 1000)\n    setup().status().set_param(\"Sampling_Noise\", True)  # Add realistic noise\n\n    print(\"Running Rabi oscillation experiment...\")\n    print(\"This will sweep pulse duration to find optimal drive parameters.\\n\")\n\n    # Create and run the Rabi experiment (experiment runs automatically)\n    rabi_exp = NormalisedRabi(\n        dut_qubit=qubit,\n        amp=0.05,          # Drive amplitude\n        start=0.01,        # Start time (\u00b5s)\n        stop=0.3,          # Stop time (\u00b5s) \n        step=0.005,        # Time step (\u00b5s)\n        fit=True,          # Fit oscillations\n        update=True        # Update qubit parameters\n    )\n\n    # Show results\n    print(\"Experiment completed!\")\n    print(f\"Fitted frequency: {rabi_exp.fit_params['Frequency']:.3f} MHz\")\n    print(f\"Oscillation amplitude: {rabi_exp.fit_params['Amplitude']:.3f}\")\n    print(f\"Suggested drive amplitude: {rabi_exp.guess_amp:.3f}\")\n\n    # Plot the results\n    try:\n        fig = rabi_exp.plot()\n        fig.show()\n        print(\"\\nPlot displayed! You should see Rabi oscillations.\")\n    except Exception as e:\n        print(f\"Plotting requires a display. Results saved to data.\")\n\n    return rabi_exp\n\nif __name__ == \"__main__\":\n    # Run the complete experiment\n    experiment_result = run_rabi_experiment()\n</code></pre>"},{"location":"quick_start/#step-4-execute-your-experiment-2-minutes","title":"Step 4: Execute Your Experiment (2 minutes)","text":"<p>Run your first quantum experiment:</p> <pre><code>python quick_start_experiment.py\n</code></pre> <p>Expected Output: <pre><code>Simulation environment ready!\nRunning Rabi oscillation experiment...\nThis will sweep pulse duration to find optimal drive parameters.\n\nExperiment completed!\nFitted frequency: 3.125 MHz\nOscillation amplitude: 0.856\nSuggested drive amplitude: 0.160\nAmplitude updated: 0.160\n\nPlot displayed! You should see Rabi oscillations.\n</code></pre></p>"},{"location":"quick_start/#what-you-just-accomplished","title":"What You Just Accomplished","text":"<p>Congratulations! You just:</p> <ol> <li>Set up a quantum simulation environment - Created a virtual transmon qubit with realistic parameters</li> <li>Ran a Rabi oscillation experiment - Swept pulse duration to observe quantum oscillations</li> <li>Automatically calibrated qubit parameters - Found optimal drive amplitude for \u03c0 pulses</li> <li>Analyzed quantum data - Fitted oscillations and extracted meaningful parameters</li> </ol> <p>The Rabi experiment you ran is fundamental to quantum computing - it demonstrates coherent control of a qubit state and is used to calibrate the strength of quantum gates.</p>"},{"location":"quick_start/#troubleshooting","title":"Troubleshooting","text":""},{"location":"quick_start/#installation-issues","title":"Installation Issues","text":"<p>Problem: <code>ImportError: No module named 'leeq'</code> <pre><code># Solution: Install in development mode\npip install -e git+https://github.com/ShuxiangCao/LeeQ#egg=leeq\n</code></pre></p> <p>Problem: <code>ModuleNotFoundError: No module named 'plotly'</code> <pre><code># Solution: Install plotting dependencies\npip install plotly kaleido\n</code></pre></p>"},{"location":"quick_start/#runtime-issues","title":"Runtime Issues","text":"<p>Problem: <code>KeyError: 'Frequency'</code> in fit results - Cause: Insufficient oscillations in the data - Solution: Increase the stop time or decrease step size in the Rabi experiment</p> <p>Problem: No plot displayed - Cause: Running in environment without display - Solution: Save plot to file instead: <pre><code>fig = rabi_exp.plot()\nfig.write_html(\"rabi_results.html\")\nprint(\"Plot saved to rabi_results.html\")\n</code></pre></p> <p>Problem: \"No virtual qubit found\" error - Cause: Setup not properly registered - Solution: Ensure <code>manager.register_setup(setup)</code> is called</p>"},{"location":"quick_start/#getting-help","title":"Getting Help","text":"<p>If you encounter issues: 1. Check the Issues page for similar problems 2. Verify all dependencies are installed: <code>pip list | grep -E \"(numpy|scipy|plotly)\"</code> 3. Follow the comprehensive tutorial for more detailed explanations</p>"},{"location":"quick_start/#next-steps","title":"Next Steps","text":"<p>Ready to explore more? Here's your learning path:</p>"},{"location":"quick_start/#immediate-next-steps-15-30-minutes","title":"Immediate Next Steps (15-30 minutes)","text":"<ul> <li>Tutorial: Read the complete tutorial for deeper understanding</li> <li>Interactive Learning: Work through the tutorial for hands-on practice</li> <li>More Experiments: Explore T1, T2, and spectroscopy experiments</li> </ul>"},{"location":"quick_start/#intermediate-learning-1-2-hours","title":"Intermediate Learning (1-2 hours)","text":"<ul> <li>Multi-qubit Systems: Learn about two-qubit gates and entanglement</li> <li>Real Hardware: Connect to actual quantum hardware when available</li> <li>Custom Experiments: Build your own experiment sequences</li> </ul>"},{"location":"quick_start/#advanced-features-2-hours","title":"Advanced Features (2+ hours)","text":"<ul> <li>AI Integration: Use LeeQ's AI agents for automated calibration</li> <li>Data Analysis: Master the Chronicle logging and analysis tools</li> <li>Hardware Integration: Connect to QubiC or other quantum control systems</li> </ul>"},{"location":"quick_start/#recommended-learning-order","title":"Recommended Learning Order","text":"<ol> <li>Start Here: Complete Tutorial - Build on what you learned</li> <li>Core Concepts: User Guide - Understand LeeQ architecture</li> <li>Experiments Guide: Experiments - Learn about available experiments</li> <li>Documentation: API Reference - Detailed technical documentation</li> </ol>"},{"location":"quick_start/#environment-configuration-optional","title":"Environment Configuration (Optional)","text":"<p>For persistent settings, you can set these environment variables:</p> <pre><code># Optional: Set custom data directories\nexport LAB_CHRONICLE_LOG_DIR=\"/path/to/experiment/logs\"\nexport LEEQ_CALIBRATION_LOG_PATH=\"/path/to/calibration/logs\"\n</code></pre> <p>If not set, LeeQ creates these directories in your working folder automatically.</p> <p>Congratulations on running your first quantum experiment with LeeQ! </p> <p>You're now ready to dive deeper into quantum computing with a powerful, flexible framework at your fingertips.</p>"},{"location":"tutorial/","title":"LeeQ Tutorial: From Quantum Concepts to Advanced Experiments","text":"<p>Welcome to the comprehensive LeeQ tutorial. This guide will take you on a journey from fundamental quantum computing concepts to advanced experimental procedures. LeeQ is a powerful framework for orchestrating quantum computing experiments on superconducting circuits, designed for both simulation and real hardware.</p>"},{"location":"tutorial/#learning-path-overview","title":"Learning Path Overview","text":"<p>This tutorial follows a progressive learning approach:</p> <ol> <li>Quantum Computing Fundamentals in LeeQ - Understanding qubits, gates, and measurements</li> <li>LeeQ Architecture and Components - Core concepts and object model</li> <li>Single Qubit Experiments - Basic operations and calibration</li> <li>Multi-Qubit Systems - Entanglement and two-qubit gates</li> <li>Advanced Calibration Procedures - Theory and practical implementation</li> <li>Custom Experiment Development - Building your own experiments</li> </ol>"},{"location":"tutorial/#interactive-learning-experience","title":"Interactive Learning Experience","text":"<p>For the best learning experience, read the concepts below and then try the hands-on interactive notebooks:</p> <p>Interactive Notebooks</p> <ul> <li>LeeQ Basics - Set up simulation and run first experiments</li> <li>Single Qubit Operations - Practice with quantum gates and calibration</li> <li>Multi-Qubit Systems - Explore entanglement and two-qubit gates</li> <li>Calibration Workflows - Complete calibration procedures</li> <li>AI Integration - Automated experiment generation</li> </ul> <p>Additional Resources</p> <p>After completing the tutorial, explore specific techniques in the User Guide and learn about experiments and calibrations.</p>"},{"location":"tutorial/#part-1-quantum-computing-fundamentals-in-leeq","title":"Part 1: Quantum Computing Fundamentals in LeeQ","text":""},{"location":"tutorial/#understanding-qubits-in-leeq","title":"Understanding Qubits in LeeQ","text":"<p>In quantum computing, a qubit is the fundamental unit of quantum information. Unlike classical bits that exist in states 0 or 1, qubits can exist in a superposition of both states simultaneously. In LeeQ, we work primarily with transmon qubits - superconducting devices that behave as artificial atoms.</p>"},{"location":"tutorial/#key-quantum-concepts","title":"Key Quantum Concepts:","text":"<p>Superposition: A qubit can be in state |0\u27e9, |1\u27e9, or any linear combination \u03b1|0\u27e9 + \u03b2|1\u27e9 where |\u03b1|\u00b2 + |\u03b2|\u00b2 = 1.</p> <p>Quantum Gates: Operations that manipulate qubit states. Common single-qubit gates include: - X gate: Bit flip (|0\u27e9 \u2194 |1\u27e9) - Y gate: Bit flip with phase - Z gate: Phase flip - Hadamard (H): Creates superposition</p> <p>Measurement: The process of reading a qubit's state, which collapses the superposition to either |0\u27e9 or |1\u27e9.</p> <p>Decoherence: Quantum states are fragile and decay over time: - T1 (relaxation time): Time for excited state |1\u27e9 to decay to ground state |0\u27e9 - T2 (dephasing time): Time for superposition to lose coherence</p>"},{"location":"tutorial/#transmon-physics","title":"Transmon Physics","text":"<p>Transmons are weakly anharmonic oscillators with multiple energy levels. In LeeQ, we typically work with the first few levels: - |0\u27e9: Ground state - |1\u27e9: First excited state (computational qubit states) - |2\u27e9: Second excited state (leakage level)</p> <p>The anharmonicity (difference between energy level spacings) allows us to address qubit transitions selectively.</p> <p>Try It Yourself</p> <p>Ready to see these concepts in action? Continue reading to set up a simulation and explore quantum states interactively.</p>"},{"location":"tutorial/#part-2-leeq-architecture-and-components","title":"Part 2: LeeQ Architecture and Components","text":""},{"location":"tutorial/#core-object-model","title":"Core Object Model","text":"<p>LeeQ uses an object-oriented approach to quantum experiment orchestration. Understanding the hierarchy is crucial:</p> <pre><code>ExperimentManager\n    \u2514\u2500\u2500 Setup (e.g., HighLevelSimulationSetup)\n        \u2514\u2500\u2500 TransmonElement (DUT - Device Under Test)\n            \u251c\u2500\u2500 Collections (pulse definitions)\n            \u2502   \u251c\u2500\u2500 f01 (0\u21921 transition)\n            \u2502   \u2514\u2500\u2500 f12 (1\u21922 transition)\n            \u2514\u2500\u2500 Measurement Primitives\n                \u251c\u2500\u2500 Readout configurations\n                \u2514\u2500\u2500 State discrimination\n</code></pre>"},{"location":"tutorial/#key-components","title":"Key Components:","text":"<p>TransmonElement (DUT): Represents a physical or virtual qubit with: - Human-readable ID (hrid) - Pulse collections for different transitions - Measurement primitive definitions - Calibration parameters</p> <p>Collections: Group related pulses sharing common parameters: - Drive collections (e.g., 'f01' for qubit transitions) - Virtual operations (phase shifts for Z gates)</p> <p>Measurement Primitives: Define how to read qubit states: - Readout pulse parameters - Data acquisition settings - State discrimination methods</p> <p>Logical Primitives (LP): Basic operations like single pulses or delays</p> <p>Logical Primitive Blocks (LPB): Composite operations combining LPs: - Series: Sequential execution (A + B) - Parallel: Simultaneous execution (A * B) - Sweep: Parameter sweeps for measurements</p>"},{"location":"tutorial/#leeqs-pulse-based-approach","title":"LeeQ's Pulse-Based Approach","text":"<p>Unlike gate-based quantum computing abstractions, LeeQ works at the pulse level, giving you precise control over:</p> <ol> <li>Pulse shapes: Gaussian, Blackman-Harris, DRAG, custom shapes</li> <li>Timing: Exact pulse scheduling and delays</li> <li>Phases: Real-time phase adjustments for gates</li> <li>Amplitudes: Power control for Rabi rotations</li> </ol> <p>This low-level control is essential for: - Calibrating gate fidelities - Characterizing qubit properties - Implementing optimal control sequences - Mitigating crosstalk and errors</p> <p>Practice with LPs and LPBs</p> <p>See logical primitives in action in the sections below, where you'll learn to build and execute quantum gate sequences.</p>"},{"location":"tutorial/#parameter-storage-and-update","title":"Parameter Storage and Update","text":""},{"location":"tutorial/#dut-object","title":"DUT Object","text":"<p>At the heart of LeeQ is the DUT (Device Under Test) object, such as the <code>TransmonElement</code> object. The DUT Object represents the central configuration storage mechanism in LeeQ for quantum devices. The <code>TransmonElement</code> class specifically implements a superconducting transmon qubit as a DUT.</p> <p>This object is pivotal for parameter storage and maintaining all configuration data that describes various elements like the channel, qubit frequency, and pulse shape. The DUT Object encapsulates all the information needed to control and interact with a quantum device, making it the primary interface between your experimental code and the underlying hardware.</p> <p>To construct a DUT object, you define a dictionary as follows:</p> <pre><code>from leeq.core.elements.built_in.qudit_transmon import TransmonElement\n\nTransmonElement(name=\"Q1\", parameters={\n    'hrid': 'Q1',  # Human-readable ID\n    'lpb_collections': lpb_collections,  # LPB collection definition dictionary\n    'measurement_primitives': measurement_primitives  # Measurement primitives definition dictionary\n})\n</code></pre> <p>When it comes to saving the calibration log, the configuration of each DUT object is stored on disk. This allows for the object to be reloaded and reconstructed later on.</p>"},{"location":"tutorial/#collection","title":"Collection","text":"<p>A Collection represents a group of pulses or virtual operations (like a phase shift for a virtual Z gate) that share common parameters. Collections are fundamental organizational units in LeeQ that allow you to define families of related operations with shared characteristics such as frequency, amplitude, and pulse shape.</p> <p>The most common type is <code>SimpleDriveCollection</code>, which groups single-qubit drive pulses that operate on the same transition (e.g., the 0\u21941 transition of a transmon). Below is an example of a collection configuration:</p> <pre><code>lpb_collections = {\n    'f01': {\n        'type': 'SimpleDriveCollection',  # Class of the collection\n        'freq': 4888.20,  # Frequency in MHz\n        'channel': 0,  # Refer to QubiC LeeQ channel map for details\n        'shape': 'blackman_drag',\n        'amp': 0.21,\n        'phase': 0.,  # Phase in radians\n        'width': 0.05,  # Width in microseconds\n        'alpha': 1e9,\n        'trunc': 1.2\n    }\n}\n</code></pre> <p>You can add more items to the LPB collections to define various pulses. The convention \"f\" is used to denote a pulse that drives transitions in a subspace, like <code>f13</code> for a two-photon transition drive between the 1 and 3 states of a transmon."},{"location":"tutorial/#measurement-primitives","title":"Measurement Primitives","text":"<p>Measurement Primitives are definitions for measurement pulses that handle quantum state readout. These primitives define how to extract information from quantum systems through dispersive measurements. When a measurement primitive is activated, the data acquisition device automatically starts collecting data from the quantum system.</p> <p>The most common type is <code>SimpleDispersiveMeasurement</code>, which implements dispersive readout where the qubit state affects the resonator frequency, allowing state discrimination through phase and amplitude measurements. Here's an example definition for qubit and qutrit readouts:</p> <pre><code>measurement_primitives = {\n    '0': {\n        'type': 'SimpleDispersiveMeasurement',\n        'freq': 9997.6,  # Frequency in MHz\n        'channel': 1,  # Refer to QubiC LeeQ channel map for details\n        'shape': 'square',\n        'amp': 0.06,\n        'phase': 0.,  # Phase in radians\n        'width': 8,  # Width in microseconds\n        'trunc': 1.2,\n        'distinguishable_states': [0, 1]  # Distinguishable states\n    },\n    '1': {\n        'type': 'SimpleDispersiveMeasurement',\n        'freq': 9997.55,\n        'channel': 1,\n        'shape': 'square',\n        'amp': 0.06,\n        'phase': 0.,\n        'width': 8,\n        'trunc': 1.2,\n        'distinguishable_states': [0, 1, 2]\n    }\n}\n</code></pre> <p>Post-experiment, a state classifier, such as one generated by the <code>MeasurementCalibrationMultilevelGMM</code> experiment, must be trained. This classifier is then stored in memory and applied to subsequent experiments until the kernel is shut down. To update the classifier, simply rerun the calibration process.</p>"},{"location":"tutorial/#customizing-pulse-shapes","title":"Customizing Pulse Shapes","text":"<p>In LeeQ, pulse shapes are defined through functions that take a sampling rate as their first argument, followed by several other parameters, including optional ones.</p> <pre><code>import numpy as np\nfrom leeq.compiler.utils.time_base import get_t_list\n\ndef custom_gaussian_func(sampling_rate: int, amp: float, phase: float, width: float, trunc: float) -&gt; np.array:\n    \"\"\"\n    Create a custom Gaussian pulse shape with specified parameters.\n\n    Args:\n        sampling_rate: Sample rate for the pulse\n        amp: Pulse amplitude\n        phase: Phase in radians\n        width: Pulse width in microseconds\n        trunc: Truncation factor for the pulse\n\n    Returns:\n        Complex array representing the pulse shape\n    \"\"\"\n    gauss_width = width / 2.0\n    t = get_t_list(sampling_rate, width * trunc)\n    return amp * np.exp(1.0j * phase) * np.exp(-((t - gauss_width) / gauss_width) ** 2).astype(\"complex64\")\n</code></pre> <p>To integrate custom pulse shapes into LeeQ, use the <code>PulseShapeFactory</code> object. This singleton facilitates the registration of new pulse shapes. Custom pulse shapes can be added to <code>leeq/compiler/utils/pulse_shapes/basic_shapes.py</code> and made visible by including their names in the file\u2019s <code>__all__</code> list for automatic loading. Alternatively, pulse shapes can be registered manually as needed:</p> <pre><code>from leeq.compiler.utils.pulse_shape_utils import PulseShapeFactory\n\nPulseShapeFactory().register_pulse_shape(\n    pulse_shape_name='custom_gaussian_func',\n    pulse_shape_function=custom_gaussian_func\n)\n</code></pre>"},{"location":"tutorial/#orchestrating-pulses","title":"Orchestrating Pulses","text":"<p>LeeQ employs a tree structure for scheduling rather than a predefined schedule, introducing two key concepts:</p> <p>Logical Primitive: The basic operation, typically a single pulse or delay, serving as a tree leaf in the pulse scheduling hierarchy. Each Logical Primitive represents an atomic operation that cannot be further subdivided.</p> <p>Logical Primitive Block (LPB): A composite element within the tree, including <code>LogicalPrimitiveBlockSeries</code>, <code>LogicalPrimitiveBlockParallel</code>, and <code>LogicalPrimitiveBlockSweep</code>.</p> <p><code>LogicalPrimitiveBlockSeries</code> signifies sequential execution of its children. It can be constructed using the <code>+</code> operator to combine LPs or LPBs.</p> <p><code>LogicalPrimitiveBlockParallel</code> indicates simultaneous start times for its children, created using the <code>*</code> operator.</p> <p><code>LogicalPrimitiveBlockSweep</code> pairs with a <code>Sweeper</code> for dynamic pulse adjustments during a sequence sweep.</p> <p>Example:</p> <pre><code>from leeq.core.primitives.logical_primitive_block import LogicalPrimitiveBlockSeries, LogicalPrimitiveBlockParallel\n\nlpb_1 = LogicalPrimitiveBlockSeries([lp_1, lp_2, lp_3])\n\nlpb_2 = LogicalPrimitiveBlockParallel([lpb_1, lp_4])  # Mixing LPBs and LPs\n\nlpb_3 = lpb_1 + lpb_2  # Series combination\n\nlpb_4 = lpb_1 * lpb_2  # Parallel combination\n</code></pre>"},{"location":"tutorial/#single-qubit-operations","title":"Single Qubit Operations","text":"<p>Single qubit gates are accessible through the DUT object's collection, which organizes the operations by subspace. For instance:</p> <pre><code>dut = duts_dict['Q1']\nc1 = dut.get_c1('f01')  # Access the single qubit drive collection for subspace 0,1\nlp = c1['X']  # X gate\nlp = c1['Y']  # Y gate\nlp = c1['Yp']  # +pi/2 Y gate\nlp = c1['Ym']  # -pi/2 Y gate\n</code></pre> <p>Shortcut methods are available for composite gates, like:</p> <pre><code>gate = dut.get_gate('qutrit_hadamard')\n</code></pre> <p>The returned object, typically an LPB, consists of a sequence of gates. Detailed documentation is available for <code>get_gate</code>.</p> <p>To access measurement primitives:</p> <pre><code>mprim = dut.get_measurement_prim_intlist(name='0')\n</code></pre> <p><code>get_measurement_prim_intlist</code> offers single-shot, demodulated, and aggregated readouts, among other options detailed in the documentation.</p>"},{"location":"tutorial/#adjusting-runtime-parameters","title":"Adjusting Runtime Parameters","text":"<p>You can update parameters for gates or measurement primitives on-the-fly during experiments, with changes stored in memory. This dynamic parameter adjustment capability is crucial for real-time calibration and optimization workflows.</p> <p>Parameter updates can be applied to any collection or measurement primitive using the <code>set_parameters()</code> method:</p> <pre><code># Update pulse amplitude\nqubit.get_c1('f01').set_parameters({'amp': 0.52})\n\n# Update frequency and phase simultaneously  \nqubit.get_c1('f01').set_parameters({'freq': 5040.2, 'phase': 0.1})\n</code></pre> <p>To achieve calibration persistence and save adjustments permanently:</p> <pre><code>dut.save_calibration_log()\n</code></pre> <p>This saves the configuration to disk, enabling calibration persistence across experimental sessions. To load a saved configuration:</p> <pre><code>from leeq.core.elements.built_in.qudit_transmon import TransmonElement\n\ndut = TransmonElement.load_from_calibration_log('&lt;Qubit hrid&gt;')\n</code></pre> <p>This method retrieves the latest calibration log, restoring all previously saved parameter values. If <code>LEEQ_CALIBRATION_LOG_PATH</code> is unset, logs are saved in the default <code>.\\calibration_log</code> directory. This calibration persistence mechanism ensures that experimental setups can be reliably reproduced and builds upon previous optimization work.</p>"},{"location":"tutorial/#part-4-single-qubit-experiments-and-calibration","title":"Part 4: Single Qubit Experiments and Calibration","text":"<p>Interactive Learning</p> <p>Follow along with this section for hands-on practice with the concepts described below.</p>"},{"location":"tutorial/#setting-up-your-first-experiment","title":"Setting Up Your First Experiment","text":"<p>Before running experiments, you need to set up LeeQ with either a simulation or hardware backend. Here's how to create a simulated two-qubit system:</p> <pre><code>from leeq.chronicle import Chronicle\nfrom leeq.core.elements.built_in.qudit_transmon import TransmonElement\nfrom leeq.setups.built_in.setup_simulation_high_level import HighLevelSimulationSetup\nfrom leeq.experiments.experiments import ExperimentManager\nfrom leeq.theory.simulation.numpy.rotated_frame_simulator import VirtualTransmon\nimport numpy as np\n\n# Start data logging\nChronicle().start_log()\n\n# Create experiment manager and clear any existing setups\nmanager = ExperimentManager()\nmanager.clear_setups()\n\n# Define virtual transmons with realistic parameters\nvirtual_qubit_a = VirtualTransmon(\n    name=\"VQubitA\",\n    qubit_frequency=5040.4,  # MHz\n    anharmonicity=-198,      # MHz\n    t1=70,                   # microseconds\n    t2=35,                   # microseconds  \n    readout_frequency=9645.4,\n    quiescent_state_distribution=np.array([0.8, 0.15, 0.04, 0.01])\n)\n\n# Create high-level simulation setup\nsetup = HighLevelSimulationSetup(\n    name='TutorialSimulation',\n    virtual_qubits={2: virtual_qubit_a}  # Channel 2 for drive\n)\n\n# Register the setup\nmanager.register_setup(setup)\n\n# Create DUT configuration\nqubit_config = {\n    'hrid': 'Q1',\n    'lpb_collections': {\n        'f01': {\n            'type': 'SimpleDriveCollection',\n            'freq': 5040.4,\n            'channel': 2,\n            'shape': 'blackman_drag',\n            'amp': 0.5487,\n            'phase': 0.,\n            'width': 0.05,\n            'alpha': 500,\n            'trunc': 1.2\n        }\n    },\n    'measurement_primitives': {\n        '0': {\n            'type': 'SimpleDispersiveMeasurement',\n            'freq': 9645.5,\n            'channel': 1,\n            'shape': 'square',\n            'amp': 0.15,\n            'phase': 0.,\n            'width': 1,\n            'trunc': 1.2,\n            'distinguishable_states': [0, 1]\n        }\n    }\n}\n\n# Create the qubit DUT\nqubit = TransmonElement(name=\"Q1\", parameters=qubit_config)\n</code></pre>"},{"location":"tutorial/#fundamental-single-qubit-experiments","title":"Fundamental Single-Qubit Experiments","text":""},{"location":"tutorial/#1-rabi-oscillations","title":"1. Rabi Oscillations","text":"<p>Rabi experiments measure the relationship between pulse amplitude/duration and qubit state. This is fundamental for calibrating \u03c0-pulses (X gates).</p> <p>Theory: When you apply a resonant drive to a qubit, it oscillates between |0\u27e9 and |1\u27e9 states. The frequency of oscillation (Rabi frequency) is proportional to the drive amplitude.</p> <pre><code>from leeq.experiments.builtin.basic.calibrations.rabi import RabiAmpExperiment\nfrom leeq.experiments.experiments import basic\nimport numpy as np\n\n# Amplitude Rabi: Sweep drive amplitude\nrabi_amp = RabiAmpExperiment(\n    qubit=qubit,\n    collection_name='f01',\n    amp_range=np.linspace(0, 1.0, 51),\n    width=0.05  # Pulse width in microseconds\n)\n\n# The experiment will show oscillations - the first \u03c0-pulse amplitude gives maximum excitation\n</code></pre>"},{"location":"tutorial/#2-t1-relaxation-measurement","title":"2. T1 Relaxation Measurement","text":"<p>T1 measures how long an excited qubit stays in |1\u27e9 before decaying to |0\u27e9.</p> <p>Theory: After exciting a qubit with a \u03c0-pulse, the population decays exponentially: P(1) = e^(-t/T1)</p> <pre><code>from leeq.experiments.builtin.basic.characterizations.t1 import SimpleT1\nfrom leeq.experiments.experiments import basic\n\n# Measure T1 relaxation time\nt1_exp = SimpleT1(\n    qubit=qubit,\n    collection_name='f01', \n    time_length=200.0,      # Total measurement time (\u03bcs)\n    time_resolution=2.0     # Time step (\u03bcs)\n)\n\n# Expected: Exponential decay with time constant ~70 \u03bcs\n</code></pre>"},{"location":"tutorial/#3-t2-dephasing-measurement","title":"3. T2* Dephasing Measurement","text":"<p>T2* measures how quickly superposition states lose coherence due to dephasing.</p> <p>Theory: After creating superposition with \u03c0/2-pulse, the coherence decays as cos(\u03c9t)e^(-t/T2*)</p> <pre><code>from leeq.experiments.builtin.basic.characterizations.t2 import SimpleT2\nfrom leeq.experiments.experiments import basic\n\n# Measure T2* dephasing time  \nt2_exp = SimpleT2(\n    qubit=qubit,\n    collection_name='f01',\n    time_length=100.0,\n    time_resolution=1.0\n)\n\n# Expected: Oscillating decay with envelope ~35 \u03bcs\n</code></pre>"},{"location":"tutorial/#4-qubit-spectroscopy","title":"4. Qubit Spectroscopy","text":"<p>Finds the precise qubit transition frequency by sweeping drive frequency.</p> <pre><code>from leeq.experiments.builtin.basic.calibrations.qubit_spectroscopy import QubitSpectroscopy\nfrom leeq.experiments.experiments import basic\nimport numpy as np\n\n# Find the exact qubit frequency\nspec_exp = QubitSpectroscopy(\n    qubit=qubit,\n    collection_name='f01',\n    freq_range=np.linspace(5035, 5045, 101),  # MHz around expected frequency\n    amp=0.5\n)\n\n# Expected: Peak at ~5040.4 MHz\n</code></pre>"},{"location":"tutorial/#understanding-the-results","title":"Understanding the Results","text":"<p>Each experiment provides both data and fitted parameters:</p> <pre><code># After running T1 experiment\nprint(f\"Measured T1: {t1_exp.fit_params['tau']:.1f} \u03bcs\")\nprint(f\"Fit quality R\u00b2: {t1_exp.fit_params['r_squared']:.3f}\")\n\n# Access raw data\ntime_points = t1_exp.get_run_args_dict()['time_length']\npopulations = t1_exp.trace\n</code></pre>"},{"location":"tutorial/#part-5-multi-qubit-systems-and-entanglement","title":"Part 5: Multi-Qubit Systems and Entanglement","text":"<p>Interactive Multi-Qubit Learning</p> <p>Explore entanglement and two-qubit gates hands-on in the sections below.</p>"},{"location":"tutorial/#setting-up-two-qubit-systems","title":"Setting Up Two-Qubit Systems","text":"<p>Multi-qubit experiments enable quantum entanglement and two-qubit gates. Let's extend our setup to include a second qubit:</p> <pre><code>from leeq.theory.simulation.numpy.rotated_frame_simulator import VirtualTransmon\nfrom leeq.setups.built_in.setup_simulation_high_level import HighLevelSimulationSetup\nfrom leeq.core.elements.built_in.qudit_transmon import TransmonElement\nfrom leeq.experiments.experiments import basic\nimport numpy as np\n\n# Add a second virtual transmon\nvirtual_qubit_b = VirtualTransmon(\n    name=\"VQubitB\", \n    qubit_frequency=4855.3,\n    anharmonicity=-197,\n    t1=60,\n    t2=30,\n    readout_frequency=9025.1,\n    quiescent_state_distribution=np.array([0.75, 0.18, 0.05, 0.02])\n)\n\n# Create two-qubit setup with coupling\nsetup = HighLevelSimulationSetup(\n    name='TwoQubitSystem',\n    virtual_qubits={\n        2: virtual_qubit_a,  # Q1 on channel 2\n        4: virtual_qubit_b   # Q2 on channel 4  \n    }\n)\n\n# Set coupling strength between qubits (MHz)\nsetup.set_coupling_strength_by_qubit(\n    virtual_qubit_a, virtual_qubit_b, \n    coupling_strength=1.5\n)\n\n# Create second qubit configuration\nqubit_b_config = {\n    'hrid': 'Q2',\n    'lpb_collections': {\n        'f01': {\n            'type': 'SimpleDriveCollection',\n            'freq': 4855.3,\n            'channel': 4,\n            'shape': 'blackman_drag',\n            'amp': 0.5234,\n            'phase': 0.,\n            'width': 0.05,\n            'alpha': 480,\n            'trunc': 1.2\n        }\n    },\n    'measurement_primitives': {\n        '0': {\n            'type': 'SimpleDispersiveMeasurement', \n            'freq': 9025.1,\n            'channel': 3,\n            'shape': 'square',\n            'amp': 0.12,\n            'phase': 0.,\n            'width': 1,\n            'trunc': 1.2,\n            'distinguishable_states': [0, 1]\n        }\n    }\n}\n\nqubit_b = TransmonElement(name=\"Q2\", parameters=qubit_b_config)\n</code></pre>"},{"location":"tutorial/#understanding-quantum-entanglement","title":"Understanding Quantum Entanglement","text":"<p>Entanglement is a uniquely quantum phenomenon where qubits become correlated in ways impossible classically. Key concepts:</p> <ul> <li>Separable states: |\u03c8\u27e9 = |\u03c8\u2081\u27e9 \u2297 |\u03c8\u2082\u27e9 (qubits independent)</li> <li>Entangled states: Cannot be written as a product, e.g., |\u03a6\u207a\u27e9 = (|00\u27e9 + |11\u27e9)/\u221a2</li> <li>Bell states: Maximally entangled two-qubit states</li> </ul>"},{"location":"tutorial/#two-qubit-gate-implementations","title":"Two-Qubit Gate Implementations","text":""},{"location":"tutorial/#1-cnot-gate-via-cross-resonance","title":"1. CNOT Gate via Cross-Resonance","text":"<p>The most common two-qubit gate in superconducting systems uses cross-resonance coupling:</p> <pre><code>from leeq.experiments.builtin.multi_qubit_gates.conditional_stark_ai import ConditionalStarkShiftAI\nfrom leeq.experiments.experiments import basic\nimport numpy as np\n\n# Calibrate CNOT gate using AI-assisted optimization\ncnot_cal = ConditionalStarkShiftAI(\n    control_qubit=qubit,      # Q1 as control\n    target_qubit=qubit_b,     # Q2 as target\n    stark_drive_freq=4855.3,  # Drive at target frequency\n    amp_range=np.linspace(0, 0.3, 31),\n    width_range=np.linspace(0.1, 0.5, 21)\n)\n\n# This experiment finds optimal parameters for CNOT gate\n</code></pre>"},{"location":"tutorial/#2-bell-state-creation","title":"2. Bell State Creation","text":"<p>Create maximally entangled Bell states:</p> <pre><code>from leeq.core import primitives as prims\nfrom leeq.experiments.sweeper import Sweeper\nfrom leeq.experiments.experiments import basic\n\ndef create_bell_state():\n    \"\"\"\n    Create a Bell state preparation sequence.\n\n    Returns:\n        Bell state preparation LPB sequence\n    \"\"\"\n    # Get collections for both qubits\n    c1_q1 = qubit.get_c1('f01')\n    c1_q2 = qubit_b.get_c1('f01')\n\n    # Get measurement primitives\n    mp_q1 = qubit.get_measurement_prim_intlist(0)\n    mp_q2 = qubit_b.get_measurement_prim_intlist(0)\n\n    # Bell state sequence: H(Q1) + CNOT(Q1,Q2)\n    hadamard_q1 = c1_q1['Yp']  # \u03c0/2 Y rotation = Hadamard\n\n    # For CNOT, we need the calibrated two-qubit gate\n    # This is a simplified example - real implementation requires calibration\n    cnot_gate = get_calibrated_cnot_gate(qubit, qubit_b)\n\n    # Parallel measurement of both qubits\n    measurement = mp_q1 * mp_q2\n\n    # Complete sequence\n    bell_sequence = hadamard_q1 + cnot_gate + measurement\n\n    return bell_sequence\n\ndef measure_bell_state():\n    \"\"\"\n    Run Bell state measurement experiment.\n\n    Expected: ~50% |00\u27e9 and ~50% |11\u27e9, very little |01\u27e9 or |10\u27e9\n    \"\"\"\n    lpb = create_bell_state()\n\n    # Single shot measurement (no sweep)\n    swp = Sweeper([0], params=[])\n\n    # Measure both qubits\n    basic(lpb, swp, ['p(1)', 'p(1)'])\n</code></pre>"},{"location":"tutorial/#3-quantum-process-tomography","title":"3. Quantum Process Tomography","text":"<p>Characterize two-qubit gate fidelity using process tomography:</p> <pre><code>from leeq.experiments.builtin.tomography.qubits import ProcessTomographyTwoQubit\n\n# Measure the actual gate implemented vs. ideal CNOT\nprocess_tomo = ProcessTomographyTwoQubit(\n    control_qubit=qubit,\n    target_qubit=qubit_b,\n    gate_lpb=cnot_gate,  # The gate to characterize\n    num_preparations=16,  # Different input states\n    num_measurements=16   # Different measurement bases\n)\n\n# Results include:\n# - Process fidelity (how close to ideal CNOT)\n# - Gate error rates\n# - Systematic errors (e.g., over/under-rotation)\n</code></pre>"},{"location":"tutorial/#multi-qubit-measurement-and-correlation","title":"Multi-Qubit Measurement and Correlation","text":"<p>When measuring multiple qubits, you get correlated results:</p> <pre><code>import numpy as np\n\n# Simultaneous measurement\nresults_q1 = mp_q1.result()  # Shape: (shots,)\nresults_q2 = mp_q2.result()  # Shape: (shots,)\n\ndef calculate_correlations(r1, r2):\n    \"\"\"\n    Calculate correlation functions for two-qubit measurements.\n\n    Args:\n        r1: Results from qubit 1\n        r2: Results from qubit 2\n\n    Returns:\n        Dictionary with joint probabilities and entanglement witness\n    \"\"\"\n    # Joint probabilities\n    p_00 = np.mean((r1 == 0) &amp; (r2 == 0))\n    p_01 = np.mean((r1 == 0) &amp; (r2 == 1))\n    p_10 = np.mean((r1 == 1) &amp; (r2 == 0))\n    p_11 = np.mean((r1 == 1) &amp; (r2 == 1))\n\n    # Entanglement witness: for Bell state, expect p_00 + p_11 \u2248 1\n    entanglement_witness = p_00 + p_11\n\n    return {\n        'joint_probs': [p_00, p_01, p_10, p_11],\n        'entanglement_witness': entanglement_witness\n    }\n\ncorr_results = calculate_correlations(results_q1, results_q2)\nprint(f\"Entanglement witness: {corr_results['entanglement_witness']:.3f}\")\n</code></pre>"},{"location":"tutorial/#part-6-advanced-calibration-procedures","title":"Part 6: Advanced Calibration Procedures","text":"<p>Complete Calibration Workflows</p> <p>Practice advanced calibration techniques with the Calibrations Guide, which demonstrates systematic calibration procedures for real quantum devices.</p>"},{"location":"tutorial/#systematic-calibration-workflow","title":"Systematic Calibration Workflow","text":"<p>Real quantum devices require careful calibration of all parameters. Here's a systematic approach:</p>"},{"location":"tutorial/#1-frequency-calibration","title":"1. Frequency Calibration","text":"<pre><code>from leeq.experiments.builtin.basic.calibrations.qubit_spectroscopy import QubitSpectroscopy\nfrom leeq.experiments.experiments import basic\nimport numpy as np\n\ndef calibrate_frequencies(qubit, freq_range_mhz=10):\n    \"\"\"\n    Find precise qubit and readout frequencies.\n\n    Args:\n        qubit: Qubit element to calibrate\n        freq_range_mhz: Frequency range to scan around current value\n\n    Returns:\n        Calibrated frequency in MHz\n    \"\"\"\n\n    # 1. Rough frequency scan\n    current_freq = qubit.get_c1('f01').get_parameters()['freq']\n    rough_range = np.linspace(\n        current_freq - freq_range_mhz/2,\n        current_freq + freq_range_mhz/2, \n        101\n    )\n\n    rough_spec = QubitSpectroscopy(\n        qubit=qubit,\n        freq_range=rough_range,\n        amp=0.5\n    )\n\n    # 2. Fine frequency scan around peak\n    peak_freq = rough_spec.fit_params['center']\n    fine_range = np.linspace(peak_freq - 1, peak_freq + 1, 101)\n\n    fine_spec = QubitSpectroscopy(\n        qubit=qubit,\n        freq_range=fine_range,\n        amp=0.5\n    )\n\n    # 3. Update qubit frequency\n    calibrated_freq = fine_spec.fit_params['center']\n    qubit.get_c1('f01').set_parameters({'freq': calibrated_freq})\n\n    return calibrated_freq\n</code></pre>"},{"location":"tutorial/#2-rabi-calibration-for-gates","title":"2. Rabi Calibration for Gates","text":"<pre><code>from leeq.experiments.builtin.basic.calibrations.rabi import RabiAmpExperiment\nimport numpy as np\n\ndef calibrate_pi_pulse(qubit):\n    \"\"\"\n    Calibrate \u03c0-pulse amplitude for X gate.\n\n    Args:\n        qubit: Qubit element to calibrate\n\n    Returns:\n        Dictionary with \u03c0 and \u03c0/2 pulse amplitudes\n    \"\"\"\n\n    # Amplitude sweep for Rabi oscillations\n    rabi_exp = RabiAmpExperiment(\n        qubit=qubit,\n        amp_range=np.linspace(0, 1.2, 61),\n        width=0.05\n    )\n\n    # Find first maximum (\u03c0-pulse amplitude)\n    pi_amp = rabi_exp.fit_params['pi_amp']\n\n    # Update collection parameters\n    qubit.get_c1('f01').set_parameters({'amp': pi_amp})\n\n    # Calibrate \u03c0/2 pulses\n    half_pi_amp = pi_amp / 2\n\n    return {\n        'pi_amp': pi_amp,\n        'half_pi_amp': half_pi_amp\n    }\n</code></pre>"},{"location":"tutorial/#3-drag-pulse-optimization","title":"3. DRAG Pulse Optimization","text":"<p>DRAG (Derivative Removal by Adiabatic Gating) pulses reduce leakage to higher levels:</p> <pre><code>from leeq.experiments.builtin.basic.calibrations.drag import DragCalibration\nimport numpy as np\n\ndef optimize_drag_parameter(qubit):\n    \"\"\"\n    Optimize DRAG parameter to minimize leakage.\n\n    Args:\n        qubit: Qubit element to optimize\n\n    Returns:\n        Optimal DRAG alpha parameter\n    \"\"\"\n\n    drag_cal = DragCalibration(\n        qubit=qubit,\n        alpha_range=np.linspace(-1000, 1000, 41),\n        num_cliffords=20  # Test with multiple Clifford gates\n    )\n\n    # Optimal alpha minimizes population in |2\u27e9 state\n    optimal_alpha = drag_cal.fit_params['optimal_alpha']\n\n    # Update DRAG parameter\n    qubit.get_c1('f01').set_parameters({'alpha': optimal_alpha})\n\n    return optimal_alpha\n</code></pre>"},{"location":"tutorial/#4-complete-calibration-sequence","title":"4. Complete Calibration Sequence","text":"<pre><code>from leeq.experiments.builtin.basic.characterizations.t1 import SimpleT1\nfrom leeq.experiments.builtin.basic.characterizations.t2 import SimpleT2\n\ndef full_single_qubit_calibration(qubit):\n    \"\"\"\n    Complete single-qubit calibration sequence.\n\n    Args:\n        qubit: Qubit element to calibrate completely\n\n    Returns:\n        Dictionary with all calibration results\n    \"\"\"\n\n    print(\"Starting single-qubit calibration\")\n\n    # 1. Find precise frequency\n    print(\"1. Calibrating qubit frequency\")\n    freq = calibrate_frequencies(qubit)\n    print(f\"   Calibrated frequency: {freq:.3f} MHz\")\n\n    # 2. Calibrate \u03c0-pulse amplitude\n    print(\"2. Calibrating Rabi amplitude\")\n    rabi_params = calibrate_pi_pulse(qubit)\n    print(f\"   \u03c0-pulse amplitude: {rabi_params['pi_amp']:.4f}\")\n\n    # 3. Optimize DRAG parameter\n    print(\"3. Optimizing DRAG parameter\")\n    alpha = optimize_drag_parameter(qubit)\n    print(f\"   Optimal DRAG \u03b1: {alpha:.1f}\")\n\n    # 4. Characterize coherence times\n    print(\"4. Measuring coherence times\")\n    t1_exp = SimpleT1(qubit=qubit, time_length=300, time_resolution=3)\n    t2_exp = SimpleT2(qubit=qubit, time_length=150, time_resolution=1.5)\n\n    print(f\"   T1: {t1_exp.fit_params['tau']:.1f} \u03bcs\")\n    print(f\"   T2*: {t2_exp.fit_params['tau']:.1f} \u03bcs\")\n\n    # 5. Save calibration\n    qubit.save_calibration_log()\n    print(\"Calibration complete and saved!\")\n\n    return {\n        'frequency': freq,\n        'rabi_params': rabi_params,\n        'drag_alpha': alpha,\n        't1': t1_exp.fit_params['tau'],\n        't2_star': t2_exp.fit_params['tau']\n    }\n</code></pre>"},{"location":"tutorial/#two-qubit-gate-calibration","title":"Two-Qubit Gate Calibration","text":"<pre><code>from leeq.experiments.builtin.multi_qubit_gates.conditional_stark_ai import ConditionalStarkShiftAI\nfrom leeq.experiments.builtin.tomography.qubits import ProcessTomographyTwoQubit\nimport numpy as np\n\ndef calibrate_two_qubit_gate(control_qubit, target_qubit):\n    \"\"\"\n    Calibrate CNOT gate between two qubits.\n\n    Args:\n        control_qubit: Control qubit element\n        target_qubit: Target qubit element\n\n    Returns:\n        Dictionary with optimal parameters and gate fidelity\n    \"\"\"\n\n    print(\"Calibrating two-qubit CNOT gate\")\n\n    # 1. Find optimal cross-resonance parameters\n    cr_cal = ConditionalStarkShiftAI(\n        control_qubit=control_qubit,\n        target_qubit=target_qubit,\n        amp_range=np.linspace(0, 0.5, 26),\n        width_range=np.linspace(0.1, 1.0, 19)\n    )\n\n    optimal_params = cr_cal.get_optimal_parameters()\n\n    # 2. Characterize gate with process tomography\n    cnot_lpb = create_cnot_gate(control_qubit, target_qubit, optimal_params)\n\n    process_tomo = ProcessTomographyTwoQubit(\n        control_qubit=control_qubit,\n        target_qubit=target_qubit,\n        gate_lpb=cnot_lpb\n    )\n\n    gate_fidelity = process_tomo.results['process_fidelity']\n\n    print(f\"CNOT gate fidelity: {gate_fidelity:.3f}\")\n\n    return {\n        'optimal_params': optimal_params,\n        'gate_fidelity': gate_fidelity,\n        'gate_lpb': cnot_lpb\n    }\n</code></pre>"},{"location":"tutorial/#customizing-your-setup","title":"Customizing Your Setup","text":"<p>LeeQ provides integrated support for setups utilizing Single Board RPC control within the LBNL QubiC system. Here's a straightforward example of how to define your setup:</p> <pre><code>class QubiCDemoSetup(QubiCSingleBoardRemoteRPCSetup):\n\n    def __init__(self):\n        \"\"\"Initialize the QubiC demo setup with default configuration.\"\"\"\n        super().__init__(\n            name='qubic_demo_setup',\n            rpc_uri='http://192.168.1.80:9095' # The RPC address for QubiC system\n        )\n</code></pre> <p>The system can be configured to adjust pulse parameters before they are submitted to the compiler. This feature is particularly useful, for instance, when integrating the QubiC system to synthesize an Intermediate Frequency (IF) signal that will be mixed with an external Local Oscillator (LO).</p> <pre><code>class QubiCSetup(QubiCSingleBoardRemoteRPCSetup):\n\n    @staticmethod\n    def _readout_frequency_mixing_callback(parameters: dict):\n        \"\"\"\n        This function changes the frequency of the lpb parameters of the readout channel,\n        considering we have a mixing of 15GHz signal.\n        \"\"\"\n\n        if 'freq' not in parameters:\n            return parameters\n\n        modified_parameters = parameters.copy()\n        modified_parameters['freq'] = 15000-parameters['freq']  # 4-8 GHz for IF Readout\n        return modified_parameters\n\n    def __init__(self):\n        \"\"\"Initialize the QubiC setup with frequency mixing callback.\"\"\"\n        super().__init__(\n            name='qubic_setup',\n            rpc_uri='http://192.168.1.80:9095'\n        )\n\n        # Register call function for all readout channels\n\n        for i in range(8):\n            readout_channel = 2 * i + 1\n            self._status.register_compile_lpb_callback(\n                channel=readout_channel,\n                callback=self._readout_frequency_mixing_callback\n            )\n</code></pre>"},{"location":"tutorial/#creating-a-customized-experiment","title":"Creating a Customized Experiment","text":"<p>Customizing an experiment can generally be segmented into three main components: (1) the setup and execution of the experiment, including data acquisition; (2) data processing and analysis; and (3) data visualization.</p> <p>Below, we present an example outlining the implementation of a basic experiment aimed at measuring the T1 relaxation time of a qubit. For the sake of brevity and clarity, certain details in the data visualization section are simplified.</p> <pre><code>from leeq.experiments.experiments import Experiment\nfrom leeq.chronicle import log_and_record\nfrom leeq.experiments.plots.live_dash_app import register_browser_function\nfrom leeq.experiments.sweeper import Sweeper\nfrom leeq.experiments.experiments import basic\nfrom leeq.core import primitives as prims\nfrom leeq.experiments import sweeper as sparam\nimport numpy as np\nimport plotly.graph_objects as go\nfrom typing import Any, Optional\n\nclass SimpleT1(Experiment):\n    \"\"\"\n    Custom T1 relaxation measurement experiment.\n\n    This experiment measures the T1 relaxation time by applying a \u03c0-pulse\n    followed by a variable delay before measurement.\n    \"\"\"\n\n    @log_and_record # This decorator is used to log the experiment and record the data\n    def run(self, # The run function should be defined to carry out the experiment\n            qubit: Any,  # Qubit element to measure\n            collection_name: str = 'f01',\n            initial_lpb: Optional[Any] = None,  # Optional preparation sequence\n            mprim_index: int = 0,\n            time_length: float = 100.0,\n            time_resolution: float = 1.0\n            ) -&gt; None:\n        \"\"\"\n        Run T1 relaxation measurement.\n\n        Args:\n            qubit: Qubit element to measure\n            collection_name: Collection name for pulses\n            initial_lpb: Optional initial preparation sequence\n            mprim_index: Measurement primitive index\n            time_length: Maximum delay time in microseconds\n            time_resolution: Time step in microseconds\n        \"\"\"\n        c1 = qubit.get_c1(collection_name)\n        mp = qubit.get_measurement_prim_intlist(mprim_index)\n\n        self.mp = mp # Store the measurement primitive for the live data plot\n        delay = prims.Delay(0)\n\n        lpb = c1['X'] + delay + mp\n\n        if initial_lpb:\n            lpb = initial_lpb + lpb\n\n        sweep_range = np.arange(0.0, time_length, time_resolution)\n        swp = Sweeper(sweep_range,\n                      params=[sparam.func(delay.set_delay, {}, 'delay')])\n\n        # The basic function is used to run the experiment\n        # The swp is used to sweep the delay time\n        # The basis parameter is used to set what to return from the experiment, \n        # here we return the probability of the qubit in the excited state \n        basic(lpb, swp, 'p(1)') \n\n        self.trace = np.squeeze(mp.result())\n\n    # This decorator is used to register the function for visualization. \n    #It will be shown after the experiment is finished.\n    @register_browser_function() \n    def plot_t1(self, fit=True, step_no=None) -&gt; go.Figure:\n        \"\"\"\n        Plot T1 decay curve with optional fitting.\n\n        Args:\n            fit: Whether to perform exponential fit\n            step_no: Current step for live plotting\n\n        Returns:\n            Plotly figure object\n        \"\"\"\n        self.trace = np.squeeze(self.mp.result()) if hasattr(self, 'mp') else []\n        self.fit_params = {}  # Initialize as an empty dictionary or suitable default value\n\n        args = self.get_run_args_dict() # Retrieve the arguments from the run function\n\n        t = np.arange(0, args['time_length'], args['time_resolution'])\n        trace = self.trace\n\n        if step_no is not None: # The step number is used to plot the live data\n            t = t[:step_no[0]]\n            trace = trace[:step_no[0]]\n\n        # Create plot data\n        data = [go.Scatter(x=t, y=trace, mode='markers+lines', name='T1 Data')]\n        layout = go.Layout(title='T1 Relaxation Measurement', \n                          xaxis_title='Time (\u03bcs)', \n                          yaxis_title='P(|1\u27e9)')\n\n        fig = go.Figure(data=data, layout=layout)\n\n        return fig\n\n    def live_plots(self, step_no):\n        \"\"\"Generate live plots during experiment execution.\"\"\"\n        return self.plot_t1(fit=step_no[0] &gt; 10, step_no=step_no) # The live plot function is used to plot the live data\n</code></pre> <p>To initiate and execute the experiment, use the following snippet:</p> <pre><code>from leeq.core.elements.built_in.qudit_transmon import TransmonElement\n\n# Assuming you have a qubit already configured\nqubit = TransmonElement(name=\"Q1\", parameters=qubit_config)\nt1_exp = SimpleT1(qubit=qubit, time_length=100, time_resolution=0.5)\n</code></pre> <p>This command automatically runs the experiment and presents the results.</p>"},{"location":"tutorial/#data-persistence","title":"Data Persistence","text":"<p>LeeQ leverages the integrated leeq.chronicle module for data persistence. To ensure proper data logging from the outset, initiate the logging process at the beginning of your notebook as shown below. Additionally, remember to annotate the <code>run</code> method of your experiment class with <code>@log_and_record</code> to enable experiment logging.</p> <pre><code>from leeq.chronicle import Chronicle\nChronicle().start_log()\n</code></pre> <p>For each experiment, leeq.chronicle automatically generates a data path and experiment ID, which can be used to access the recorded data. For comprehensive information on data retrieval and additional functionalities, consult the leeq.chronicle documentation.</p>"},{"location":"tutorial/#part-7-custom-experiment-development","title":"Part 7: Custom Experiment Development","text":"<p>Build Your Own Experiments</p> <p>Learn to create custom experiments with the examples below, which show both automated experiment generation and manual custom experiment creation.</p>"},{"location":"tutorial/#anatomy-of-a-leeq-experiment","title":"Anatomy of a LeeQ Experiment","text":"<p>Building custom experiments follows a structured pattern. Here's the template for creating your own experiments:</p> <pre><code>from leeq.chronicle import log_and_record\nfrom leeq.experiments.plots.live_dash_app import register_browser_function\nfrom leeq.experiments.experiments import Experiment\nfrom leeq.experiments.sweeper import Sweeper\nfrom leeq.experiments.experiments import basic\nfrom leeq.core import primitives as prims\nfrom leeq.experiments import sweeper as sparam\nimport numpy as np\nfrom plotly import graph_objects as go\n\nclass MyCustomExperiment(Experiment):\n    \"\"\"\n    Template for custom experiments in LeeQ.\n\n    This example implements a custom Ramsey experiment with adjustable detuning.\n    \"\"\"\n\n    @log_and_record  # Essential: enables data logging\n    def run(self, \n            qubit,                    # Target qubit\n            collection_name='f01',    # Pulse collection to use\n            detuning_freq=0.1,       # Frequency detuning (MHz)\n            time_length=50.0,        # Max evolution time (\u03bcs)\n            time_resolution=1.0,     # Time step (\u03bcs)\n            initial_lpb=None         # Optional preparation sequence\n           ):\n        \"\"\"\n        Run custom Ramsey experiment with detuning.\n\n        Sequence: \u03c0/2 - delay - \u03c0/2(\u03c6) - measurement\n        where \u03c6 = 2\u03c0 * detuning * delay\n        \"\"\"\n\n        # Get pulse collection and measurement primitive\n        c1 = qubit.get_c1(collection_name)\n        mp = qubit.get_measurement_prim_intlist(0)\n\n        # Store for plotting\n        self.mp = mp\n        self.detuning = detuning_freq\n\n        # Create delay primitive\n        from leeq.core import primitives as prims\n        delay = prims.Delay(0)  # Will be swept\n\n        # Create Ramsey sequence: \u03c0/2 - delay - \u03c0/2 - measure\n        ramsey_lpb = c1['Yp'] + delay + c1['Yp'] + mp\n\n        # Add initial preparation if provided\n        if initial_lpb:\n            ramsey_lpb = initial_lpb + ramsey_lpb\n\n        # Create time sweep\n        sweep_times = np.arange(0.0, time_length, time_resolution)\n\n        # Create phase sweep for detuning effect\n        phases = 2 * np.pi * detuning_freq * sweep_times\n\n        # Create sweeper for both delay and phase\n        from leeq.experiments.sweeper import SweepParametersSideEffect\n\n        delay_sweep = sparam.func(delay.set_delay, {}, 'delay')\n        phase_sweep = sparam.func(c1['Yp'].set_phase, {}, 'phase')\n\n        swp = Sweeper(\n            param_list=list(zip(sweep_times, phases)),\n            params=[delay_sweep, phase_sweep]\n        )\n\n        # Execute experiment\n        basic(ramsey_lpb, swp, 'p(1)')\n\n        # Store results\n        self.trace = np.squeeze(mp.result())\n        self.times = sweep_times\n\n    @register_browser_function()  # Makes plot available in web interface\n    def plot_ramsey(self, fit=True):\n        \"\"\"Plot Ramsey oscillations with optional fitting.\"\"\"\n\n        if not hasattr(self, 'trace'):\n            return go.Figure()\n\n        # Create plot data\n        trace_data = go.Scatter(\n            x=self.times,\n            y=self.trace,\n            mode='markers+lines',\n            name=f'Ramsey (\u03b4f={self.detuning:.2f} MHz)',\n            marker=dict(size=4)\n        )\n\n        data = [trace_data]\n\n        # Optional fitting\n        if fit and len(self.times) &gt; 10:\n            try:\n                # Fit oscillating decay: A*cos(2\u03c0ft + \u03c6)*exp(-t/T2) + offset\n                from scipy.optimize import curve_fit\n\n                def ramsey_func(t, amp, freq, phase, t2, offset):\n                    \"\"\"Ramsey oscillation function with exponential decay.\"\"\"\n                    return amp * np.cos(2*np.pi*freq*t + phase) * np.exp(-t/t2) + offset\n\n                # Initial guess\n                p0 = [0.4, self.detuning, 0, 20, 0.5]\n\n                popt, _ = curve_fit(ramsey_func, self.times, self.trace, p0=p0)\n\n                # Generate fit curve\n                t_fit = np.linspace(0, self.times[-1], 200)\n                y_fit = ramsey_func(t_fit, *popt)\n\n                fit_trace = go.Scatter(\n                    x=t_fit,\n                    y=y_fit,\n                    mode='lines',\n                    name=f'Fit (T2*={popt[3]:.1f}\u03bcs)',\n                    line=dict(color='red', dash='dash')\n                )\n                data.append(fit_trace)\n\n                # Store fit parameters\n                self.fit_params = {\n                    'amplitude': popt[0],\n                    'frequency': popt[1], \n                    'phase': popt[2],\n                    't2_star': popt[3],\n                    'offset': popt[4]\n                }\n\n            except Exception as e:\n                print(f\"Fitting failed: {e}\")\n\n        # Create layout\n        layout = go.Layout(\n            title=f'Custom Ramsey Experiment (Detuning: {self.detuning:.2f} MHz)',\n            xaxis=dict(title='Time (\u03bcs)'),\n            yaxis=dict(title='P(|1\u27e9)'),\n            hovermode='closest'\n        )\n\n        return go.Figure(data=data, layout=layout)\n\n    def live_plots(self, step_no):\n        \"\"\"Real-time plotting during experiment.\"\"\"\n        return self.plot_ramsey(fit=step_no[0] &gt; 10)\n</code></pre>"},{"location":"tutorial/#running-your-custom-experiment","title":"Running Your Custom Experiment","text":"<pre><code># Run the custom experiment\ncustom_exp = MyCustomExperiment(\n    qubit=qubit,\n    detuning_freq=0.2,  # 200 kHz detuning\n    time_length=80.0,\n    time_resolution=1.0\n)\n\n# Access results\nprint(f\"Measured T2*: {custom_exp.fit_params['t2_star']:.1f} \u03bcs\")\nprint(f\"Observed frequency: {custom_exp.fit_params['frequency']:.3f} MHz\")\n</code></pre>"},{"location":"tutorial/#advanced-experiment-features","title":"Advanced Experiment Features","text":""},{"location":"tutorial/#1-multi-parameter-sweeps","title":"1. Multi-Parameter Sweeps","text":"<pre><code>from leeq.experiments.experiments import Experiment\nfrom leeq.chronicle import log_and_record\nfrom leeq.experiments.sweeper import Sweeper\nfrom leeq.experiments.experiments import basic\nfrom leeq.experiments import sweeper as sparam\nimport numpy as np\n\nclass ParameterSweep2D(Experiment):\n    \"\"\"\n    Example of 2D parameter sweep experiment.\n\n    This experiment demonstrates how to sweep two parameters simultaneously\n    and collect data in a 2D grid format.\n    \"\"\"\n\n    @log_and_record\n    def run(self, qubit, amp_range, freq_range):\n        \"\"\"\n        Run 2D parameter sweep over amplitude and frequency.\n\n        Args:\n            qubit: Qubit element to use\n            amp_range: Array of amplitude values to sweep\n            freq_range: Array of frequency values to sweep\n        \"\"\"\n        c1 = qubit.get_c1('f01')\n        mp = qubit.get_measurement_prim_intlist(0)\n\n        # Create 2D parameter grid\n        amp_grid, freq_grid = np.meshgrid(amp_range, freq_range)\n        param_pairs = list(zip(amp_grid.flatten(), freq_grid.flatten()))\n\n        # Define parameter sweeps\n        amp_sweep = sparam.func(c1.set_amp, {}, 'amplitude')\n        freq_sweep = sparam.func(c1.set_freq, {}, 'frequency')\n\n        swp = Sweeper(param_pairs, params=[amp_sweep, freq_sweep])\n\n        # Simple pulse-measure sequence\n        lpb = c1['X'] + mp\n        basic(lpb, swp, 'p(1)')\n\n        # Reshape results back to 2D\n        self.results_2d = mp.result().reshape(len(freq_range), len(amp_range))\n        self.amp_range = amp_range\n        self.freq_range = freq_range\n</code></pre>"},{"location":"tutorial/#2-ai-assisted-optimization","title":"2. AI-Assisted Optimization","text":"<pre><code>from k_agents.inspection.decorator import text_inspection\nfrom leeq.experiments.experiments import Experiment\nfrom leeq.chronicle import log_and_record\nfrom leeq.experiments.experiments import basic\n\nclass AIOptimizedExperiment(Experiment):\n    \"\"\"\n    Example using LeeQ's AI capabilities for parameter optimization.\n\n    This experiment demonstrates integration with AI agents for automated\n    parameter optimization and experimental feedback.\n    \"\"\"\n\n    @text_inspection(agent_name=\"experiment_optimizer\")\n    @log_and_record\n    def run(self, qubit, optimization_target='fidelity'):\n        \"\"\"\n        AI agent can analyze results and suggest parameter adjustments.\n\n        Args:\n            qubit: Qubit element to optimize\n            optimization_target: Target metric to optimize\n        \"\"\"\n        # Implementation with AI feedback loop\n        c1 = qubit.get_c1('f01')\n        mp = qubit.get_measurement_prim_intlist(0)\n\n        # Run initial measurement\n        lpb = c1['X'] + mp\n        basic(lpb, None, 'p(1)')\n\n        # Store results for AI analysis\n        self.initial_results = mp.result()\n\n        # AI agent will analyze these results and suggest optimizations\n        print(f\"Optimizing {optimization_target} for qubit {qubit.hrid}\")\n</code></pre>"},{"location":"tutorial/#next-steps-and-learning-resources","title":"Next Steps and Learning Resources","text":""},{"location":"tutorial/#immediate-next-steps","title":"Immediate Next Steps","text":"<ol> <li>Explore the User Guide: Understand LeeQ's architecture and capabilities:</li> <li>Core Concepts - LeeQ design principles and architecture</li> <li>Experiments Guide - Available experiment types</li> <li> <p>Calibrations Guide - Calibration procedures</p> </li> <li> <p>Dive into the API Documentation:</p> </li> <li>Core API - Base classes and functionality</li> <li>Experiments API - Built-in experiments</li> <li>Theory API - Simulation backends</li> <li> <p>Compiler API - Pulse compilation</p> </li> <li> <p>Apply Your Knowledge:</p> </li> <li>Build custom experiments using the patterns from this tutorial</li> <li>Implement calibration workflows for your quantum system</li> <li>Use AI assistance for experiment generation</li> <li> <p>Analyze results with Chronicle logging</p> </li> <li> <p>Join the Community: Connect with other LeeQ users for support and collaboration</p> </li> </ol>"},{"location":"tutorial/#advanced-topics-to-explore","title":"Advanced Topics to Explore","text":"<ol> <li>Optimal Control: Use GRAPE and other techniques for pulse optimization</li> <li>Error Mitigation: Implement error correction and mitigation strategies  </li> <li>Machine Learning: Integrate ML models for automated calibration</li> <li>Real Hardware: Transition from simulation to actual quantum devices</li> <li>Large-Scale Systems: Scale to many-qubit experiments and algorithms</li> </ol>"},{"location":"tutorial/#learning-resources","title":"Learning Resources","text":"<ul> <li>User Guide: Core concepts and architecture</li> <li>Experiments Guide: Available experiment types  </li> <li>Calibrations Guide: Calibration procedures</li> <li>API Documentation: Complete technical documentation</li> <li>Community Forums: Q&amp;A and discussion with experts</li> <li>Research Papers: Scientific background on implemented techniques</li> </ul>"},{"location":"tutorial/#contributing-to-leeq","title":"Contributing to LeeQ","text":"<p>LeeQ is an open framework that benefits from community contributions:</p> <ol> <li>Report Issues: Help improve LeeQ by reporting bugs or requesting features</li> <li>Contribute Code: Add new experiments, pulse shapes, or analysis tools</li> <li>Share Notebooks: Create tutorials and examples for others to learn from</li> <li>Documentation: Help improve guides and API documentation</li> </ol>"},{"location":"tutorial/#final-tips-for-success","title":"Final Tips for Success","text":"<ol> <li>Start Simple: Begin with basic experiments before attempting complex protocols</li> <li>Understand the Physics: Strong quantum mechanics knowledge aids troubleshooting</li> <li>Calibrate Carefully: Good calibration is essential for meaningful results</li> <li>Validate Results: Always sanity-check your experimental outcomes</li> <li>Keep Learning: Quantum computing is rapidly evolving - stay updated!</li> </ol> <p>Welcome to the LeeQ community! We're excited to see what you'll build with this powerful quantum experiment orchestration framework.</p>"},{"location":"two_tone_spectroscopy/","title":"Two-Tone Qubit Spectroscopy","text":""},{"location":"two_tone_spectroscopy/#overview","title":"Overview","text":"<p>Two-tone spectroscopy is an advanced characterization technique that simultaneously applies two frequency-swept tones to a quantum system. This technique is essential for probing:</p> <ul> <li>Multi-photon transitions: Identifying higher-order excitation pathways</li> <li>Sideband effects: Characterizing modulation-induced sidebands</li> <li>Qubit-resonator coupling: Measuring dispersive shifts and coupling strengths</li> <li>AC Stark shifts: Quantifying power-dependent frequency shifts</li> <li>Cross-Kerr interactions: Studying inter-qubit coupling effects</li> </ul>"},{"location":"two_tone_spectroscopy/#physics-background","title":"Physics Background","text":"<p>In two-tone spectroscopy, the system Hamiltonian includes two driving terms:</p> <pre><code>H = H_0 + \u03a9\u2081(t)cos(\u03c9\u2081t)\u03c3_x^(1) + \u03a9\u2082(t)cos(\u03c9\u2082t)\u03c3_x^(2)\n</code></pre> <p>Where: - <code>H_0</code> is the unperturbed system Hamiltonian - <code>\u03a9\u2081,\u2082</code> are the drive amplitudes - <code>\u03c9\u2081,\u2082</code> are the drive frequencies - <code>\u03c3_x^(1,2)</code> are the Pauli operators (may act on same or different transitions)</p> <p>The two tones can interact through various mechanisms: 1. Direct multi-photon processes: \u03c9\u2081 + \u03c9\u2082 = \u03c9_transition 2. Parametric processes: \u03c9\u2081 - \u03c9\u2082 = \u03c9_modulation 3. Cross-Kerr effects: Simultaneous excitation modifies transition frequencies</p>"},{"location":"two_tone_spectroscopy/#usage","title":"Usage","text":""},{"location":"two_tone_spectroscopy/#basic-two-tone-spectroscopy","title":"Basic Two-Tone Spectroscopy","text":"<pre><code>from leeq.experiments.builtin.basic.calibrations.two_tone_spectroscopy import TwoToneQubitSpectroscopy\n\n# Run two-tone spectroscopy with different channels\nexp = TwoToneQubitSpectroscopy(\n    dut_qubit=qubit,\n    tone1_start=4950.0,  # MHz\n    tone1_stop=5050.0,   # MHz\n    tone1_step=2.0,      # MHz\n    tone1_amp=0.1,       # Drive amplitude\n    tone2_start=4750.0,  # MHz\n    tone2_stop=4850.0,   # MHz\n    tone2_step=2.0,      # MHz\n    tone2_amp=0.1,       # Drive amplitude\n    same_channel=False,  # Use different channels\n    num_avs=1000,        # Number of averages\n    mp_width=1.0         # Measurement pulse width (\u03bcs)\n)\n\n# Results are automatically plotted\n# Access data programmatically\nmagnitude = exp.result['Magnitude']\nphase = exp.result['Phase']\n</code></pre>"},{"location":"two_tone_spectroscopy/#same-channel-mode","title":"Same Channel Mode","text":"<p>For superimposed tones on the same drive channel:</p> <pre><code>exp = TwoToneQubitSpectroscopy(\n    dut_qubit=qubit,\n    tone1_start=4980.0,\n    tone1_stop=5020.0,\n    tone1_step=1.0,\n    tone2_start=5000.0,\n    tone2_stop=5040.0,\n    tone2_step=1.0,\n    same_channel=True,  # Superimpose on same channel\n    tone1_amp=0.05,\n    tone2_amp=0.05\n)\n</code></pre>"},{"location":"two_tone_spectroscopy/#analysis-methods","title":"Analysis Methods","text":""},{"location":"two_tone_spectroscopy/#peak-detection","title":"Peak Detection","text":"<pre><code>peaks = exp.find_peaks()\nprint(f\"Peak at Tone1: {peaks['peak_freq1']} MHz\")\nprint(f\"Peak at Tone2: {peaks['peak_freq2']} MHz\")\nprint(f\"Peak magnitude: {peaks['peak_magnitude']}\")\n</code></pre>"},{"location":"two_tone_spectroscopy/#cross-sections","title":"Cross-Sections","text":"<pre><code># Extract 1D slice at peak frequency\ncross_section = exp.get_cross_section(axis='freq1')\nfrequencies = cross_section['frequencies']\nmagnitude = cross_section['magnitude']\n\n# Or at specific frequency\ncross_section = exp.get_cross_section(axis='freq2', value=5000.0)\n</code></pre>"},{"location":"two_tone_spectroscopy/#parameters","title":"Parameters","text":""},{"location":"two_tone_spectroscopy/#required-parameters","title":"Required Parameters","text":"<ul> <li><code>dut_qubit</code>: TransmonElement to perform spectroscopy on</li> </ul>"},{"location":"two_tone_spectroscopy/#tone-1-parameters","title":"Tone 1 Parameters","text":"<ul> <li><code>tone1_start</code>: Start frequency in MHz (default: 4950.0)</li> <li><code>tone1_stop</code>: Stop frequency in MHz (default: 5050.0)</li> <li><code>tone1_step</code>: Frequency step size in MHz (default: 10.0)</li> <li><code>tone1_amp</code>: Drive amplitude (default: 0.1)</li> </ul>"},{"location":"two_tone_spectroscopy/#tone-2-parameters","title":"Tone 2 Parameters","text":"<ul> <li><code>tone2_start</code>: Start frequency in MHz (default: 4750.0)</li> <li><code>tone2_stop</code>: Stop frequency in MHz (default: 4850.0)</li> <li><code>tone2_step</code>: Frequency step size in MHz (default: 10.0)</li> <li><code>tone2_amp</code>: Drive amplitude (default: 0.1)</li> </ul>"},{"location":"two_tone_spectroscopy/#configuration-parameters","title":"Configuration Parameters","text":"<ul> <li><code>same_channel</code>: If True, both tones on same channel (default: False)</li> <li><code>num_avs</code>: Number of averages (default: 1000)</li> <li><code>rep_rate</code>: Repetition rate in Hz (default: 0.0)</li> <li><code>mp_width</code>: Measurement pulse width in \u03bcs (default: 1.0)</li> <li><code>set_qubit</code>: Transition for tone 1 ('f01' or 'f12', default: 'f01')</li> </ul>"},{"location":"two_tone_spectroscopy/#implementation-details","title":"Implementation Details","text":""},{"location":"two_tone_spectroscopy/#pulse-sequence","title":"Pulse Sequence","text":"<p>The experiment constructs a pulse sequence with two drive pulses applied in parallel:</p> <pre><code>lpb = (drive1 * drive2) + measurement\n</code></pre> <p>The <code>*</code> operator creates a <code>LogicalPrimitiveBlockParallel</code> ensuring simultaneous application.</p>"},{"location":"two_tone_spectroscopy/#sweep-engine","title":"Sweep Engine","text":"<p>The 2D frequency sweep uses chained sweepers:</p> <pre><code>swp = swp_freq1 + swp_freq2  # freq2 is inner loop\n</code></pre> <p>This creates an efficient nested sweep where: - Outer loop: tone1 frequency - Inner loop: tone2 frequency</p>"},{"location":"two_tone_spectroscopy/#simulation-mode","title":"Simulation Mode","text":"<p>In simulation mode, the experiment uses <code>CWSpectroscopySimulator</code> which: 1. Calculates dressed states for each drive configuration 2. Includes crosstalk effects between channels 3. Simulates realistic IQ responses 4. Adds shot noise scaled by <code>num_avs</code></p>"},{"location":"two_tone_spectroscopy/#visualization","title":"Visualization","text":"<p>The experiment automatically generates:</p> <ol> <li>Magnitude Heatmap: 2D plot of response magnitude vs both frequencies</li> <li>Phase Heatmap: Unwrapped phase response revealing dispersive effects</li> </ol> <p>Both plots are automatically displayed when the experiment completes.</p>"},{"location":"two_tone_spectroscopy/#advanced-applications","title":"Advanced Applications","text":""},{"location":"two_tone_spectroscopy/#identifying-multi-photon-transitions","title":"Identifying Multi-Photon Transitions","text":"<pre><code># Look for sum/difference frequency transitions\nexp = TwoToneQubitSpectroscopy(\n    dut_qubit=qubit,\n    tone1_start=2400.0,  # ~f01/2\n    tone1_stop=2600.0,\n    tone2_start=2400.0,  # ~f01/2\n    tone2_stop=2600.0,\n    same_channel=True\n)\n</code></pre>"},{"location":"two_tone_spectroscopy/#ac-stark-shift-measurement","title":"AC Stark Shift Measurement","text":"<pre><code># Fix one tone, sweep the other with varying power\nstark_shifts = []\nfor amp in [0.01, 0.05, 0.1, 0.2]:\n    exp = TwoToneQubitSpectroscopy(\n        dut_qubit=qubit,\n        tone1_start=5000.0,\n        tone1_stop=5000.0,  # Fixed frequency\n        tone1_step=10.0,\n        tone1_amp=amp,\n        tone2_start=4900.0,\n        tone2_stop=5100.0,\n        tone2_step=2.0,\n        tone2_amp=0.01  # Weak probe\n    )\n    peaks = exp.find_peaks()\n    stark_shifts.append(peaks['peak_freq2'])\n</code></pre>"},{"location":"two_tone_spectroscopy/#sideband-spectroscopy","title":"Sideband Spectroscopy","text":"<pre><code># Look for modulation sidebands\nmodulation_freq = 50.0  # MHz\nexp = TwoToneQubitSpectroscopy(\n    dut_qubit=qubit,\n    tone1_start=5000.0 - modulation_freq - 10,\n    tone1_stop=5000.0 - modulation_freq + 10,\n    tone2_start=5000.0 + modulation_freq - 10,\n    tone2_stop=5000.0 + modulation_freq + 10,\n    same_channel=False\n)\n</code></pre>"},{"location":"two_tone_spectroscopy/#troubleshooting","title":"Troubleshooting","text":""},{"location":"two_tone_spectroscopy/#no-clear-resonances","title":"No Clear Resonances","text":"<ul> <li>Increase <code>num_avs</code> for better SNR</li> <li>Reduce frequency step size for finer resolution</li> <li>Check amplitude levels - too low won't excite, too high causes power broadening</li> </ul>"},{"location":"two_tone_spectroscopy/#unexpected-peak-locations","title":"Unexpected Peak Locations","text":"<ul> <li>Verify qubit frequency calibration</li> <li>Check for AC Stark shifts at high power</li> <li>Consider crosstalk if using same channel</li> </ul>"},{"location":"two_tone_spectroscopy/#asymmetric-response","title":"Asymmetric Response","text":"<ul> <li>May indicate nonlinear effects</li> <li>Check for heating (reduce rep_rate)</li> <li>Verify measurement settings</li> </ul>"},{"location":"two_tone_spectroscopy/#related-experiments","title":"Related Experiments","text":"<ul> <li><code>QubitSpectroscopyFrequency</code>: Single-tone frequency sweep</li> <li><code>QubitSpectroscopyAmplitudeFrequency</code>: 2D amplitude-frequency sweep</li> <li><code>ResonatorSpectroscopy</code>: Cavity mode characterization</li> </ul>"},{"location":"two_tone_spectroscopy/#references","title":"References","text":"<ol> <li>Blais et al., \"Cavity quantum electrodynamics for superconducting electrical circuits\" (2004)</li> <li>Schuster et al., \"AC Stark shift and dephasing of a superconducting qubit\" (2005)</li> <li>Wallraff et al., \"Approaching unit visibility for control of a superconducting qubit\" (2005)</li> </ol>"},{"location":"api/compiler/base/","title":"Compiler Base Classes","text":"<p>::: leeq.compiler.base     options:       show_root_heading: true       show_source: true       heading_level: 2       members_order: source       show_signature_annotations: true       show_if_no_docstring: true       separate_signature: true</p>"},{"location":"api/compiler/lbnl_qubic/","title":"LBNL QubiC Compiler","text":"<p>::: leeq.compiler.lbnl_qubic     options:       show_root_heading: true       show_source: true       heading_level: 2       members_order: source       show_signature_annotations: true       show_if_no_docstring: true       separate_signature: true</p>"},{"location":"api/core/base/","title":"Core Base Classes","text":"<p>::: leeq.core.base     options:       show_root_heading: true       show_source: true       heading_level: 2       members_order: source       show_signature_annotations: true       show_if_no_docstring: true       separate_signature: true</p>"},{"location":"api/core/elements/","title":"Quantum Elements","text":"<p>::: leeq.core.elements     options:       show_root_heading: true       show_source: true       heading_level: 2       members_order: source       show_signature_annotations: true       show_if_no_docstring: true       separate_signature: true</p>"},{"location":"api/core/engine/","title":"Execution Engine","text":"<p>::: leeq.core.engine     options:       show_root_heading: true       show_source: true       heading_level: 2       members_order: source       show_signature_annotations: true       show_if_no_docstring: true       separate_signature: true</p>"},{"location":"api/core/primitives/","title":"Quantum Primitives","text":"<p>::: leeq.core.primitives     options:       show_root_heading: true       show_source: true       heading_level: 2       members_order: source       show_signature_annotations: true       show_if_no_docstring: true       separate_signature: true</p>"},{"location":"api/epii/experiments/","title":"EPII Experiment Router","text":"<p>::: leeq.epii.experiments     options:       show_root_heading: true       show_source: true       heading_level: 2       members_order: source       show_signature_annotations: true       show_if_no_docstring: true       separate_signature: true</p>"},{"location":"api/epii/overview/","title":"EPII v0.2.0 API Overview","text":"<p>The Experiment Programming Interface for Instruments (EPII) v0.2.0 provides a modern, backend-aware experiment discovery and execution system for LeeQ.</p>"},{"location":"api/epii/overview/#architecture-overview","title":"Architecture Overview","text":""},{"location":"api/epii/overview/#experimentrouter-class","title":"ExperimentRouter Class","text":"<p>The central component of EPII v0.2.0 is the <code>ExperimentRouter</code> class (<code>leeq.epii.experiments:17</code>), which provides:</p> <ul> <li>Dynamic Experiment Discovery: Automatically discovers experiments with <code>EPII_INFO</code> attributes</li> <li>Backend-Aware Filtering: Only exposes experiments compatible with current setup (simulation vs hardware)</li> <li>Canonical Naming: Uses module-qualified names instead of aliases (e.g., <code>calibrations.NormalisedRabi</code> instead of <code>rabi</code>)</li> </ul>"},{"location":"api/epii/overview/#key-features","title":"Key Features","text":""},{"location":"api/epii/overview/#1-dynamic-discovery-leeqepiiexperiments83-148","title":"1. Dynamic Discovery (<code>leeq.epii.experiments:83-148</code>)","text":"<pre><code>router = ExperimentRouter(setup=my_setup)\nexperiments = router.list_experiments()  # Returns all discovered experiments\n</code></pre> <p>The router scans all modules in <code>leeq.experiments.builtin</code> and automatically registers classes with: - <code>EPII_INFO</code> attribute (experiment metadata) - <code>run</code> method (execution capability) - Optional <code>run_simulated</code> method for simulation compatibility</p>"},{"location":"api/epii/overview/#2-backend-aware-operation-leeqepiiexperiments36-51","title":"2. Backend-Aware Operation (<code>leeq.epii.experiments:36-51</code>)","text":"<p>When initialized with a <code>HighLevelSimulationSetup</code>, the router: - Only includes experiments with <code>run_simulated</code> implementations (<code>leeq.epii.experiments:53-81</code>) - Filters out hardware-only experiments - Provides simulation-optimized experiment discovery</p>"},{"location":"api/epii/overview/#3-canonical-naming-system-leeqepiiexperiments114-138","title":"3. Canonical Naming System (<code>leeq.epii.experiments:114-138</code>)","text":"<p>Experiments are now referenced by their canonical module-qualified names: - <code>calibrations.NormalisedRabi</code> (was <code>rabi</code>) - <code>characterizations.SimpleT1</code> (was <code>t1</code>) - <code>calibrations.SimpleRamseyMultilevel</code> (was <code>ramsey</code>)</p>"},{"location":"api/epii/overview/#api-methods","title":"API Methods","text":""},{"location":"api/epii/overview/#core-router-methods","title":"Core Router Methods","text":"<ul> <li><code>get_experiment(name: str)</code> - Retrieve experiment class by canonical name (<code>leeq.epii.experiments:172-185</code>)</li> <li><code>list_experiments()</code> - Get all available experiments with descriptions (<code>leeq.epii.experiments:187-200</code>)</li> <li><code>get_experiment_info(name: str)</code> - Get detailed experiment metadata (<code>leeq.epii.experiments:150-170</code>)</li> </ul>"},{"location":"api/epii/overview/#backend-detection","title":"Backend Detection","text":"<ul> <li><code>_detect_simulation_setup()</code> - Identifies simulation vs hardware setup (<code>leeq.epii.experiments:36-51</code>)</li> <li><code>_has_own_run_simulated()</code> - Validates simulation compatibility (<code>leeq.epii.experiments:53-81</code>)</li> </ul>"},{"location":"api/epii/overview/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/epii/overview/#basic-usage","title":"Basic Usage","text":"<pre><code>from leeq.epii.experiments import ExperimentRouter\n\n# Initialize router with setup\nrouter = ExperimentRouter(setup=my_setup)\n\n# Get experiment class\nexperiment_class = router.get_experiment(\"calibrations.NormalisedRabi\")\n\n# List all available experiments\nexperiments = router.list_experiments()\n</code></pre>"},{"location":"api/epii/overview/#simulation-aware-usage","title":"Simulation-Aware Usage","text":"<pre><code># Router automatically filters for simulation-compatible experiments\nsim_router = ExperimentRouter(setup=simulation_setup)\nsim_experiments = sim_router.list_experiments()  # Only includes experiments with run_simulated\n</code></pre>"},{"location":"api/epii/overview/#migration-from-v01x","title":"Migration from v0.1.x","text":"<p>Breaking Changes: - All experiment aliases removed - Must use canonical names (module-qualified) - Backend-aware filtering may limit available experiments</p> <p>Migration Steps: 1. Replace all alias references with canonical names 2. Update configuration files and scripts 3. Test experiment discovery with your setup type</p>"},{"location":"api/epii/overview/#module-documentation","title":"Module Documentation","text":"<p>::: leeq.epii     options:       show_root_heading: true       show_source: true       heading_level: 2       members_order: source       show_signature_annotations: true       show_if_no_docstring: true       separate_signature: true</p>"},{"location":"api/epii/service/","title":"EPII gRPC Service","text":"<p>::: leeq.epii.service     options:       show_root_heading: true       show_source: true       heading_level: 2       members_order: source       show_signature_annotations: true       show_if_no_docstring: true       separate_signature: true</p>"},{"location":"api/experiments/base/","title":"Experiment Base Classes","text":"<p>::: leeq.experiments.base     options:       show_root_heading: true       show_source: true       heading_level: 2       members_order: source       show_signature_annotations: true       show_if_no_docstring: true       separate_signature: true</p>"},{"location":"api/experiments/builtin/","title":"Built-in Experiments","text":"<p>::: leeq.experiments.builtin     options:       show_root_heading: true       show_source: true       heading_level: 2       members_order: source       show_signature_annotations: true       show_if_no_docstring: true       separate_signature: true</p>"},{"location":"api/theory/clifford/","title":"Clifford Gates","text":"<p>::: leeq.theory.clifford     options:       show_root_heading: true       show_source: true       heading_level: 2       members_order: source       show_signature_annotations: true       show_if_no_docstring: true       separate_signature: true</p>"},{"location":"api/theory/fits/","title":"Fitting Functions","text":"<p>::: leeq.theory.fits     options:       show_root_heading: true       show_source: true       heading_level: 2       members_order: source       show_signature_annotations: true       show_if_no_docstring: true       separate_signature: true</p>"},{"location":"api/theory/simulation/","title":"Simulation","text":"<p>::: leeq.theory.simulation     options:       show_root_heading: true       show_source: true       heading_level: 2       members_order: source       show_signature_annotations: true       show_if_no_docstring: true       separate_signature: true</p>"},{"location":"api/theory/tomography/","title":"Tomography","text":"<p>::: leeq.theory.tomography     options:       show_root_heading: true       show_source: true       heading_level: 2       members_order: source       show_signature_annotations: true       show_if_no_docstring: true       separate_signature: true</p>"},{"location":"code_reference/config/","title":"leeq.config","text":"<p>::: leeq.config</p>"},{"location":"code_reference/compiler/compiler_base/","title":"leeq.compiler.compiler_base","text":"<p>::: leeq.compiler.compiler_base</p>"},{"location":"code_reference/compiler/full_sequencing_compiler/","title":"leeq.compiler.full_sequencing_compiler","text":"<p>::: leeq.compiler.full_sequencing_compiler</p>"},{"location":"code_reference/compiler/individual_lpb_compiler/","title":"leeq.compiler.individual_lpb_compiler","text":"<p>::: leeq.compiler.individual_lpb_compiler</p>"},{"location":"code_reference/compiler/lbnl_qubic/circuit_list_compiler/","title":"leeq.compiler.lbnl_qubic.circuit_list_compiler","text":"<p>::: leeq.compiler.lbnl_qubic.circuit_list_compiler</p>"},{"location":"code_reference/compiler/utils/pulse_shape_utils/","title":"leeq.compiler.utils.pulse_shape_utils","text":"<p>::: leeq.compiler.utils.pulse_shape_utils</p>"},{"location":"code_reference/compiler/utils/time_base/","title":"leeq.compiler.utils.time_base","text":"<p>::: leeq.compiler.utils.time_base</p>"},{"location":"code_reference/compiler/utils/pulse_shapes/basic_shapes/","title":"leeq.compiler.utils.pulse_shapes.basic_shapes","text":"<p>::: leeq.compiler.utils.pulse_shapes.basic_shapes</p>"},{"location":"code_reference/core/base/","title":"leeq.core.base","text":"<p>::: leeq.core.base</p>"},{"location":"code_reference/core/context/","title":"leeq.core.context","text":"<p>::: leeq.core.context</p>"},{"location":"code_reference/core/elements/elements/","title":"leeq.core.elements.elements","text":"<p>::: leeq.core.elements.elements</p>"},{"location":"code_reference/core/elements/built_in/qudit_transmon/","title":"leeq.core.elements.built_in.qudit_transmon","text":"<p>::: leeq.core.elements.built_in.qudit_transmon</p>"},{"location":"code_reference/core/engine/engine_base/","title":"leeq.core.engine.engine_base","text":"<p>::: leeq.core.engine.engine_base</p>"},{"location":"code_reference/core/engine/grid_sweep_engine/","title":"leeq.core.engine.grid_sweep_engine","text":"<p>::: leeq.core.engine.grid_sweep_engine</p>"},{"location":"code_reference/core/engine/measurement_result/","title":"leeq.core.engine.measurement_result","text":"<p>::: leeq.core.engine.measurement_result</p>"},{"location":"code_reference/core/primitives/base/","title":"leeq.core.primitives.base","text":"<p>::: leeq.core.primitives.base</p>"},{"location":"code_reference/core/primitives/collections/","title":"leeq.core.primitives.collections","text":"<p>::: leeq.core.primitives.collections</p>"},{"location":"code_reference/core/primitives/logical_primitives/","title":"leeq.core.primitives.logical_primitives","text":"<p>::: leeq.core.primitives.logical_primitives</p>"},{"location":"code_reference/core/primitives/built_in/common/","title":"leeq.core.primitives.built_in.common","text":"<p>::: leeq.core.primitives.built_in.common</p>"},{"location":"code_reference/core/primitives/built_in/compatibility/","title":"leeq.core.primitives.built_in.compatibility","text":"<p>::: leeq.core.primitives.built_in.compatibility</p>"},{"location":"code_reference/core/primitives/built_in/simple_drive/","title":"leeq.core.primitives.built_in.simple_drive","text":"<p>::: leeq.core.primitives.built_in.simple_drive</p>"},{"location":"code_reference/core/primitives/built_in/sizzel_gate/","title":"leeq.core.primitives.built_in.sizzel_gate","text":"<p>::: leeq.core.primitives.built_in.sizzel_gate</p>"},{"location":"code_reference/experiments/experiments/","title":"leeq.experiments.experiments","text":"<p>::: leeq.experiments.experiments</p>"},{"location":"code_reference/experiments/sweeper/","title":"leeq.experiments.sweeper","text":"<p>::: leeq.experiments.sweeper</p>"},{"location":"code_reference/experiments/plots/live_dash_app/","title":"leeq.experiments.plots.live_dash_app","text":"<p>::: leeq.experiments.plots.live_dash_app</p>"},{"location":"code_reference/integrations/pygsti/","title":"leeq.integrations.pygsti","text":"<p>::: leeq.integrations.pygsti</p>"},{"location":"code_reference/setups/qubic_lbnl_setups/","title":"leeq.setups.qubic_lbnl_setups","text":"<p>::: leeq.setups.qubic_lbnl_setups</p>"},{"location":"code_reference/setups/setup_base/","title":"leeq.setups.setup_base","text":"<p>::: leeq.setups.setup_base</p>"},{"location":"code_reference/setups/built_in/setup_numpy_2q_virtual_device/","title":"leeq.setups.built_in.setup_numpy_2q_virtual_device","text":"<p>::: leeq.setups.built_in.setup_numpy_2q_virtual_device</p>"},{"location":"code_reference/setups/built_in/setup_qutip_2q_local/","title":"leeq.setups.built_in.setup_qutip_2q_local","text":"<p>::: leeq.setups.built_in.setup_qutip_2q_local</p>"},{"location":"code_reference/setups/built_in/setup_simulation_high_level/","title":"leeq.setups.built_in.setup_simulation_high_level","text":"<p>::: leeq.setups.built_in.setup_simulation_high_level</p>"},{"location":"code_reference/theory/cliffords/single_qubit_cliffords/","title":"leeq.theory.cliffords.single_qubit_cliffords","text":"<p>::: leeq.theory.cliffords.single_qubit_cliffords</p>"},{"location":"code_reference/theory/cliffords/two_qubit_cliffords/","title":"leeq.theory.cliffords.two_qubit_cliffords","text":"<p>::: leeq.theory.cliffords.two_qubit_cliffords</p>"},{"location":"code_reference/theory/fits/fit_exp/","title":"leeq.theory.fits.fit_exp","text":"<p>::: leeq.theory.fits.fit_exp</p>"},{"location":"code_reference/theory/simulation/numpy/rotated_frame_simulator/","title":"leeq.theory.simulation.numpy.rotated_frame_simulator","text":"<p>::: leeq.theory.simulation.numpy.rotated_frame_simulator</p>"},{"location":"code_reference/theory/simulation/numpy/dispersive_readout/simulator/","title":"leeq.theory.simulation.numpy.dispersive_readout.simulator","text":"<p>::: leeq.theory.simulation.numpy.dispersive_readout.simulator</p>"},{"location":"code_reference/theory/simulation/numpy/dispersive_readout/utils/","title":"leeq.theory.simulation.numpy.dispersive_readout.utils","text":"<p>::: leeq.theory.simulation.numpy.dispersive_readout.utils</p>"},{"location":"code_reference/theory/simulation/qutip/pulsed_simulator/","title":"leeq.theory.simulation.qutip.pulsed_simulator","text":"<p>::: leeq.theory.simulation.qutip.pulsed_simulator</p>"},{"location":"code_reference/utils/utils/","title":"leeq.utils.utils","text":"<p>::: leeq.utils.utils</p>"},{"location":"code_reference/utils/compatibility/prims/","title":"leeq.utils.compatibility.prims","text":"<p>::: leeq.utils.compatibility.prims</p>"},{"location":"development/architecture/","title":"Architecture Overview","text":"<p>This document provides an overview of LeeQ's architecture and design principles.</p>"},{"location":"development/architecture/#system-architecture","title":"System Architecture","text":"<p>LeeQ follows a modular, layered architecture designed for flexibility and extensibility:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         User Interface Layer            \u2502\n\u2502    (Experiments, Calibrations, API)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           Core Abstraction Layer        \u2502\n\u2502     (Elements, Primitives, Engine)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         Compiler &amp; Execution Layer      \u2502\n\u2502    (Pulse Compilation, Sequencing)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           Hardware Interface Layer      \u2502\n\u2502    (QubiC, Simulation, Virtual Device)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"development/architecture/#core-components","title":"Core Components","text":""},{"location":"development/architecture/#1-base-classes-leeqcorebase","title":"1. Base Classes (<code>leeq.core.base</code>)","text":"<p>All LeeQ objects inherit from <code>LeeQObject</code>, which provides: - Automatic persistence via leeq.chronicle (integrated module) - Parameter tracking and versioning - Serialization capabilities</p> <pre><code>class LeeQObject(LoggableObject):\n    \"\"\"Base class for all LeeQ components.\"\"\"\n    pass\n</code></pre>"},{"location":"development/architecture/#2-quantum-elements-leeqcoreelements","title":"2. Quantum Elements (<code>leeq.core.elements</code>)","text":"<p>Represents quantum systems: - Qubit: Basic qubit implementation - Transmon: Transmon-specific features - Resonator: Readout resonators - QuditTransmon: Multi-level transmon</p> <p>Elements maintain: - Calibration parameters - Gate definitions - Measurement configurations</p>"},{"location":"development/architecture/#3-primitives-leeqcoreprimitives","title":"3. Primitives (<code>leeq.core.primitives</code>)","text":"<p>Low-level operations: - Drive primitives: Gaussian, DRAG pulses - Measurement primitives: Dispersive readout - Gate primitives: Single and two-qubit gates - Collections: Primitive sequences</p>"},{"location":"development/architecture/#4-execution-engine-leeqcoreengine","title":"4. Execution Engine (<code>leeq.core.engine</code>)","text":"<p>Manages experiment execution: - Sweeper: Parameter sweep management - MeasurementManager: Data collection - BatchManager: Experiment batching - ResultProcessor: Data processing</p>"},{"location":"development/architecture/#5-compiler-leeqcompiler","title":"5. Compiler (<code>leeq.compiler</code>)","text":"<p>Translates high-level operations to hardware instructions: - PulseCompiler: Pulse shape generation - SequenceCompiler: Instruction sequencing - CalibrationManager: Parameter optimization</p>"},{"location":"development/architecture/#design-patterns","title":"Design Patterns","text":""},{"location":"development/architecture/#dependency-injection","title":"Dependency Injection","text":"<pre><code>class Experiment:\n    def __init__(self, setup, compiler=None):\n        self.setup = setup\n        self.compiler = compiler or setup.default_compiler\n</code></pre>"},{"location":"development/architecture/#factory-pattern","title":"Factory Pattern","text":"<pre><code>def create_experiment(experiment_type, **kwargs):\n    \"\"\"Factory for creating experiments.\"\"\"\n    if experiment_type == \"rabi\":\n        return RabiExperiment(**kwargs)\n    elif experiment_type == \"ramsey\":\n        return RamseyExperiment(**kwargs)\n</code></pre>"},{"location":"development/architecture/#strategy-pattern","title":"Strategy Pattern","text":"<p>Different backends implement the same interface:</p> <pre><code>class Backend(ABC):\n    @abstractmethod\n    def execute(self, circuit):\n        pass\n\nclass QubiCBackend(Backend):\n    def execute(self, circuit):\n        # QubiC-specific implementation\n        pass\n\nclass SimulationBackend(Backend):\n    def execute(self, circuit):\n        # Simulation implementation\n        pass\n</code></pre>"},{"location":"development/architecture/#data-flow","title":"Data Flow","text":"<pre><code>User Code\n    \u2502\n    \u251c\u2500\u2500&gt; Experiment Definition\n    \u2502         \u2502\n    \u2502         \u251c\u2500\u2500&gt; Parameter Sweeps\n    \u2502         \u2502\n    \u2502         \u2514\u2500\u2500&gt; Pulse Sequences\n    \u2502\n    \u251c\u2500\u2500&gt; Compilation\n    \u2502         \u2502\n    \u2502         \u251c\u2500\u2500&gt; Gate Decomposition\n    \u2502         \u2502\n    \u2502         \u2514\u2500\u2500&gt; Pulse Generation\n    \u2502\n    \u251c\u2500\u2500&gt; Execution\n    \u2502         \u2502\n    \u2502         \u251c\u2500\u2500&gt; Hardware Interface\n    \u2502         \u2502\n    \u2502         \u2514\u2500\u2500&gt; Data Collection\n    \u2502\n    \u2514\u2500\u2500&gt; Analysis\n              \u2502\n              \u251c\u2500\u2500&gt; Fitting\n              \u2502\n              \u2514\u2500\u2500&gt; Visualization\n</code></pre>"},{"location":"development/architecture/#module-organization","title":"Module Organization","text":""},{"location":"development/architecture/#core-modules","title":"Core Modules","text":"<pre><code>leeq/\n\u251c\u2500\u2500 core/\n\u2502   \u251c\u2500\u2500 base.py          # Base classes\n\u2502   \u251c\u2500\u2500 context.py       # Execution context\n\u2502   \u251c\u2500\u2500 elements/        # Quantum elements\n\u2502   \u251c\u2500\u2500 engine/          # Execution engine\n\u2502   \u2514\u2500\u2500 primitives/      # Low-level operations\n</code></pre>"},{"location":"development/architecture/#experiment-modules","title":"Experiment Modules","text":"<pre><code>experiments/\n\u251c\u2500\u2500 builtin/            # Standard experiments\n\u2502   \u251c\u2500\u2500 basic/         # Basic calibrations\n\u2502   \u251c\u2500\u2500 tomography/    # State/process tomography\n\u2502   \u2514\u2500\u2500 benchmarking/  # RB, XEB, etc.\n\u251c\u2500\u2500 sweeper.py         # Parameter sweeping\n\u2514\u2500\u2500 base.py            # Base experiment class\n</code></pre>"},{"location":"development/architecture/#theory-modules","title":"Theory Modules","text":"<pre><code>theory/\n\u251c\u2500\u2500 simulation/        # Simulation backends\n\u2502   \u251c\u2500\u2500 numpy/        # NumPy-based\n\u2502   \u2514\u2500\u2500 qutip/        # QuTiP integration\n\u251c\u2500\u2500 cliffords/        # Clifford operations\n\u2514\u2500\u2500 fits/             # Fitting routines\n</code></pre>"},{"location":"development/architecture/#extension-points","title":"Extension Points","text":""},{"location":"development/architecture/#adding-new-experiments","title":"Adding New Experiments","text":"<ol> <li>Inherit from <code>BaseExperiment</code></li> <li>Implement required methods</li> <li>Register with experiment factory</li> </ol> <pre><code>class CustomExperiment(BaseExperiment):\n    def build_sequence(self):\n        # Define pulse sequence\n        pass\n\n    def analyze_results(self, data):\n        # Process measurement data\n        pass\n</code></pre>"},{"location":"development/architecture/#adding-hardware-backends","title":"Adding Hardware Backends","text":"<ol> <li>Implement <code>Backend</code> interface</li> <li>Handle compilation specifics</li> <li>Provide execution method</li> </ol> <pre><code>class NewBackend(Backend):\n    def compile(self, circuit):\n        # Backend-specific compilation\n        pass\n\n    def execute(self, compiled_circuit):\n        # Execute on hardware\n        pass\n</code></pre>"},{"location":"development/architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"development/architecture/#caching","title":"Caching","text":"<ul> <li>Calibration parameters cached</li> <li>Compiled sequences cached</li> <li>Fitting results cached</li> </ul>"},{"location":"development/architecture/#parallelization","title":"Parallelization","text":"<ul> <li>Parallel sweep execution</li> <li>Batch compilation</li> <li>Concurrent data processing</li> </ul>"},{"location":"development/architecture/#memory-management","title":"Memory Management","text":"<ul> <li>Lazy loading of large datasets</li> <li>Streaming data processing</li> <li>Automatic cleanup of temporary data</li> </ul>"},{"location":"development/architecture/#configuration","title":"Configuration","text":""},{"location":"development/architecture/#environment-variables","title":"Environment Variables","text":"<pre><code>LEEQ_BACKEND=qubic         # Default backend\nLEEQ_CACHE_DIR=/tmp/leeq   # Cache directory\nLEEQ_LOG_LEVEL=INFO        # Logging level\n</code></pre>"},{"location":"development/architecture/#configuration-files","title":"Configuration Files","text":"<pre><code># leeq_config.yaml\nbackend:\n  type: qubic\n  host: localhost\n  port: 8080\n\ncompiler:\n  optimization_level: 2\n  cache_compiled: true\n\nexecution:\n  batch_size: 1000\n  timeout: 60\n</code></pre>"},{"location":"development/architecture/#error-handling","title":"Error Handling","text":""},{"location":"development/architecture/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>class LeeQError(Exception):\n    \"\"\"Base exception for LeeQ.\"\"\"\n    pass\n\nclass CalibrationError(LeeQError):\n    \"\"\"Calibration-related errors.\"\"\"\n    pass\n\nclass CompilationError(LeeQError):\n    \"\"\"Compilation errors.\"\"\"\n    pass\n\nclass ExecutionError(LeeQError):\n    \"\"\"Execution errors.\"\"\"\n    pass\n</code></pre>"},{"location":"development/architecture/#error-recovery","title":"Error Recovery","text":"<ul> <li>Automatic retry on transient failures</li> <li>Fallback to simulation on hardware errors</li> <li>Graceful degradation of functionality</li> </ul>"},{"location":"development/architecture/#future-directions","title":"Future Directions","text":""},{"location":"development/architecture/#planned-features","title":"Planned Features","text":"<ol> <li>Distributed Execution: Multi-node experiment execution</li> <li>Real-time Calibration: Adaptive calibration during experiments</li> <li>ML Integration: Machine learning for calibration optimization</li> <li>Cloud Support: Cloud-based backends and storage</li> </ol>"},{"location":"development/architecture/#api-stability","title":"API Stability","text":"<ul> <li>Core API stable (v1.0+)</li> <li>Experimental features marked clearly</li> <li>Deprecation warnings for breaking changes</li> <li>Migration guides for major updates</li> </ul>"},{"location":"development/contributing/","title":"Contributing to LeeQ","text":"<p>Thank you for your interest in contributing to LeeQ! This document provides guidelines and instructions for contributing to the project.</p>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":""},{"location":"development/contributing/#development-setup","title":"Development Setup","text":"<ol> <li>Fork the repository on GitHub</li> <li> <p>Clone your fork locally:    <pre><code>git clone https://github.com/your-username/LeeQ.git\ncd LeeQ\n</code></pre></p> </li> <li> <p>Create a virtual environment:    <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n</code></pre></p> </li> <li> <p>Install in development mode:    <pre><code>pip install -e .\npip install -r requirements-dev.txt\n</code></pre></p> </li> </ol>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#creating-a-feature-branch","title":"Creating a Feature Branch","text":"<pre><code>git checkout -b feature/your-feature-name\n</code></pre>"},{"location":"development/contributing/#making-changes","title":"Making Changes","text":"<ol> <li>Write your code following the project style guide</li> <li>Add tests for new functionality</li> <li>Update documentation as needed</li> <li>Run tests locally before committing</li> </ol>"},{"location":"development/contributing/#testing-your-changes","title":"Testing Your Changes","text":"<pre><code># Run all tests\npytest\n\n# Run specific test file\npytest tests/path/to/test_file.py\n\n# Run with coverage\npytest --cov=leeq\n</code></pre>"},{"location":"development/contributing/#code-style","title":"Code Style","text":"<p>We use the following tools to maintain code quality:</p> <ul> <li>flake8 for linting</li> <li>black for formatting (optional)</li> <li>mypy for type checking (where applicable)</li> </ul> <p>Run linting checks: <pre><code>bash ./ci_scripts/lint.sh\n</code></pre></p>"},{"location":"development/contributing/#submitting-changes","title":"Submitting Changes","text":""},{"location":"development/contributing/#commit-messages","title":"Commit Messages","text":"<p>Follow conventional commit format: - <code>feat:</code> New feature - <code>fix:</code> Bug fix - <code>docs:</code> Documentation changes - <code>test:</code> Test additions or changes - <code>refactor:</code> Code refactoring - <code>style:</code> Code style changes</p> <p>Example: <pre><code>git commit -m \"feat: add new calibration experiment for XY gate\"\n</code></pre></p>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Push your branch to your fork</li> <li>Create a pull request against the main repository</li> <li>Fill out the PR template with:</li> <li>Description of changes</li> <li>Related issues</li> <li>Testing performed</li> <li>Wait for review and address feedback</li> </ol>"},{"location":"development/contributing/#code-guidelines","title":"Code Guidelines","text":""},{"location":"development/contributing/#python-style","title":"Python Style","text":"<ul> <li>Follow PEP 8</li> <li>Use descriptive variable names</li> <li>Add type hints where beneficial</li> <li>Document all public functions with numpy-style docstrings</li> </ul>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<ul> <li>Update relevant documentation for any API changes</li> <li>Add docstrings to new classes and functions</li> <li>Include usage examples where appropriate</li> </ul>"},{"location":"development/contributing/#testing","title":"Testing","text":"<ul> <li>Write unit tests for new functionality</li> <li>Ensure all tests pass before submitting PR</li> <li>Aim for good test coverage</li> <li>Include integration tests for complex features</li> </ul>"},{"location":"development/contributing/#project-structure","title":"Project Structure","text":"<pre><code>leeq/\n\u251c\u2500\u2500 core/           # Core functionality\n\u251c\u2500\u2500 experiments/    # Experiment implementations\n\u251c\u2500\u2500 theory/         # Theoretical simulations\n\u251c\u2500\u2500 compiler/       # Hardware compilation\n\u251c\u2500\u2500 setups/         # Hardware setups\n\u2514\u2500\u2500 utils/          # Utility functions\n\ntests/\n\u251c\u2500\u2500 unit/          # Unit tests\n\u2514\u2500\u2500 integration/   # Integration tests\n\ndocs/              # Documentation source\n</code></pre>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Open an issue for bugs or feature requests</li> <li>Join discussions in existing issues</li> <li>Reach out to maintainers for guidance</li> </ul>"},{"location":"development/contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the project's MIT License.</p>"},{"location":"development/testing/","title":"Testing Guide","text":"<p>This guide covers testing practices and procedures for LeeQ development.</p>"},{"location":"development/testing/#test-structure","title":"Test Structure","text":"<p>LeeQ uses pytest for testing, with tests organized as follows:</p> <pre><code>tests/\n\u251c\u2500\u2500 unit/                  # Unit tests for individual components\n\u2502   \u251c\u2500\u2500 core/             # Core module tests\n\u2502   \u251c\u2500\u2500 experiments/      # Experiment tests\n\u2502   \u2514\u2500\u2500 utils/            # Utility tests\n\u251c\u2500\u2500 integration/          # Integration tests\n\u2514\u2500\u2500 fixtures/            # Shared test fixtures\n</code></pre>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":""},{"location":"development/testing/#basic-test-execution","title":"Basic Test Execution","text":"<pre><code># Run all tests\npytest\n\n# Run with verbose output\npytest -v\n\n# Run specific test file\npytest tests/unit/core/test_elements.py\n\n# Run specific test\npytest tests/unit/core/test_elements.py::test_qubit_initialization\n</code></pre>"},{"location":"development/testing/#test-coverage","title":"Test Coverage","text":"<pre><code># Run with coverage report\npytest --cov=leeq\n\n# Generate HTML coverage report\npytest --cov=leeq --cov-report=html\n\n# View coverage report\nopen htmlcov/index.html\n</code></pre>"},{"location":"development/testing/#test-categories","title":"Test Categories","text":"<pre><code># Run only unit tests\npytest tests/unit/\n\n# Run only integration tests\npytest tests/integration/\n\n# Run tests matching pattern\npytest -k \"rabi\"\n</code></pre>"},{"location":"development/testing/#writing-tests","title":"Writing Tests","text":""},{"location":"development/testing/#unit-test-example","title":"Unit Test Example","text":"<pre><code>import pytest\nfrom leeq.core.elements import Qubit\n\ndef test_qubit_frequency():\n    \"\"\"Test qubit frequency setting.\"\"\"\n    qubit = Qubit(name=\"q0\")\n    qubit.set_frequency(5.0e9)\n    assert qubit.frequency == 5.0e9\n\ndef test_qubit_invalid_frequency():\n    \"\"\"Test invalid frequency raises error.\"\"\"\n    qubit = Qubit(name=\"q0\")\n    with pytest.raises(ValueError):\n        qubit.set_frequency(-1.0)\n</code></pre>"},{"location":"development/testing/#integration-test-example","title":"Integration Test Example","text":"<pre><code>import pytest\nfrom leeq.experiments import RabiExperiment\nfrom leeq.setups import create_virtual_setup\n\n@pytest.fixture\ndef virtual_setup():\n    \"\"\"Create virtual setup for testing.\"\"\"\n    return create_virtual_setup(num_qubits=2)\n\ndef test_rabi_experiment_workflow(virtual_setup):\n    \"\"\"Test complete Rabi experiment workflow.\"\"\"\n    qubit = virtual_setup.get_qubit(0)\n\n    experiment = RabiExperiment(\n        qubit=qubit,\n        amplitude_range=(0, 1),\n        num_points=20\n    )\n\n    result = experiment.run()\n    assert result.success\n    assert result.optimal_amplitude is not None\n</code></pre>"},{"location":"development/testing/#test-fixtures","title":"Test Fixtures","text":""},{"location":"development/testing/#common-fixtures","title":"Common Fixtures","text":"<p>Located in <code>tests/fixtures/</code>:</p> <pre><code># conftest.py\nimport pytest\nfrom leeq.core.elements import Qubit\n\n@pytest.fixture\ndef sample_qubit():\n    \"\"\"Provide a sample qubit for testing.\"\"\"\n    return Qubit(\n        name=\"test_qubit\",\n        frequency=5.0e9,\n        anharmonicity=-200e6\n    )\n\n@pytest.fixture\ndef mock_hardware():\n    \"\"\"Mock hardware interface.\"\"\"\n    from unittest.mock import Mock\n    hardware = Mock()\n    hardware.execute.return_value = {\"success\": True}\n    return hardware\n</code></pre>"},{"location":"development/testing/#mocking-and-patching","title":"Mocking and Patching","text":""},{"location":"development/testing/#mocking-hardware","title":"Mocking Hardware","text":"<pre><code>from unittest.mock import patch, Mock\n\n@patch('leeq.hardware.quantum_device')\ndef test_with_mock_hardware(mock_device):\n    \"\"\"Test with mocked hardware.\"\"\"\n    mock_device.execute.return_value = {\n        \"counts\": {\"0\": 500, \"1\": 500}\n    }\n\n    # Your test code here\n    result = run_experiment()\n    assert mock_device.execute.called\n</code></pre>"},{"location":"development/testing/#test-best-practices","title":"Test Best Practices","text":""},{"location":"development/testing/#1-test-organization","title":"1. Test Organization","text":"<ul> <li>One test file per module</li> <li>Group related tests in classes</li> <li>Use descriptive test names</li> </ul>"},{"location":"development/testing/#2-test-independence","title":"2. Test Independence","text":"<ul> <li>Tests should not depend on each other</li> <li>Clean up resources after tests</li> <li>Use fixtures for shared setup</li> </ul>"},{"location":"development/testing/#3-assertions","title":"3. Assertions","text":"<ul> <li>Use specific assertions</li> <li>Test both success and failure cases</li> <li>Include edge cases</li> </ul>"},{"location":"development/testing/#4-documentation","title":"4. Documentation","text":"<ul> <li>Add docstrings to test functions</li> <li>Explain complex test scenarios</li> <li>Document expected behaviors</li> </ul>"},{"location":"development/testing/#continuous-integration","title":"Continuous Integration","text":"<p>Tests run automatically on: - Pull requests - Commits to main branch - Nightly builds</p>"},{"location":"development/testing/#environment-setup-for-ci","title":"Environment Setup for CI","text":"<p>Critical environment variables for headless testing:</p> <pre><code>export MPLBACKEND=Agg\nexport PYTHONDONTWRITEBYTECODE=1\nexport QT_QPA_PLATFORM=offscreen\n</code></pre>"},{"location":"development/testing/#current-ci-configuration","title":"Current CI Configuration","text":"<p>The project uses GitHub Actions with configurations in <code>.github/workflows/</code>.</p>"},{"location":"development/testing/#performance-testing","title":"Performance Testing","text":""},{"location":"development/testing/#benchmarking","title":"Benchmarking","text":"<pre><code>import pytest\nimport time\n\n@pytest.mark.benchmark\ndef test_performance():\n    \"\"\"Benchmark critical operations.\"\"\"\n    start = time.time()\n\n    # Operation to benchmark\n    result = expensive_operation()\n\n    duration = time.time() - start\n    assert duration &lt; 1.0  # Should complete in under 1 second\n</code></pre>"},{"location":"development/testing/#debugging-tests","title":"Debugging Tests","text":""},{"location":"development/testing/#running-with-debugger","title":"Running with debugger","text":"<pre><code># Run with pdb on failure\npytest --pdb\n\n# Run with verbose traceback\npytest --tb=long\n\n# Run with print statements visible\npytest -s\n</code></pre>"},{"location":"development/testing/#using-pytest-markers","title":"Using pytest markers","text":"<pre><code>@pytest.mark.slow\ndef test_slow_operation():\n    \"\"\"Mark slow tests.\"\"\"\n    pass\n\n# Run excluding slow tests\npytest -m \"not slow\"\n</code></pre>"},{"location":"development/testing/#test-data","title":"Test Data","text":"<p>Store test data in <code>tests/data/</code>: - Sample configuration files - Expected output files - Mock response data</p> <pre><code>import os\nimport json\n\ndef test_with_data():\n    \"\"\"Test using external data file.\"\"\"\n    data_path = os.path.join(\n        os.path.dirname(__file__),\n        \"data\",\n        \"sample_results.json\"\n    )\n\n    with open(data_path) as f:\n        expected = json.load(f)\n\n    result = process_data()\n    assert result == expected\n</code></pre>"},{"location":"development/troubleshooting/","title":"Troubleshooting Guide","text":""},{"location":"development/troubleshooting/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"development/troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"development/troubleshooting/#problem-git-based-dependencies-fail-to-install","title":"Problem: Git-based dependencies fail to install","text":"<p>Solution: Ensure you have git installed and accessible from your command line. For GitHub dependencies, you may need to configure SSH keys or use HTTPS URLs.</p>"},{"location":"development/troubleshooting/#problem-labchronicle-module-not-found","title":"Problem: LabChronicle module not found","text":"<p>Solution: As of the latest version, LabChronicle is now integrated as <code>leeq.chronicle</code>. Update your imports: <pre><code># Old\nfrom labchronicle import LoggableObject\n\n# New\nfrom leeq.chronicle import LoggableObject\n</code></pre></p>"},{"location":"development/troubleshooting/#runtime-issues","title":"Runtime Issues","text":""},{"location":"development/troubleshooting/#problem-epii-daemon-connection-refused","title":"Problem: EPII daemon connection refused","text":"<p>Solution:  1. Check if the EPII daemon is running: <code>systemctl status epii-daemon</code> 2. Verify the port is not blocked by firewall 3. Check the daemon logs: <code>journalctl -u epii-daemon -f</code></p>"},{"location":"development/troubleshooting/#problem-experiment-execution-timeout","title":"Problem: Experiment execution timeout","text":"<p>Solution: 1. Increase timeout in experiment configuration 2. Check if hardware connections are stable 3. Verify that measurement devices are responsive</p>"},{"location":"development/troubleshooting/#import-errors","title":"Import Errors","text":""},{"location":"development/troubleshooting/#problem-circular-import-detected","title":"Problem: Circular import detected","text":"<p>Solution:  1. Use lazy imports where possible 2. Move shared utilities to a common module 3. Refactor to reduce module interdependencies</p>"},{"location":"development/troubleshooting/#problem-type-hints-cause-import-errors","title":"Problem: Type hints cause import errors","text":"<p>Solution: Use <code>TYPE_CHECKING</code> for forward references: <pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from leeq.core.elements import TransmonElement\n</code></pre></p>"},{"location":"development/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"development/troubleshooting/#problem-slow-experiment-execution","title":"Problem: Slow experiment execution","text":"<p>Solution: 1. Enable parallel execution where possible 2. Optimize sweep parameters 3. Use batch operations for multiple qubits 4. Check network latency to hardware</p>"},{"location":"development/troubleshooting/#problem-high-memory-usage","title":"Problem: High memory usage","text":"<p>Solution: 1. Limit data retention in Chronicle logger 2. Clear experiment results after processing 3. Use generators for large data sequences</p>"},{"location":"development/troubleshooting/#data-issues","title":"Data Issues","text":""},{"location":"development/troubleshooting/#problem-chronicle-log-files-growing-too-large","title":"Problem: Chronicle log files growing too large","text":"<p>Solution: 1. Set <code>LAB_CHRONICLE_LOG_DIR</code> to a disk with sufficient space 2. Implement log rotation 3. Clean old log files periodically</p>"},{"location":"development/troubleshooting/#problem-experiment-results-not-saved","title":"Problem: Experiment results not saved","text":"<p>Solution: 1. Verify Chronicle is properly initialized 2. Check file permissions in log directory 3. Ensure decorators are properly applied</p>"},{"location":"development/troubleshooting/#debug-tips","title":"Debug Tips","text":""},{"location":"development/troubleshooting/#enable-verbose-logging","title":"Enable Verbose Logging","text":"<pre><code>from leeq.utils import setup_logging\nlogger = setup_logging(__name__, level='DEBUG')\n</code></pre>"},{"location":"development/troubleshooting/#check-leeq-version","title":"Check LeeQ Version","text":"<pre><code>import leeq\nprint(leeq.__version__)\n</code></pre>"},{"location":"development/troubleshooting/#verify-hardware-connection","title":"Verify Hardware Connection","text":"<pre><code>from leeq import setup\nsetup.status()  # Check all connections\n</code></pre>"},{"location":"development/troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you encounter issues not covered here:</p> <ol> <li>Check the GitHub Issues</li> <li>Review the API Documentation</li> <li>Contact the development team</li> </ol>"},{"location":"development/troubleshooting/#see-also","title":"See Also","text":"<ul> <li>Installation Guide</li> <li>Experiments Guide</li> <li>EPII Troubleshooting</li> </ul>"},{"location":"epii/","title":"LeeQ EPII Documentation","text":"<p>EPII (Experiment Platform Intelligence Interface) is a gRPC service that provides standardized access to LeeQ quantum experiment capabilities. This documentation covers deployment, usage, and troubleshooting of the EPII service.</p>"},{"location":"epii/#quick-start","title":"Quick Start","text":""},{"location":"epii/#installation","title":"Installation","text":"<pre><code># Run the installation script\nsudo ./scripts/install-epii.sh --config simulation_2q\n\n# Or manually deploy following the deployment guide\n</code></pre>"},{"location":"epii/#basic-usage","title":"Basic Usage","text":"<pre><code>import grpc\nfrom leeq.epii.proto import epii_pb2, epii_pb2_grpc\n\n# Connect and run experiment\nchannel = grpc.insecure_channel('localhost:50051')\nstub = epii_pb2_grpc.ExperimentPlatformServiceStub(channel)\nresponse = stub.Ping(epii_pb2.PingRequest())\nprint(f\"Service: {response.message}\")\n</code></pre>"},{"location":"epii/#documentation","title":"Documentation","text":""},{"location":"epii/#deployment-administration","title":"Deployment &amp; Administration","text":"<ul> <li>Deployment Guide - Complete deployment instructions for production environments</li> <li>Operations Guide - Comprehensive production operations and maintenance guide</li> <li>Deployment Checklist - Step-by-step production deployment validation</li> <li>Configuration Examples - Ready-to-use configuration files for different setups</li> <li>Systemd Service - Service templates and installation scripts</li> </ul>"},{"location":"epii/#development-usage","title":"Development &amp; Usage","text":"<ul> <li>Client Usage Guide - Comprehensive guide for gRPC client development</li> <li>Example Clients - Working example applications and usage patterns</li> <li>API Reference - Complete gRPC protocol documentation (if available)</li> </ul>"},{"location":"epii/#operations-support","title":"Operations &amp; Support","text":"<ul> <li>Troubleshooting Guide - Common issues and solutions</li> <li>Monitoring &amp; Logging - Service monitoring setup</li> <li>Security Considerations - Production security guidelines</li> </ul>"},{"location":"epii/#configuration-templates","title":"Configuration Templates","text":""},{"location":"epii/#available-configurations","title":"Available Configurations","text":"<ul> <li><code>simulation_2q.json</code> - 2-qubit simulation setup for development and testing</li> <li><code>hardware_lab1.json</code> - Hardware setup template for production quantum devices  </li> <li><code>minimal.json</code> - Minimal configuration for basic testing</li> </ul>"},{"location":"epii/#configuration-structure","title":"Configuration Structure","text":"<pre><code>{\n  \"setup_type\": \"simulation|hardware\",\n  \"setup_class\": \"HighLevelSimulationSetup|QubicLBNLSetup\",\n  \"config\": { /* Setup-specific configuration */ },\n  \"grpc\": {\n    \"port\": 50051,\n    \"max_workers\": 10,\n    \"max_message_length\": 104857600\n  },\n  \"logging\": {\n    \"level\": \"INFO\",\n    \"file\": \"/var/log/leeq/epii.log\"\n  },\n  \"experiment_timeout\": 300,\n  \"parameter_validation\": true\n}\n</code></pre>"},{"location":"epii/#supported-experiments","title":"Supported Experiments","text":"<p>EPII supports the following quantum experiments:</p>"},{"location":"epii/#single-qubit-experiments","title":"Single-Qubit Experiments","text":"<ul> <li>Rabi - Calibrate pulse amplitudes and measure Rabi frequency</li> <li>T1 - Measure qubit relaxation time</li> <li>Ramsey - Measure dephasing time (T2*) and frequency detuning</li> <li>Echo - Measure coherence time (T2) with echo sequences</li> </ul>"},{"location":"epii/#advanced-experiments","title":"Advanced Experiments","text":"<ul> <li>DRAG - Optimize pulse shapes to reduce leakage</li> <li>Randomized Benchmarking - Measure average gate fidelity</li> </ul>"},{"location":"epii/#multi-qubit-experiments-future","title":"Multi-Qubit Experiments (Future)","text":"<ul> <li>Two-qubit gate calibration</li> <li>Process tomography</li> <li>Quantum error correction protocols</li> </ul>"},{"location":"epii/#service-management","title":"Service Management","text":""},{"location":"epii/#systemd-commands","title":"Systemd Commands","text":"<pre><code># Start service\nsudo systemctl start leeq-epii@&lt;config&gt;\n\n# Check status  \nsudo systemctl status leeq-epii@&lt;config&gt;\n\n# View logs\nsudo journalctl -u leeq-epii@&lt;config&gt; -f\n\n# Multiple configurations\nsudo systemctl start leeq-epii@simulation_2q\nsudo systemctl start leeq-epii@hardware_lab1\n</code></pre>"},{"location":"epii/#health-checks","title":"Health Checks","text":"<pre><code># Test gRPC endpoint\ngrpcurl -plaintext localhost:50051 list\ngrpcurl -plaintext localhost:50051 ExperimentPlatformService/Ping\n\n# Check process status\nps aux | grep leeq-epii\n</code></pre>"},{"location":"epii/#development-examples","title":"Development Examples","text":""},{"location":"epii/#simple-experiment","title":"Simple Experiment","text":"<pre><code># Run a Rabi experiment\nrequest = epii_pb2.ExperimentRequest(\n    experiment_name=\"rabi\",\n    parameters={\n        \"qubit\": \"q0\",\n        \"amplitudes\": serialize_array(np.linspace(0, 1, 21)),\n        \"num_shots\": \"1000\"\n    }\n)\nresponse = stub.RunExperiment(request)\ndata = deserialize_array(response.data)\n</code></pre>"},{"location":"epii/#parameter-management","title":"Parameter Management","text":"<pre><code># Get parameter\nrequest = epii_pb2.ParameterRequest(name=\"q0.frequency\")\nresponse = stub.GetParameter(request)\n\n# Set parameter\nrequest = epii_pb2.SetParameterRequest(name=\"q0.frequency\", value=\"5.1e9\")\nresponse = stub.SetParameter(request)\n</code></pre>"},{"location":"epii/#architecture-overview","title":"Architecture Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    gRPC     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Client Apps   \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502  EPII Service   \u2502\n\u2502                 \u2502             \u2502                 \u2502\n\u2502 - Lab Software  \u2502             \u2502 - Experiment    \u2502\n\u2502 - Jupyter       \u2502             \u2502   Router        \u2502\n\u2502 - Automation    \u2502             \u2502 - Parameter     \u2502\n\u2502 - External APIs \u2502             \u2502   Manager       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2502 - Serialization \u2502\n                                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                         \u2502\n                                         \u25bc\n                                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                \u2502   LeeQ Core     \u2502\n                                \u2502                 \u2502\n                                \u2502 - Experiments   \u2502\n                                \u2502 - Setups        \u2502\n                                \u2502 - Hardware      \u2502\n                                \u2502 - Simulation    \u2502\n                                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"epii/#support-community","title":"Support &amp; Community","text":""},{"location":"epii/#getting-help","title":"Getting Help","text":"<ul> <li>Issues: Report bugs and request features on GitHub Issues</li> <li>Documentation: Check the troubleshooting guide for common problems</li> <li>Support: Contact the development team for enterprise support</li> </ul>"},{"location":"epii/#contributing","title":"Contributing","text":"<ul> <li>Follow the contribution guidelines in the main LeeQ repository</li> <li>Add tests for new experiment types and features</li> <li>Update documentation for any API changes</li> </ul>"},{"location":"epii/#license","title":"License","text":"<p>LeeQ EPII is part of the LeeQ project and follows the same licensing terms.</p>"},{"location":"epii/#version-information","title":"Version Information","text":"<ul> <li>EPII Protocol Version: 1.0</li> <li>Supported LeeQ Version: Latest (check requirements.txt)</li> <li>Python Version: 3.8+</li> <li>gRPC Version: See requirements.txt</li> </ul>"},{"location":"epii/#migration-upgrades","title":"Migration &amp; Upgrades","text":""},{"location":"epii/#from-direct-leeq-usage","title":"From Direct LeeQ Usage","text":"<p>If migrating from direct LeeQ experiment scripts: 1. Review the Client Usage Guide for equivalent patterns 2. Use the example clients as templates 3. Consider the standardized parameter naming in EPII</p>"},{"location":"epii/#service-upgrades","title":"Service Upgrades","text":"<p>Follow the upgrade procedures in the Deployment Guide for safe service updates.</p>"},{"location":"epii/client-usage/","title":"EPII gRPC Client Usage Guide","text":"<p>This guide demonstrates how to use the LeeQ EPII service from client applications using gRPC.</p>"},{"location":"epii/client-usage/#quick-start","title":"Quick Start","text":""},{"location":"epii/client-usage/#python-client-setup","title":"Python Client Setup","text":"<pre><code>import grpc\nfrom leeq.epii.proto import epii_pb2, epii_pb2_grpc\nimport numpy as np\n\n# Connect to EPII service\nchannel = grpc.insecure_channel('localhost:50051')\nstub = epii_pb2_grpc.ExperimentPlatformServiceStub(channel)\n\n# Test connection\nresponse = stub.Ping(epii_pb2.PingRequest())\nprint(f\"Service online: {response.message}\")\n</code></pre>"},{"location":"epii/client-usage/#basic-experiment-execution","title":"Basic Experiment Execution","text":"<pre><code># Prepare experiment request\nrequest = epii_pb2.ExperimentRequest(\n    experiment_name=\"rabi\",\n    parameters={\n        \"qubit\": \"q0\",\n        \"amplitudes\": serialize_array(np.linspace(0, 1, 21)),\n        \"num_shots\": 1000\n    }\n)\n\n# Run experiment\nresponse = stub.RunExperiment(request)\n\n# Deserialize results\ndata = deserialize_array(response.data)\nfit_params = dict(response.fit_params)\nprint(f\"Rabi frequency: {fit_params.get('frequency', 'N/A')}\")\n</code></pre>"},{"location":"epii/client-usage/#common-usage-patterns","title":"Common Usage Patterns","text":""},{"location":"epii/client-usage/#1-parameter-management","title":"1. Parameter Management","text":""},{"location":"epii/client-usage/#get-parameters","title":"Get Parameters","text":"<pre><code># Get single parameter\nrequest = epii_pb2.ParameterRequest(name=\"q0.frequency\")\nresponse = stub.GetParameter(request)\nfrequency = response.value\n\n# List all parameters\nresponse = stub.ListParameters(epii_pb2.Empty())\nfor param in response.parameters:\n    print(f\"{param.name}: {param.value} ({param.type})\")\n</code></pre>"},{"location":"epii/client-usage/#set-parameters","title":"Set Parameters","text":"<pre><code># Set qubit frequency\nrequest = epii_pb2.SetParameterRequest(\n    name=\"q0.frequency\",\n    value=\"5.1e9\"\n)\nresponse = stub.SetParameter(request)\nif response.success:\n    print(\"Parameter updated successfully\")\n</code></pre>"},{"location":"epii/client-usage/#2-experiment-workflows","title":"2. Experiment Workflows","text":""},{"location":"epii/client-usage/#rabi-experiment","title":"Rabi Experiment","text":"<pre><code>def run_rabi_experiment(qubit, amplitudes, num_shots=1000):\n    \"\"\"Run a Rabi experiment and return results.\"\"\"\n    request = epii_pb2.ExperimentRequest(\n        experiment_name=\"rabi\",\n        parameters={\n            \"qubit\": qubit,\n            \"amplitudes\": serialize_array(np.array(amplitudes)),\n            \"num_shots\": str(num_shots)\n        }\n    )\n\n    try:\n        response = stub.RunExperiment(request)\n        return {\n            \"data\": deserialize_array(response.data),\n            \"fit_params\": dict(response.fit_params),\n            \"success\": True\n        }\n    except grpc.RpcError as e:\n        return {\n            \"error\": str(e),\n            \"success\": False\n        }\n\n# Usage\nresult = run_rabi_experiment(\"q0\", np.linspace(0, 1, 21))\nif result[\"success\"]:\n    print(f\"Pi pulse amplitude: {result['fit_params'].get('pi_amplitude')}\")\n</code></pre>"},{"location":"epii/client-usage/#t1-measurement","title":"T1 Measurement","text":"<pre><code>def measure_t1(qubit, delays, num_shots=1000):\n    \"\"\"Measure T1 relaxation time.\"\"\"\n    request = epii_pb2.ExperimentRequest(\n        experiment_name=\"t1\",\n        parameters={\n            \"qubit\": qubit,\n            \"delays\": serialize_array(np.array(delays)),\n            \"num_shots\": str(num_shots)\n        }\n    )\n\n    response = stub.RunExperiment(request)\n    return {\n        \"delays\": delays,\n        \"populations\": deserialize_array(response.data),\n        \"t1\": float(response.fit_params.get(\"t1\", 0))\n    }\n\n# Usage\ndelays = np.logspace(-6, -3, 20)  # 1\u03bcs to 1ms\nresult = measure_t1(\"q0\", delays)\nprint(f\"T1 = {result['t1']*1e6:.1f} \u03bcs\")\n</code></pre>"},{"location":"epii/client-usage/#ramsey-experiment","title":"Ramsey Experiment","text":"<pre><code>def run_ramsey(qubit, delays, detuning=0, num_shots=1000):\n    \"\"\"Run Ramsey experiment to measure T2*.\"\"\"\n    request = epii_pb2.ExperimentRequest(\n        experiment_name=\"ramsey\",\n        parameters={\n            \"qubit\": qubit,\n            \"delays\": serialize_array(np.array(delays)),\n            \"detuning\": str(detuning),\n            \"num_shots\": str(num_shots)\n        }\n    )\n\n    response = stub.RunExperiment(request)\n    return {\n        \"delays\": delays,\n        \"populations\": deserialize_array(response.data),\n        \"t2_star\": float(response.fit_params.get(\"t2_star\", 0)),\n        \"frequency\": float(response.fit_params.get(\"frequency\", 0))\n    }\n</code></pre>"},{"location":"epii/client-usage/#3-advanced-patterns","title":"3. Advanced Patterns","text":""},{"location":"epii/client-usage/#calibration-sequence","title":"Calibration Sequence","text":"<pre><code>def full_qubit_calibration(qubit):\n    \"\"\"Perform complete qubit calibration sequence.\"\"\"\n    results = {}\n\n    # 1. Rabi calibration\n    print(\"Running Rabi calibration...\")\n    rabi_result = run_rabi_experiment(qubit, np.linspace(0, 1, 51))\n    results[\"rabi\"] = rabi_result\n\n    # 2. Update pi pulse amplitude\n    if rabi_result[\"success\"]:\n        pi_amp = rabi_result[\"fit_params\"].get(\"pi_amplitude\")\n        if pi_amp:\n            set_request = epii_pb2.SetParameterRequest(\n                name=f\"{qubit}.pi_amplitude\",\n                value=str(pi_amp)\n            )\n            stub.SetParameter(set_request)\n\n    # 3. T1 measurement\n    print(\"Measuring T1...\")\n    delays = np.logspace(-6, -3, 30)\n    results[\"t1\"] = measure_t1(qubit, delays)\n\n    # 4. Ramsey for T2*\n    print(\"Measuring T2*...\")\n    delays = np.linspace(0, 50e-6, 51)\n    results[\"ramsey\"] = run_ramsey(qubit, delays)\n\n    return results\n</code></pre>"},{"location":"epii/client-usage/#error-handling","title":"Error Handling","text":"<pre><code>def robust_experiment_runner(experiment_func, max_retries=3):\n    \"\"\"Run experiment with automatic retry on failure.\"\"\"\n    for attempt in range(max_retries):\n        try:\n            return experiment_func()\n        except grpc.RpcError as e:\n            if e.code() == grpc.StatusCode.DEADLINE_EXCEEDED:\n                print(f\"Experiment timeout, attempt {attempt + 1}/{max_retries}\")\n                if attempt == max_retries - 1:\n                    raise\n            elif e.code() == grpc.StatusCode.UNAVAILABLE:\n                print(f\"Service unavailable, attempt {attempt + 1}/{max_retries}\")\n                time.sleep(2 ** attempt)  # Exponential backoff\n                if attempt == max_retries - 1:\n                    raise\n            else:\n                raise  # Don't retry other errors\n</code></pre>"},{"location":"epii/client-usage/#4-asynchronous-operations","title":"4. Asynchronous Operations","text":""},{"location":"epii/client-usage/#async-client","title":"Async Client","text":"<pre><code>import asyncio\nimport grpc.aio\n\nasync def async_experiment_client():\n    \"\"\"Example of asynchronous experiment execution.\"\"\"\n    async with grpc.aio.insecure_channel('localhost:50051') as channel:\n        stub = epii_pb2_grpc.ExperimentPlatformServiceStub(channel)\n\n        # Run multiple experiments concurrently\n        tasks = []\n        for qubit in [\"q0\", \"q1\"]:\n            request = epii_pb2.ExperimentRequest(\n                experiment_name=\"t1\",\n                parameters={\n                    \"qubit\": qubit,\n                    \"delays\": serialize_array(np.logspace(-6, -3, 20)),\n                    \"num_shots\": \"1000\"\n                }\n            )\n            task = stub.RunExperiment(request)\n            tasks.append(task)\n\n        # Wait for all experiments to complete\n        results = await asyncio.gather(*tasks)\n\n        for i, result in enumerate(results):\n            t1 = float(result.fit_params.get(\"t1\", 0))\n            print(f\"q{i} T1 = {t1*1e6:.1f} \u03bcs\")\n\n# Run async client\nasyncio.run(async_experiment_client())\n</code></pre>"},{"location":"epii/client-usage/#utility-functions","title":"Utility Functions","text":""},{"location":"epii/client-usage/#data-serialization","title":"Data Serialization","text":"<pre><code>def serialize_array(array):\n    \"\"\"Convert NumPy array to protobuf bytes.\"\"\"\n    return array.astype(np.float64).tobytes()\n\ndef deserialize_array(data, shape=None):\n    \"\"\"Convert protobuf bytes back to NumPy array.\"\"\"\n    array = np.frombuffer(data, dtype=np.float64)\n    if shape:\n        array = array.reshape(shape)\n    return array\n\ndef serialize_complex_array(array):\n    \"\"\"Serialize complex array as interleaved real/imag.\"\"\"\n    complex_array = array.astype(np.complex128)\n    real_imag = np.empty(complex_array.size * 2, dtype=np.float64)\n    real_imag[0::2] = complex_array.real\n    real_imag[1::2] = complex_array.imag\n    return real_imag.tobytes()\n\ndef deserialize_complex_array(data):\n    \"\"\"Deserialize complex array from interleaved real/imag.\"\"\"\n    real_imag = np.frombuffer(data, dtype=np.float64)\n    complex_array = real_imag[0::2] + 1j * real_imag[1::2]\n    return complex_array\n</code></pre>"},{"location":"epii/client-usage/#connection-management","title":"Connection Management","text":"<pre><code>class EPIIClient:\n    \"\"\"Managed EPII client with connection pooling.\"\"\"\n\n    def __init__(self, address='localhost:50051', timeout=60):\n        self.address = address\n        self.timeout = timeout\n        self.channel = None\n        self.stub = None\n\n    def __enter__(self):\n        self.connect()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.disconnect()\n\n    def connect(self):\n        \"\"\"Establish connection to EPII service.\"\"\"\n        self.channel = grpc.insecure_channel(self.address)\n        self.stub = epii_pb2_grpc.ExperimentPlatformServiceStub(self.channel)\n\n        # Test connection\n        try:\n            self.stub.Ping(epii_pb2.PingRequest(), timeout=5)\n        except grpc.RpcError:\n            raise ConnectionError(f\"Cannot connect to EPII service at {self.address}\")\n\n    def disconnect(self):\n        \"\"\"Close connection.\"\"\"\n        if self.channel:\n            self.channel.close()\n\n# Usage\nwith EPIIClient() as client:\n    result = client.stub.RunExperiment(request)\n</code></pre>"},{"location":"epii/client-usage/#configuration-examples","title":"Configuration Examples","text":""},{"location":"epii/client-usage/#client-configuration","title":"Client Configuration","text":"<pre><code># config.py\nEPII_CONFIG = {\n    \"address\": \"localhost:50051\",\n    \"timeout\": 300,  # 5 minutes\n    \"retry_attempts\": 3,\n    \"retry_delay\": 1.0,\n    \"compression\": grpc.Compression.Gzip\n}\n\n# client.py\ndef create_channel(config):\n    \"\"\"Create gRPC channel with configuration.\"\"\"\n    options = [\n        ('grpc.keepalive_time_ms', 30000),\n        ('grpc.keepalive_timeout_ms', 5000),\n        ('grpc.keepalive_permit_without_calls', True),\n        ('grpc.http2.max_pings_without_data', 0),\n        ('grpc.http2.min_time_between_pings_ms', 10000),\n        ('grpc.http2.min_ping_interval_without_data_ms', 300000)\n    ]\n\n    if config.get(\"compression\"):\n        return grpc.insecure_channel(\n            config[\"address\"], \n            options=options,\n            compression=config[\"compression\"]\n        )\n    else:\n        return grpc.insecure_channel(config[\"address\"], options=options)\n</code></pre>"},{"location":"epii/client-usage/#best-practices","title":"Best Practices","text":"<ol> <li>Connection Management: Use context managers or connection pooling</li> <li>Error Handling: Always wrap gRPC calls in try-catch blocks</li> <li>Timeouts: Set appropriate timeouts for long-running experiments</li> <li>Data Serialization: Use provided utility functions for NumPy arrays</li> <li>Parameter Validation: Validate parameters client-side when possible</li> <li>Logging: Log all experiment requests and responses for debugging</li> <li>Concurrency: Use async clients for parallel experiment execution</li> <li>Resource Cleanup: Always close channels and clean up resources</li> </ol>"},{"location":"epii/client-usage/#see-also","title":"See Also","text":"<ul> <li>EPII Protocol Documentation</li> <li>Troubleshooting Guide</li> <li>Deployment Guide</li> </ul>"},{"location":"epii/deployment-guide/","title":"LeeQ EPII Deployment Guide","text":"<p>This guide covers deploying the LeeQ EPII (Experiment Platform Intelligence Interface) service in production environments.</p>"},{"location":"epii/deployment-guide/#prerequisites","title":"Prerequisites","text":""},{"location":"epii/deployment-guide/#system-requirements","title":"System Requirements","text":"<ul> <li>Linux server (Ubuntu 20.04+ or CentOS 8+ recommended)</li> <li>Python 3.8+ with virtual environment support</li> <li>systemd for service management</li> <li>Minimum 4GB RAM, 8GB recommended for hardware setups</li> <li>Network access to quantum hardware (for hardware configurations)</li> </ul>"},{"location":"epii/deployment-guide/#user-setup","title":"User Setup","text":"<p>Create a dedicated user for running the EPII service:</p> <pre><code>sudo useradd -r -s /bin/bash -d /opt/leeq leeq\nsudo mkdir -p /opt/leeq /var/log/leeq /var/lib/leeq /etc/leeq/configs/epii\nsudo chown -R leeq:leeq /opt/leeq /var/log/leeq /var/lib/leeq\nsudo chown -R leeq:leeq /etc/leeq\n</code></pre>"},{"location":"epii/deployment-guide/#installation","title":"Installation","text":""},{"location":"epii/deployment-guide/#1-install-leeq-epii","title":"1. Install LeeQ EPII","text":"<pre><code># Clone the repository\ncd /opt/leeq\nsudo -u leeq git clone https://github.com/ShuxiangCao/LeeQ.git .\n\n# Create virtual environment\nsudo -u leeq python3 -m venv venv\nsudo -u leeq ./venv/bin/pip install --upgrade pip\n\n# Install dependencies\nsudo -u leeq ./venv/bin/pip install -r requirements.txt\nsudo -u leeq ./venv/bin/pip install -e .\n</code></pre>"},{"location":"epii/deployment-guide/#2-configure-the-service","title":"2. Configure the Service","text":"<pre><code># Copy configuration files\nsudo cp configs/epii/*.json /etc/leeq/configs/epii/\n\n# Edit configuration for your environment\nsudo -u leeq nano /etc/leeq/configs/epii/production.json\n</code></pre>"},{"location":"epii/deployment-guide/#3-install-systemd-service","title":"3. Install systemd Service","text":"<pre><code># Copy service template\nsudo cp scripts/systemd/leeq-epii@.service /etc/systemd/system/\n\n# Reload systemd\nsudo systemctl daemon-reload\n\n# Enable and start the service\nsudo systemctl enable leeq-epii@production\nsudo systemctl start leeq-epii@production\n</code></pre>"},{"location":"epii/deployment-guide/#configuration","title":"Configuration","text":""},{"location":"epii/deployment-guide/#configuration-file-structure","title":"Configuration File Structure","text":"<pre><code>{\n  \"setup_type\": \"simulation|hardware\",\n  \"setup_class\": \"HighLevelSimulationSetup|QubicLBNLSetup\",\n  \"config\": {\n    // Setup-specific configuration\n  },\n  \"grpc\": {\n    \"port\": 50051,\n    \"max_workers\": 10,\n    \"max_message_length\": 104857600\n  },\n  \"logging\": {\n    \"level\": \"INFO|WARNING|ERROR\",\n    \"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    \"file\": \"/var/log/leeq/epii.log\"\n  },\n  \"experiment_timeout\": 300,\n  \"parameter_validation\": true\n}\n</code></pre>"},{"location":"epii/deployment-guide/#configuration-templates","title":"Configuration Templates","text":""},{"location":"epii/deployment-guide/#simulation-setup","title":"Simulation Setup","text":"<p>Use <code>simulation_2q.json</code> for development and testing with simulated qubits.</p>"},{"location":"epii/deployment-guide/#hardware-setup","title":"Hardware Setup","text":"<p>Use <code>hardware_lab1.json</code> as a template for real quantum hardware deployments.</p>"},{"location":"epii/deployment-guide/#minimal-setup","title":"Minimal Setup","text":"<p>Use <code>minimal.json</code> for basic testing and validation.</p>"},{"location":"epii/deployment-guide/#service-management","title":"Service Management","text":""},{"location":"epii/deployment-guide/#basic-commands","title":"Basic Commands","text":"<pre><code># Start service\nsudo systemctl start leeq-epii@&lt;config-name&gt;\n\n# Stop service\nsudo systemctl stop leeq-epii@&lt;config-name&gt;\n\n# Restart service\nsudo systemctl restart leeq-epii@&lt;config-name&gt;\n\n# Check status\nsudo systemctl status leeq-epii@&lt;config-name&gt;\n\n# View logs\nsudo journalctl -u leeq-epii@&lt;config-name&gt; -f\n</code></pre>"},{"location":"epii/deployment-guide/#multiple-configurations","title":"Multiple Configurations","text":"<p>You can run multiple EPII instances with different configurations:</p> <pre><code># Start simulation instance\nsudo systemctl start leeq-epii@simulation_2q\n\n# Start hardware instance\nsudo systemctl start leeq-epii@hardware_lab1\n\n# Check all running instances\nsudo systemctl list-units \"leeq-epii@*\"\n</code></pre>"},{"location":"epii/deployment-guide/#security-considerations","title":"Security Considerations","text":""},{"location":"epii/deployment-guide/#network-security","title":"Network Security","text":"<ul> <li>Configure firewall to restrict access to gRPC port (default 50051)</li> <li>Use TLS/SSL for production deployments</li> <li>Consider VPN access for remote clients</li> </ul>"},{"location":"epii/deployment-guide/#system-security","title":"System Security","text":"<p>The systemd service includes security hardening: - Runs with restricted user privileges - Isolated temporary directories - Protected system directories - Resource limits to prevent abuse</p>"},{"location":"epii/deployment-guide/#configuration-security","title":"Configuration Security","text":"<ul> <li>Store sensitive configuration in <code>/etc/leeq/configs/</code> with restricted permissions</li> <li>Use environment variables for secrets when possible</li> <li>Regularly rotate any embedded credentials</li> </ul>"},{"location":"epii/deployment-guide/#monitoring-and-logging","title":"Monitoring and Logging","text":""},{"location":"epii/deployment-guide/#log-files","title":"Log Files","text":"<ul> <li>Service logs: <code>journalctl -u leeq-epii@&lt;config&gt;</code></li> <li>Application logs: <code>/var/log/leeq/epii.log</code> (if configured)</li> <li>System logs: <code>/var/log/syslog</code></li> </ul>"},{"location":"epii/deployment-guide/#health-checks","title":"Health Checks","text":"<pre><code># Check service status\nsudo systemctl status leeq-epii@&lt;config&gt;\n\n# Test gRPC endpoint\ngrpcurl -plaintext localhost:50051 list\n\n# Check process resources\nps aux | grep leeq-epii\n</code></pre>"},{"location":"epii/deployment-guide/#performance-monitoring","title":"Performance Monitoring","text":"<ul> <li>Monitor memory usage with <code>htop</code> or <code>systemd-cgtop</code></li> <li>Track gRPC request metrics in application logs</li> <li>Use <code>netstat</code> to monitor network connections</li> </ul>"},{"location":"epii/deployment-guide/#backup-and-recovery","title":"Backup and Recovery","text":""},{"location":"epii/deployment-guide/#configuration-backup","title":"Configuration Backup","text":"<pre><code># Backup configurations\nsudo tar -czf leeq-config-backup-$(date +%Y%m%d).tar.gz /etc/leeq/\n\n# Backup application\nsudo tar -czf leeq-app-backup-$(date +%Y%m%d).tar.gz /opt/leeq/\n</code></pre>"},{"location":"epii/deployment-guide/#disaster-recovery","title":"Disaster Recovery","text":"<ol> <li>Reinstall system packages</li> <li>Restore application from backup</li> <li>Restore configurations</li> <li>Restart services</li> <li>Validate functionality with test experiments</li> </ol>"},{"location":"epii/deployment-guide/#upgrades","title":"Upgrades","text":""},{"location":"epii/deployment-guide/#application-upgrades","title":"Application Upgrades","text":"<pre><code># Stop service\nsudo systemctl stop leeq-epii@&lt;config&gt;\n\n# Backup current installation\nsudo cp -r /opt/leeq /opt/leeq.backup.$(date +%Y%m%d)\n\n# Update code\ncd /opt/leeq\nsudo -u leeq git pull origin main\nsudo -u leeq ./venv/bin/pip install --upgrade -r requirements.txt\n\n# Test configuration\nsudo -u leeq ./venv/bin/python -m leeq.epii.daemon --config /etc/leeq/configs/epii/&lt;config&gt;.json --validate\n\n# Restart service\nsudo systemctl start leeq-epii@&lt;config&gt;\n</code></pre>"},{"location":"epii/deployment-guide/#configuration-updates","title":"Configuration Updates","text":"<pre><code># Validate new configuration\nsudo -u leeq /opt/leeq/venv/bin/python -m leeq.epii.daemon --config /etc/leeq/configs/epii/new-config.json --validate\n\n# Reload service (for minor changes)\nsudo systemctl reload leeq-epii@&lt;config&gt;\n\n# Or restart for major changes\nsudo systemctl restart leeq-epii@&lt;config&gt;\n</code></pre>"},{"location":"epii/deployment-guide/#troubleshooting","title":"Troubleshooting","text":"<p>See the Troubleshooting Guide for common issues and solutions.</p>"},{"location":"epii/dynamic-discovery/","title":"Dynamic Experiment Discovery","text":""},{"location":"epii/dynamic-discovery/#overview","title":"Overview","text":"<p>The EPII system now features automatic discovery of all experiments that have <code>EPII_INFO</code> metadata defined. This eliminates the need to manually register experiments in the router.</p>"},{"location":"epii/dynamic-discovery/#how-it-works","title":"How It Works","text":"<ol> <li>Automatic Discovery: On startup, the <code>ExperimentRouter</code> automatically scans all LeeQ experiment modules</li> <li>EPII_INFO Detection: Any experiment class with an <code>EPII_INFO</code> attribute and a <code>run</code> method is automatically registered</li> <li>Categorized Naming: Experiments are organized by category (e.g., <code>calibrations.NormalisedRabi</code>, <code>characterizations.SimpleT1</code>)</li> <li>Backward Compatibility: Old simple names (e.g., <code>rabi</code>, <code>t1</code>) are maintained as aliases</li> </ol>"},{"location":"epii/dynamic-discovery/#adding-new-experiments","title":"Adding New Experiments","text":"<p>To make a new experiment available through EPII:</p> <ol> <li> <p>Add an <code>EPII_INFO</code> attribute to your experiment class: <pre><code>class MyNewExperiment(ExperimentBase):\n    EPII_INFO = {\n        'experiment': 'my_new_experiment',\n        'description': 'Description of what this experiment does',\n        'category': 'calibrations',  # or characterizations, etc.\n        'version': '1.0.0'\n    }\n\n    def run(self, ...):\n        \"\"\"Run the experiment.\"\"\"\n        pass\n</code></pre></p> </li> <li> <p>Place the experiment in the appropriate LeeQ module under <code>leeq.experiments.builtin</code></p> </li> <li> <p>The experiment will be automatically discovered and available through EPII with no additional configuration needed</p> </li> </ol>"},{"location":"epii/dynamic-discovery/#experiment-naming-convention","title":"Experiment Naming Convention","text":"<p>Experiments are named using a dot notation: - <code>category.ExperimentClassName</code> - Examples:   - <code>calibrations.NormalisedRabi</code>   - <code>characterizations.SimpleT1</code>   - <code>multi_qubit_gates.ConditionalStarkTuneUp</code>   - <code>tomography.SingleQubitStateTomography</code></p>"},{"location":"epii/dynamic-discovery/#available-categories","title":"Available Categories","text":"<ul> <li><code>calibrations</code>: Basic calibration experiments</li> <li><code>characterizations</code>: Qubit characterization experiments  </li> <li><code>multi_qubit_gates</code>: Multi-qubit gate experiments</li> <li><code>tomography</code>: State and process tomography</li> <li><code>hamiltonian_tomography</code>: Hamiltonian reconstruction</li> <li><code>optimal_control</code>: Optimal control experiments</li> </ul>"},{"location":"epii/dynamic-discovery/#listing-available-experiments","title":"Listing Available Experiments","text":"<pre><code>from leeq.epii.experiments import ExperimentRouter\n\nrouter = ExperimentRouter()\nexperiments = router.list_experiments()\nprint(f\"Found {len(experiments)} experiments\")\n\n# List by category\nfor name in sorted(experiments.keys()):\n    if name.startswith('calibrations.'):\n        print(f\"  - {name}\")\n</code></pre>"},{"location":"epii/dynamic-discovery/#metadata-access","title":"Metadata Access","text":"<p>Each experiment's metadata can be accessed:</p> <pre><code>router = ExperimentRouter()\ninfo = router.get_experiment_info('calibrations.NormalisedRabi')\nprint(info['epii_info'])  # EPII metadata\nprint(info['run_docstring'])  # Run method documentation\n</code></pre>"},{"location":"epii/overview/","title":"EPII v0.2.0 User Guide","text":"<p>The Experiment Programming Interface for Instruments (EPII) v0.2.0 is a major update that brings backend-aware experiment discovery, canonical naming, and improved integration capabilities to LeeQ.</p>"},{"location":"epii/overview/#whats-new-in-v020","title":"What's New in v0.2.0","text":""},{"location":"epii/overview/#key-features","title":"Key Features","text":"<ul> <li>Backend-Aware Discovery: Automatically filters experiments based on your setup type</li> <li>Canonical Naming: No more aliases - use full module-qualified experiment names</li> <li>Dynamic Discovery: Automatically finds all available experiments</li> <li>Enhanced Metadata: Rich experiment information with EPII_INFO</li> </ul>"},{"location":"epii/overview/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>All experiment aliases removed (<code>rabi</code>, <code>t1</code>, <code>ramsey</code>, etc.)</li> <li>Must use canonical names (<code>calibrations.NormalisedRabi</code>, <code>characterizations.SimpleT1</code>)</li> <li>Backend filtering may limit available experiments</li> </ul>"},{"location":"epii/overview/#getting-started","title":"Getting Started","text":""},{"location":"epii/overview/#basic-usage","title":"Basic Usage","text":"<pre><code>from leeq.epii.experiments import ExperimentRouter\n\n# Initialize with your setup\nrouter = ExperimentRouter(setup=my_setup)\n\n# Discover available experiments\nexperiments = router.list_experiments()\nprint(f\"Found {len(experiments)} experiments\")\n\n# Get a specific experiment\nexperiment_class = router.get_experiment(\"calibrations.NormalisedRabi\")\n</code></pre>"},{"location":"epii/overview/#backend-aware-operation","title":"Backend-Aware Operation","text":"<p>The router automatically detects your setup type and filters experiments accordingly:</p> <pre><code># With simulation setup - only shows experiments with run_simulated\nfrom leeq.setups.built_in.setup_simulation_high_level import HighLevelSimulationSetup\n\nsim_setup = HighLevelSimulationSetup()\nsim_router = ExperimentRouter(setup=sim_setup)\nsim_experiments = sim_router.list_experiments()  # Filtered for simulation compatibility\n\n# With hardware setup - shows all experiments\nhardware_router = ExperimentRouter(setup=hardware_setup)\nall_experiments = hardware_router.list_experiments()  # All experiments available\n</code></pre>"},{"location":"epii/overview/#experiment-naming","title":"Experiment Naming","text":""},{"location":"epii/overview/#canonical-names","title":"Canonical Names","text":"<p>All experiments now use module-qualified names that reflect their organization:</p> Category Example Calibrations <code>calibrations.NormalisedRabi</code>, <code>calibrations.DragCalibrationSingleQubitMultilevel</code> Characterizations <code>characterizations.SimpleT1</code>, <code>characterizations.SpinEchoMultiLevel</code> Multi-Qubit Gates <code>multi_qubit_gates.CrossResonanceCalibration</code> Tomography <code>tomography.StateTomography</code>, <code>tomography.ProcessTomography</code> Optimal Control <code>optimal_control.GrapeOptimization</code>"},{"location":"epii/overview/#finding-experiment-names","title":"Finding Experiment Names","text":"<pre><code># List all available experiments with descriptions\nexperiments = router.list_experiments()\nfor name, description in experiments.items():\n    print(f\"{name}: {description}\")\n\n# Get detailed information about an experiment\ninfo = router.get_experiment_info(\"calibrations.NormalisedRabi\")\nprint(info['epii_info'])  # Experiment metadata\nprint(info['run_docstring'])  # Run method documentation\n</code></pre>"},{"location":"epii/overview/#usage-patterns","title":"Usage Patterns","text":""},{"location":"epii/overview/#running-experiments","title":"Running Experiments","text":"<p>Follow LeeQ's constructor-based pattern - never call <code>run()</code> methods directly:</p> <pre><code># CORRECT: Pass all parameters to constructor\nexp = QubitSpectroscopyFrequency(\n    dut_qubit=qubit,\n    start=4900.0,\n    stop=5100.0, \n    step=2.0,\n    num_avs=1000\n)\n\n# INCORRECT: Never do this\nexp = QubitSpectroscopyFrequency()\nexp.run_simulated(...)  # WRONG!\n</code></pre>"},{"location":"epii/overview/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    experiment_class = router.get_experiment(\"calibrations.NormalisedRabi\")\n    if experiment_class:\n        exp = experiment_class(\n            dut_qubit=qubit,\n            amplitudes=np.linspace(0, 1, 51)\n        )\n    else:\n        print(\"Experiment not found or not compatible with current setup\")\nexcept Exception as e:\n    print(f\"Experiment failed: {e}\")\n</code></pre>"},{"location":"epii/overview/#checking-compatibility","title":"Checking Compatibility","text":"<pre><code># Check if an experiment is available (considers backend compatibility)\nif \"calibrations.NormalisedRabi\" in router.experiment_map:\n    print(\"Rabi experiment available\")\nelse:\n    print(\"Rabi experiment not available for this setup\")\n\n# Get experiment requirements\ninfo = router.get_experiment_info(\"calibrations.NormalisedRabi\")\nepii_info = info['epii_info']\nprint(f\"Description: {epii_info.get('description', 'N/A')}\")\nprint(f\"Parameters: {epii_info.get('parameters', {})}\")\n</code></pre>"},{"location":"epii/overview/#advanced-features","title":"Advanced Features","text":""},{"location":"epii/overview/#custom-experiment-discovery","title":"Custom Experiment Discovery","text":"<pre><code># Initialize without automatic discovery\nrouter = ExperimentRouter()\n\n# Manually discover experiments (useful for debugging)\nrouter._discover_experiments()\nprint(f\"Discovered {len(router.experiment_map)} experiments\")\n</code></pre>"},{"location":"epii/overview/#simulation-vs-hardware","title":"Simulation vs Hardware","text":"<pre><code># Check if router is in simulation mode\nif router.is_simulation:\n    print(\"Running in simulation mode\")\n    print(\"Only experiments with run_simulated method are available\")\nelse:\n    print(\"Running on hardware\")\n    print(\"All experiments available\")\n\n# List simulation capabilities\nfor name, exp_class in router.experiment_map.items():\n    has_sim = router._has_own_run_simulated(exp_class)\n    print(f\"{name}: {'\u2713' if has_sim else '\u2717'} simulation support\")\n</code></pre>"},{"location":"epii/overview/#integration-examples","title":"Integration Examples","text":""},{"location":"epii/overview/#with-chronicle-logging","title":"With Chronicle Logging","text":"<pre><code>from leeq.experiments.builtin.calibrations import NormalisedRabi\n\n# Experiments automatically integrate with Chronicle\nexp = NormalisedRabi(\n    dut_qubit=qubit,\n    amplitudes=np.linspace(0, 1, 51)\n)\n# Results automatically logged to Chronicle\n</code></pre>"},{"location":"epii/overview/#batch-experiment-execution","title":"Batch Experiment Execution","text":"<pre><code># Run multiple experiments in sequence\nexperiment_names = [\n    \"calibrations.NormalisedRabi\",\n    \"characterizations.SimpleT1\", \n    \"calibrations.SimpleRamseyMultilevel\"\n]\n\nresults = {}\nfor exp_name in experiment_names:\n    exp_class = router.get_experiment(exp_name)\n    if exp_class:\n        # Configure experiment based on type\n        if \"rabi\" in exp_name.lower():\n            exp = exp_class(dut_qubit=qubit, amplitudes=np.linspace(0, 1, 21))\n        elif \"t1\" in exp_name.lower():\n            exp = exp_class(dut_qubit=qubit, delays=np.logspace(-6, -3, 21))\n        # Store results\n        results[exp_name] = exp\n</code></pre>"},{"location":"epii/overview/#best-practices","title":"Best Practices","text":"<ol> <li>Always initialize router with your setup for proper backend filtering</li> <li>Use canonical names consistently throughout your code</li> <li>Check experiment availability before attempting to run</li> <li>Follow constructor-only pattern for experiment execution</li> <li>Handle errors gracefully with try/catch blocks</li> </ol>"},{"location":"epii/overview/#troubleshooting","title":"Troubleshooting","text":""},{"location":"epii/overview/#common-issues","title":"Common Issues","text":"<p>Experiment not found: <pre><code># Check available experiments\nexperiments = router.list_experiments()\nif \"my_experiment\" not in experiments:\n    print(\"Available experiments:\")\n    for name in experiments:\n        print(f\"  {name}\")\n</code></pre></p> <p>No experiments available: - Check if your setup is properly configured - Verify EPII_INFO attributes on custom experiments - For simulation: ensure experiments have <code>run_simulated</code> method</p> <p>Import errors: - Ensure all LeeQ dependencies are installed - Check that experiment modules are in Python path</p>"},{"location":"epii/overview/#api-reference","title":"API Reference","text":"<p>For detailed API documentation, see: - EPII API Overview - ExperimentRouter Reference - Service Integration</p>"},{"location":"epii/protocol/","title":"EPII Protocol Documentation","text":""},{"location":"epii/protocol/#overview","title":"Overview","text":"<p>The EPII (Experiment Python Interface and Infrastructure) protocol defines the communication interface between EPII clients and the EPII daemon service.</p>"},{"location":"epii/protocol/#protocol-version","title":"Protocol Version","text":"<p>Current protocol version: 1.0</p>"},{"location":"epii/protocol/#communication-model","title":"Communication Model","text":"<p>EPII uses a request-response model over TCP sockets with JSON-encoded messages.</p>"},{"location":"epii/protocol/#message-format","title":"Message Format","text":"<p>All messages are JSON objects with the following structure:</p> <pre><code>{\n    \"method\": \"method_name\",\n    \"params\": {...},\n    \"id\": \"unique_request_id\"\n}\n</code></pre>"},{"location":"epii/protocol/#response-format","title":"Response Format","text":"<pre><code>{\n    \"result\": {...},\n    \"error\": null,\n    \"id\": \"unique_request_id\"\n}\n</code></pre>"},{"location":"epii/protocol/#available-methods","title":"Available Methods","text":""},{"location":"epii/protocol/#core-methods","title":"Core Methods","text":"<ul> <li><code>list_experiments</code>: List available experiments</li> <li><code>run_experiment</code>: Execute an experiment</li> <li><code>get_experiment_status</code>: Check experiment status</li> <li><code>cancel_experiment</code>: Cancel a running experiment</li> </ul>"},{"location":"epii/protocol/#parameter-methods","title":"Parameter Methods","text":"<ul> <li><code>list_parameters</code>: List available parameters</li> <li><code>get_parameter</code>: Get parameter value</li> <li><code>set_parameter</code>: Set parameter value</li> </ul>"},{"location":"epii/protocol/#capability-methods","title":"Capability Methods","text":"<ul> <li><code>get_capabilities</code>: Get service capabilities</li> <li><code>get_version</code>: Get protocol version</li> </ul>"},{"location":"epii/protocol/#error-handling","title":"Error Handling","text":"<p>Errors are returned in the response with an error object:</p> <pre><code>{\n    \"error\": {\n        \"code\": -32000,\n        \"message\": \"Error description\",\n        \"data\": {...}\n    }\n}\n</code></pre>"},{"location":"epii/protocol/#examples","title":"Examples","text":""},{"location":"epii/protocol/#list-experiments-request","title":"List Experiments Request","text":"<pre><code>{\n    \"method\": \"list_experiments\",\n    \"params\": {},\n    \"id\": \"req-001\"\n}\n</code></pre>"},{"location":"epii/protocol/#run-experiment-request","title":"Run Experiment Request","text":"<pre><code>{\n    \"method\": \"run_experiment\",\n    \"params\": {\n        \"experiment\": \"PowerRabi\",\n        \"kwargs\": {\n            \"qubit\": 0,\n            \"amplitude_range\": [0, 1],\n            \"num_points\": 51\n        }\n    },\n    \"id\": \"req-002\"\n}\n</code></pre>"},{"location":"epii/protocol/#see-also","title":"See Also","text":"<ul> <li>EPII Client Usage</li> <li>EPII README</li> </ul>"},{"location":"epii/quick-reference/","title":"EPII v0.2.0 Quick Reference","text":""},{"location":"epii/quick-reference/#alias-to-canonical-name-mapping","title":"Alias to Canonical Name Mapping","text":"Old Alias Canonical Name Description <code>rabi</code> <code>calibrations.NormalisedRabi</code> Rabi oscillation amplitude calibration <code>t1</code> <code>characterizations.SimpleT1</code> T1 relaxation time measurement <code>ramsey</code> <code>calibrations.SimpleRamseyMultilevel</code> Ramsey fringe detuning calibration <code>echo</code> <code>characterizations.SpinEchoMultiLevel</code> Spin echo T2 measurement <code>spin_echo</code> <code>characterizations.SpinEchoMultiLevel</code> Spin echo T2 measurement <code>drag</code> <code>calibrations.DragCalibrationSingleQubitMultilevel</code> DRAG pulse calibration <code>randomized_benchmarking</code> <code>characterizations.RandomizedBenchmarkingTwoLevelSubspaceMultilevelSystem</code> Gate fidelity benchmarking <code>multi_qubit_rabi</code> <code>calibrations.MultiQubitRabi</code> Multi-qubit Rabi calibration <code>multi_qubit_t1</code> <code>characterizations.MultiQubitT1</code> Multi-qubit T1 measurement <code>multi_qubit_ramsey</code> <code>calibrations.MultiQubitRamseyMultilevel</code> Multi-qubit Ramsey calibration <code>qubit_spectroscopy_frequency</code> <code>calibrations.QubitSpectroscopyFrequency</code> Qubit frequency spectroscopy"},{"location":"epii/quick-reference/#common-usage-patterns","title":"Common Usage Patterns","text":""},{"location":"epii/quick-reference/#experimentrouter-initialization","title":"ExperimentRouter Initialization","text":"<pre><code>from leeq.epii.experiments import ExperimentRouter\n\n# With setup for backend-aware filtering\nrouter = ExperimentRouter(setup=my_setup)\n\n# Without setup (discovers all experiments)\nrouter = ExperimentRouter()\n</code></pre>"},{"location":"epii/quick-reference/#experiment-discovery","title":"Experiment Discovery","text":"<pre><code># List all available experiments\nexperiments = router.list_experiments()\n\n# Check if specific experiment is available\nif \"calibrations.NormalisedRabi\" in router.experiment_map:\n    print(\"Rabi experiment available\")\n\n# Get experiment class\nexperiment_class = router.get_experiment(\"calibrations.NormalisedRabi\")\n</code></pre>"},{"location":"epii/quick-reference/#experiment-execution-constructor-pattern","title":"Experiment Execution (Constructor Pattern)","text":"<pre><code># CORRECT: Pass parameters to constructor\nexp = QubitSpectroscopyFrequency(\n    dut_qubit=qubit,\n    start=4900.0,\n    stop=5100.0,\n    step=2.0,\n    num_avs=1000\n)\n\n# INCORRECT: Never call run methods directly\n# exp.run_simulated(...)  # DON'T DO THIS\n</code></pre>"},{"location":"epii/quick-reference/#migration-examples","title":"Migration Examples","text":""},{"location":"epii/quick-reference/#before-v01x-with-aliases","title":"Before (v0.1.x with aliases)","text":"<pre><code># Old approach with aliases\nrouter = ExperimentRouter()\nrabi_class = router.get_experiment(\"rabi\")\nt1_class = router.get_experiment(\"t1\")\n\n# Configuration with aliases\nexperiments_to_run = [\"rabi\", \"t1\", \"ramsey\"]\n\n# Client usage with aliases  \nresult = client.run_experiment(\"rabi\", {...})\n</code></pre>"},{"location":"epii/quick-reference/#after-v020-with-canonical-names","title":"After (v0.2.0 with canonical names)","text":"<pre><code># New approach with canonical names\nrouter = ExperimentRouter(setup=my_setup)\nrabi_class = router.get_experiment(\"calibrations.NormalisedRabi\")\nt1_class = router.get_experiment(\"characterizations.SimpleT1\")\n\n# Configuration with canonical names\nexperiments_to_run = [\n    \"calibrations.NormalisedRabi\",\n    \"characterizations.SimpleT1\", \n    \"calibrations.SimpleRamseyMultilevel\"\n]\n\n# Client usage with canonical names\nresult = client.run_experiment(\"calibrations.NormalisedRabi\", {...})\n</code></pre>"},{"location":"epii/quick-reference/#error-handling","title":"Error Handling","text":""},{"location":"epii/quick-reference/#common-errors-and-solutions","title":"Common Errors and Solutions","text":"<p>1. Experiment not found <pre><code>experiment_class = router.get_experiment(\"rabi\")  # Returns None\n# Solution: Use canonical name\nexperiment_class = router.get_experiment(\"calibrations.NormalisedRabi\")\n</code></pre></p> <p>2. No experiments discovered <pre><code>router = ExperimentRouter(setup=hardware_setup)\nif len(router.experiment_map) == 0:\n    print(\"No experiments found\")\n# Solution: Check setup compatibility or use simulation setup\n</code></pre></p> <p>3. Simulation experiments not available <pre><code># In simulation mode, only experiments with run_simulated are available\nrouter = ExperimentRouter(setup=simulation_setup)\n# Some experiments may be filtered out\n</code></pre></p>"},{"location":"epii/quick-reference/#backend-compatibility","title":"Backend Compatibility","text":""},{"location":"epii/quick-reference/#simulation-setup","title":"Simulation Setup","text":"<pre><code>from leeq.setups.built_in.setup_simulation_high_level import HighLevelSimulationSetup\n\nsetup = HighLevelSimulationSetup()\nrouter = ExperimentRouter(setup=setup)\n\n# Only experiments with run_simulated method are available\nprint(f\"Simulation-compatible experiments: {len(router.experiment_map)}\")\n</code></pre>"},{"location":"epii/quick-reference/#hardware-setup","title":"Hardware Setup","text":"<pre><code>router = ExperimentRouter(setup=hardware_setup)\n# All experiments with EPII_INFO are available\nprint(f\"All available experiments: {len(router.experiment_map)}\")\n</code></pre>"},{"location":"epii/quick-reference/#troubleshooting","title":"Troubleshooting","text":""},{"location":"epii/quick-reference/#check-experiment-capabilities","title":"Check Experiment Capabilities","text":"<pre><code># Check if experiment supports simulation\nexp_class = router.get_experiment(\"calibrations.NormalisedRabi\")\nhas_simulation = router._has_own_run_simulated(exp_class)\nprint(f\"Supports simulation: {has_simulation}\")\n\n# Get detailed experiment info\ninfo = router.get_experiment_info(\"calibrations.NormalisedRabi\")\nprint(f\"Description: {info['epii_info'].get('description', 'N/A')}\")\nprint(f\"Parameters: {info['epii_info'].get('parameters', {})}\")\n</code></pre>"},{"location":"epii/quick-reference/#debug-discovery-process","title":"Debug Discovery Process","text":"<pre><code># Enable debug logging\nimport logging\nlogging.getLogger('leeq.epii.experiments').setLevel(logging.DEBUG)\n\n# Initialize router to see discovery process\nrouter = ExperimentRouter()\n</code></pre>"},{"location":"epii/quick-reference/#validate-configuration","title":"Validate Configuration","text":"<pre><code># Test that aliases don't exist\nrouter = ExperimentRouter()\naliases = ['rabi', 't1', 'ramsey', 'echo', 'drag']\nfor alias in aliases:\n    assert alias not in router.experiment_map, f\"Alias {alias} still exists!\"\nprint(\"\u2713 All aliases successfully removed\")\n</code></pre>"},{"location":"epii/quick-reference/#best-practices","title":"Best Practices","text":"<ol> <li>Always use canonical names in new code</li> <li>Initialize router with setup for proper filtering</li> <li>Check experiment availability before execution</li> <li>Use constructor pattern for experiment execution</li> <li>Handle backend compatibility gracefully</li> </ol>"},{"location":"epii/quick-reference/#links","title":"Links","text":"<ul> <li>EPII Overview - Complete user guide</li> <li>API Reference - Technical documentation</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"epii/troubleshooting/","title":"EPII Troubleshooting Guide","text":"<p>This guide helps diagnose and resolve common issues with the LeeQ EPII service.</p>"},{"location":"epii/troubleshooting/#quick-diagnostics","title":"Quick Diagnostics","text":""},{"location":"epii/troubleshooting/#service-status-check","title":"Service Status Check","text":"<pre><code># Check if service is running\nsudo systemctl status leeq-epii@&lt;config&gt;\n\n# Check service logs\nsudo journalctl -u leeq-epii@&lt;config&gt; --no-pager -l\n\n# Check process information\nps aux | grep leeq-epii\n</code></pre>"},{"location":"epii/troubleshooting/#network-connectivity","title":"Network Connectivity","text":"<pre><code># Test if gRPC port is listening\nnetstat -tlnp | grep :50051\n\n# Test gRPC endpoint (requires grpcurl)\ngrpcurl -plaintext localhost:50051 list\n\n# Basic ping test\ngrpcurl -plaintext localhost:50051 ExperimentPlatformService/Ping\n</code></pre>"},{"location":"epii/troubleshooting/#configuration-validation","title":"Configuration Validation","text":"<pre><code># Validate configuration file\nsudo -u leeq /opt/leeq/venv/bin/python -m leeq.epii.daemon --config /etc/leeq/configs/epii/&lt;config&gt;.json --validate\n\n# Check JSON syntax\npython -m json.tool /etc/leeq/configs/epii/&lt;config&gt;.json\n</code></pre>"},{"location":"epii/troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"epii/troubleshooting/#1-service-wont-start","title":"1. Service Won't Start","text":""},{"location":"epii/troubleshooting/#symptoms","title":"Symptoms","text":"<ul> <li><code>systemctl start</code> fails</li> <li>Service immediately exits</li> <li>\"Failed to start\" in system logs</li> </ul>"},{"location":"epii/troubleshooting/#diagnostics","title":"Diagnostics","text":"<pre><code># Check detailed service logs\nsudo journalctl -u leeq-epii@&lt;config&gt; -f\n\n# Try manual start for more detailed errors\nsudo -u leeq /opt/leeq/venv/bin/python -m leeq.epii.daemon --config /etc/leeq/configs/epii/&lt;config&gt;.json --verbose\n</code></pre>"},{"location":"epii/troubleshooting/#common-causes-solutions","title":"Common Causes &amp; Solutions","text":"<p>Configuration File Issues <pre><code># Symptom: JSON parsing errors in logs\n# Solution: Validate JSON syntax\npython -m json.tool /etc/leeq/configs/epii/&lt;config&gt;.json\n\n# Common fixes:\n# - Remove trailing commas\n# - Check quote marks are balanced\n# - Verify all brackets are closed\n</code></pre></p> <p>Permission Issues <pre><code># Symptom: \"Permission denied\" errors\n# Solution: Fix file ownership\nsudo chown -R leeq:leeq /opt/leeq /var/log/leeq /etc/leeq\nsudo chmod 755 /opt/leeq\nsudo chmod 644 /etc/leeq/configs/epii/&lt;config&gt;.json\n</code></pre></p> <p>Missing Dependencies <pre><code># Symptom: ImportError or ModuleNotFoundError\n# Solution: Reinstall dependencies\ncd /opt/leeq\nsudo -u leeq ./venv/bin/pip install -r requirements.txt\nsudo -u leeq ./venv/bin/pip install -e .\n</code></pre></p> <p>Port Already in Use <pre><code># Symptom: \"Address already in use\" error\n# Solution: Find and kill conflicting process\nsudo netstat -tlnp | grep :50051\nsudo kill &lt;PID&gt;\n\n# Or change port in configuration\n</code></pre></p>"},{"location":"epii/troubleshooting/#2-grpc-connection-issues","title":"2. gRPC Connection Issues","text":""},{"location":"epii/troubleshooting/#symptoms_1","title":"Symptoms","text":"<ul> <li>Client cannot connect</li> <li>\"Connection refused\" errors</li> <li>Timeouts on requests</li> </ul>"},{"location":"epii/troubleshooting/#diagnostics_1","title":"Diagnostics","text":"<pre><code># Check if service is listening\nsudo netstat -tlnp | grep :50051\n\n# Test from local machine\ngrpcurl -plaintext localhost:50051 list\n\n# Test from remote machine\ngrpcurl -plaintext &lt;server-ip&gt;:50051 list\n</code></pre>"},{"location":"epii/troubleshooting/#solutions","title":"Solutions","text":"<p>Firewall Issues <pre><code># Check firewall status\nsudo ufw status\n\n# Open gRPC port\nsudo ufw allow 50051/tcp\n\n# For iptables\nsudo iptables -A INPUT -p tcp --dport 50051 -j ACCEPT\n</code></pre></p> <p>Service Not Listening <pre><code># Check service is actually running\nsudo systemctl status leeq-epii@&lt;config&gt;\n\n# Check logs for startup errors\nsudo journalctl -u leeq-epii@&lt;config&gt; --no-pager -l\n</code></pre></p> <p>Network Configuration <pre><code># Verify service binds to correct interface\n# In config.json, ensure proper binding:\n{\n  \"grpc\": {\n    \"host\": \"0.0.0.0\",  // Listen on all interfaces\n    \"port\": 50051\n  }\n}\n</code></pre></p>"},{"location":"epii/troubleshooting/#3-experiment-execution-failures","title":"3. Experiment Execution Failures","text":""},{"location":"epii/troubleshooting/#symptoms_2","title":"Symptoms","text":"<ul> <li>Experiments timeout</li> <li>gRPC INTERNAL errors</li> <li>Invalid parameter errors</li> </ul>"},{"location":"epii/troubleshooting/#diagnostics_2","title":"Diagnostics","text":"<pre><code># Check experiment-specific logs\nsudo journalctl -u leeq-epii@&lt;config&gt; | grep \"experiment\"\n\n# Enable debug logging\n# In config.json:\n{\n  \"logging\": {\n    \"level\": \"DEBUG\"\n  }\n}\n</code></pre>"},{"location":"epii/troubleshooting/#solutions_1","title":"Solutions","text":"<p>LeeQ Setup Issues <pre><code># Symptom: Setup initialization errors\n# Solution: Verify LeeQ configuration\n\n# Check if simulation setup works\npython3 -c \"\nfrom leeq.setups.built_in.setup_simulation_high_level import HighLevelSimulationSetup\nsetup = HighLevelSimulationSetup.build_setup_from_config({\n    'platform': 'numpy',\n    'num_qubits': 2\n})\nprint('Setup OK')\n\"\n</code></pre></p> <p>Parameter Validation Errors <pre><code># Symptom: \"Invalid parameter\" in logs\n# Solution: Check parameter names and types\n\n# List available parameters\ngrpcurl -plaintext localhost:50051 ExperimentPlatformService/ListParameters\n\n# Verify parameter format matches expected types\n</code></pre></p> <p>Memory Issues <pre><code># Symptom: Out of memory errors, experiments killed\n# Solution: Increase memory limits\n\n# Check current memory usage\nps aux | grep leeq-epii\nfree -h\n\n# Increase systemd memory limit\nsudo systemctl edit leeq-epii@&lt;config&gt;\n# Add:\n[Service]\nMemoryLimit=8G\n</code></pre></p>"},{"location":"epii/troubleshooting/#4-performance-issues","title":"4. Performance Issues","text":""},{"location":"epii/troubleshooting/#symptoms_3","title":"Symptoms","text":"<ul> <li>Slow experiment execution</li> <li>High CPU/memory usage</li> <li>Client timeouts</li> </ul>"},{"location":"epii/troubleshooting/#diagnostics_3","title":"Diagnostics","text":"<pre><code># Monitor resource usage\nhtop\nsystemd-cgtop\n\n# Check gRPC worker threads\nps -eLf | grep leeq-epii\n\n# Monitor network connections\nnetstat -an | grep :50051\n</code></pre>"},{"location":"epii/troubleshooting/#solutions_2","title":"Solutions","text":"<p>Worker Thread Tuning <pre><code>// In config.json\n{\n  \"grpc\": {\n    \"max_workers\": 4,  // Reduce for low-memory systems\n    \"max_message_length\": 52428800  // 50MB, reduce if needed\n  }\n}\n</code></pre></p> <p>Experiment Timeout Adjustment <pre><code>{\n  \"experiment_timeout\": 600,  // Increase for slow experiments\n  \"grpc\": {\n    \"client_timeout\": 300\n  }\n}\n</code></pre></p> <p>Hardware-Specific Optimizations <pre><code>// For hardware setups\n{\n  \"config\": {\n    \"parallel_execution\": false,  // Disable for stability\n    \"safety_checks\": {\n      \"enabled\": true,\n      \"max_experiment_duration\": 1800\n    }\n  }\n}\n</code></pre></p>"},{"location":"epii/troubleshooting/#5-data-serialization-issues","title":"5. Data Serialization Issues","text":""},{"location":"epii/troubleshooting/#symptoms_4","title":"Symptoms","text":"<ul> <li>\"Failed to serialize data\" errors</li> <li>Corrupted experiment results</li> <li>gRPC message size errors</li> </ul>"},{"location":"epii/troubleshooting/#solutions_3","title":"Solutions","text":"<p>Large Data Handling <pre><code>{\n  \"grpc\": {\n    \"max_message_length\": 104857600,  // 100MB\n    \"compression\": \"gzip\"\n  }\n}\n</code></pre></p> <p>NumPy Compatibility <pre><code># Ensure NumPy arrays are contiguous\ndata = np.ascontiguousarray(data)\n\n# Check data types\nassert data.dtype == np.float64\n</code></pre></p>"},{"location":"epii/troubleshooting/#advanced-troubleshooting","title":"Advanced Troubleshooting","text":""},{"location":"epii/troubleshooting/#debug-mode-setup","title":"Debug Mode Setup","text":"<pre><code># Create debug configuration\nsudo cp /etc/leeq/configs/epii/production.json /etc/leeq/configs/epii/debug.json\n\n# Edit debug config\nsudo nano /etc/leeq/configs/epii/debug.json\n</code></pre> <pre><code>{\n  \"logging\": {\n    \"level\": \"DEBUG\",\n    \"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s\"\n  },\n  \"grpc\": {\n    \"port\": 50052,  // Use different port\n    \"max_workers\": 1  // Single worker for easier debugging\n  }\n}\n</code></pre>"},{"location":"epii/troubleshooting/#manual-testing","title":"Manual Testing","text":"<pre><code># Test individual components\nfrom leeq.epii.service import EPIIService\nfrom leeq.epii.config import load_config\n\n# Load configuration\nconfig = load_config(\"/etc/leeq/configs/epii/debug.json\")\n\n# Test service initialization\nservice = EPIIService(config)\n\n# Test experiment router\nfrom leeq.epii.experiments import ExperimentRouter\nrouter = ExperimentRouter()\nprint(router.list_experiments())\n</code></pre>"},{"location":"epii/troubleshooting/#log-analysis","title":"Log Analysis","text":"<pre><code># Extract error patterns\nsudo journalctl -u leeq-epii@&lt;config&gt; | grep ERROR\n\n# Extract performance metrics\nsudo journalctl -u leeq-epii@&lt;config&gt; | grep \"duration\"\n\n# Extract client requests\nsudo journalctl -u leeq-epii@&lt;config&gt; | grep \"RunExperiment\"\n</code></pre>"},{"location":"epii/troubleshooting/#environment-specific-issues","title":"Environment-Specific Issues","text":""},{"location":"epii/troubleshooting/#docker-deployment","title":"Docker Deployment","text":"<pre><code># Check container logs\ndocker logs leeq-epii\n\n# Verify port mapping\ndocker port leeq-epii\n\n# Check resource limits\ndocker stats leeq-epii\n</code></pre>"},{"location":"epii/troubleshooting/#kubernetes-deployment","title":"Kubernetes Deployment","text":"<pre><code># Check pod status\nkubectl describe pod leeq-epii-pod\n\n# Check service endpoints\nkubectl get endpoints leeq-epii-service\n\n# View logs\nkubectl logs leeq-epii-pod -f\n</code></pre>"},{"location":"epii/troubleshooting/#hardware-lab-environment","title":"Hardware Lab Environment","text":"<pre><code># Check hardware connectivity\nping &lt;instrument-ip&gt;\n\n# Verify hardware configuration\ncat /etc/leeq/hardware/lab_config.json\n\n# Test hardware interfaces\npython3 -c \"\nfrom leeq.setups.qubic_lbnl_setups import QubicLBNLSetup\n# Test hardware connection\n\"\n</code></pre>"},{"location":"epii/troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"epii/troubleshooting/#information-to-collect","title":"Information to Collect","text":"<p>When reporting issues, include:</p> <ol> <li> <p>System Information <pre><code>uname -a\npython3 --version\npip list | grep leeq\n</code></pre></p> </li> <li> <p>Service Logs <pre><code>sudo journalctl -u leeq-epii@&lt;config&gt; --since \"1 hour ago\" &gt; epii-logs.txt\n</code></pre></p> </li> <li> <p>Configuration <pre><code>sudo cat /etc/leeq/configs/epii/&lt;config&gt;.json &gt; config.txt\n</code></pre></p> </li> <li> <p>Error Details</p> </li> <li>Exact error messages</li> <li>Steps to reproduce</li> <li>Expected vs actual behavior</li> </ol>"},{"location":"epii/troubleshooting/#debug-information-script","title":"Debug Information Script","text":"<pre><code>#!/bin/bash\n# debug-info.sh - Collect EPII debugging information\n\necho \"=== System Information ===\"\nuname -a\npython3 --version\npip list | grep -E \"(leeq|grpc|numpy)\"\n\necho \"=== Service Status ===\"\nsudo systemctl status leeq-epii@* --no-pager\n\necho \"=== Recent Logs ===\"\nsudo journalctl -u leeq-epii@* --since \"1 hour ago\" --no-pager\n\necho \"=== Network Status ===\"\nnetstat -tlnp | grep :50051\n\necho \"=== Resource Usage ===\"\nps aux | grep leeq-epii\nfree -h\ndf -h /var/log/leeq\n</code></pre>"},{"location":"epii/troubleshooting/#contact-information","title":"Contact Information","text":"<ul> <li>GitHub Issues: https://github.com/ShuxiangCao/LeeQ/issues</li> <li>Documentation: https://leeq.readthedocs.io/</li> <li>Support Forum: [Add forum link if available]</li> </ul>"},{"location":"epii/troubleshooting/#preventive-measures","title":"Preventive Measures","text":""},{"location":"epii/troubleshooting/#regular-maintenance","title":"Regular Maintenance","text":"<pre><code># Weekly log rotation\nsudo logrotate /etc/logrotate.d/leeq-epii\n\n# Monthly configuration backup\nsudo tar -czf /backup/leeq-config-$(date +%Y%m).tar.gz /etc/leeq/\n\n# Quarterly dependency updates\ncd /opt/leeq\nsudo -u leeq ./venv/bin/pip list --outdated\n</code></pre>"},{"location":"epii/troubleshooting/#monitoring-setup","title":"Monitoring Setup","text":"<pre><code># Setup log monitoring\nsudo systemctl enable --now systemd-journald\n\n# Configure log retention\nsudo mkdir -p /etc/systemd/journald.conf.d/\necho \"[Journal]\nSystemMaxUse=1G\nRuntimeMaxUse=100M\nMaxRetentionSec=1month\" | sudo tee /etc/systemd/journald.conf.d/leeq.conf\n</code></pre>"},{"location":"epii/troubleshooting/#health-checks","title":"Health Checks","text":"<pre><code># health-check.py - Regular service health verification\nimport grpc\nfrom leeq.epii.proto import epii_pb2, epii_pb2_grpc\n\ndef health_check():\n    try:\n        with grpc.insecure_channel('localhost:50051') as channel:\n            stub = epii_pb2_grpc.ExperimentPlatformServiceStub(channel)\n            response = stub.Ping(epii_pb2.PingRequest(), timeout=5)\n            return True\n    except:\n        return False\n\nif __name__ == \"__main__\":\n    if health_check():\n        print(\"EPII service is healthy\")\n        exit(0)\n    else:\n        print(\"EPII service is unhealthy\")\n        exit(1)\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>Git (for installing dependencies from GitHub)</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#option-1-install-from-github-recommended","title":"Option 1: Install from GitHub (Recommended)","text":"<pre><code>pip install git+https://github.com/ShuxiangCao/LeeQ\n</code></pre>"},{"location":"getting-started/installation/#option-2-install-from-source","title":"Option 2: Install from Source","text":"<ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/ShuxiangCao/LeeQ.git\ncd LeeQ\n</code></pre></p> </li> <li> <p>Install using pip: <pre><code>pip install -e .\n</code></pre></p> </li> </ol>"},{"location":"getting-started/installation/#option-3-using-poetry","title":"Option 3: Using Poetry","text":"<p>If you prefer to use Poetry for dependency management:</p> <pre><code>git clone https://github.com/ShuxiangCao/LeeQ.git\ncd LeeQ\npoetry install\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>LeeQ requires the following key dependencies:</p>"},{"location":"getting-started/installation/#core-dependencies","title":"Core Dependencies","text":"<ul> <li>numpy &lt; 2.0.0: Numerical computing library</li> <li>scipy: Scientific computing library </li> <li>matplotlib: Plotting library</li> <li>qutip: Quantum simulation library</li> <li>plotly: Interactive plotting</li> <li>dash: Web-based dashboards for live monitoring</li> </ul>"},{"location":"getting-started/installation/#external-dependencies-github","title":"External Dependencies (GitHub)","text":"<ul> <li>k_agents: AI/ML experiment generation framework</li> <li>MinimalLLM: LLM integration utilities</li> </ul>"},{"location":"getting-started/installation/#integrated-modules","title":"Integrated Modules","text":"<ul> <li>leeq.chronicle: Experiment logging and persistence (integrated from labchronicle)</li> </ul>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"<ul> <li>scikit-learn: Machine learning algorithms</li> <li>pandas: Data manipulation</li> <li>h5py: HDF5 file format support</li> <li>ipywidgets: Jupyter notebook widgets</li> </ul>"},{"location":"getting-started/installation/#docker-installation","title":"Docker Installation","text":"<p>LeeQ provides a Docker image with all dependencies pre-installed:</p> <pre><code>docker run -p 8888:8888 -p 8050:8050 -v /path/to/local/folder:/home/jovyan/work ghcr.io/shuxiangcao/leeq:latest\n</code></pre> <p>This will: - Start a Jupyter notebook server on port 8888 - Enable live plotting dashboard on port 8050 - Mount your local directory for persistent storage</p>"},{"location":"getting-started/installation/#environment-configuration","title":"Environment Configuration","text":""},{"location":"getting-started/installation/#optional-environment-variables","title":"Optional Environment Variables","text":"<p>Set these environment variables to customize LeeQ behavior:</p> <pre><code># Directory for experiment logs (leeq.chronicle)\nexport LAB_CHRONICLE_LOG_DIR=/path/to/experiment/logs\n\n# Directory for calibration logs\nexport LEEQ_CALIBRATION_LOG_PATH=/path/to/calibration/logs\n</code></pre> <p>If not set, LeeQ will create default directories in your working folder.</p>"},{"location":"getting-started/installation/#virtual-environment-recommended","title":"Virtual Environment (Recommended)","text":"<p>It's recommended to install LeeQ in a virtual environment:</p> <pre><code>python -m venv leeq_env\nsource leeq_env/bin/activate  # On Windows: leeq_env\\Scripts\\activate\npip install git+https://github.com/ShuxiangCao/LeeQ\n</code></pre>"},{"location":"getting-started/installation/#verification","title":"Verification","text":"<p>To verify your installation works correctly:</p> <pre><code>import leeq\nprint(f\"LeeQ version: {leeq.__version__}\")\n\n# Test basic functionality\nfrom leeq.core.elements.built_in.qudit_transmon import TransmonElement\nfrom leeq.setups.built_in.setup_simulation_high_level import HighLevelSimulationSetup\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":"<p>Dependency Conflicts: If you encounter version conflicts, try installing in a fresh virtual environment.</p> <p>GitHub Dependencies: If installation of GitHub dependencies fails, ensure you have Git installed and can access GitHub.</p> <p>NumPy Version: LeeQ requires numpy &lt; 2.0.0 for compatibility. If you have numpy 2.x installed, downgrade with: <pre><code>pip install \"numpy&lt;2.0.0\"\n</code></pre></p>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<ul> <li>Check the GitHub Issues for known problems</li> <li>Review the troubleshooting guide</li> <li>Join our community discussions for support</li> </ul>"},{"location":"guide/calibrations/","title":"Calibrations","text":"<p>This guide covers the calibration procedures and experiments available in LeeQ.</p>"},{"location":"guide/calibrations/#overview","title":"Overview","text":"<p>Calibration is a crucial step in quantum computing experiments. LeeQ provides a comprehensive set of calibration experiments to characterize and optimize qubit performance.</p>"},{"location":"guide/calibrations/#available-calibrations","title":"Available Calibrations","text":""},{"location":"guide/calibrations/#rabi-experiments","title":"Rabi Experiments","text":"<ul> <li>Purpose: Determine optimal drive parameters</li> <li>Module: <code>leeq.experiments.builtin.basic.calibrations.rabi</code></li> <li>Key Parameters: Drive amplitude, frequency</li> </ul>"},{"location":"guide/calibrations/#ramsey-experiments","title":"Ramsey Experiments","text":"<ul> <li>Purpose: Measure dephasing time and fine-tune frequencies</li> <li>Module: <code>leeq.experiments.builtin.basic.calibrations.ramsey</code></li> <li>Key Parameters: Evolution time, detuning</li> </ul>"},{"location":"guide/calibrations/#t1-measurements","title":"T1 Measurements","text":"<ul> <li>Purpose: Measure relaxation time</li> <li>Module: <code>leeq.experiments.builtin.basic.characterizations.t1</code></li> <li>Key Parameters: Delay time range</li> </ul>"},{"location":"guide/calibrations/#running-calibrations","title":"Running Calibrations","text":"<pre><code>import leeq\n\n# Example: Rabi calibration\nrabi_exp = leeq.experiments.RabiExperiment(\n    qubit=my_qubit,\n    drive_amplitude_range=(0, 1),\n    num_points=50\n)\n\nresult = rabi_exp.run()\noptimal_amplitude = result.fit_result.optimal_amplitude\n</code></pre>"},{"location":"guide/calibrations/#best-practices","title":"Best Practices","text":"<ol> <li>Regular Calibration: Run calibrations periodically as system parameters drift</li> <li>Parameter Ranges: Use appropriate ranges based on previous calibrations</li> <li>Fitting: Always verify fit quality before using calibration results</li> <li>Documentation: Log calibration results for tracking system performance</li> </ol>"},{"location":"guide/calibrations/#related-topics","title":"Related Topics","text":"<ul> <li>Experiments - General experiment framework</li> <li>Core Concepts - Understanding LeeQ architecture</li> </ul>"},{"location":"guide/concepts/","title":"Core Concepts","text":"<p>This guide explains the fundamental concepts and architecture of LeeQ.</p>"},{"location":"guide/concepts/#architecture-overview","title":"Architecture Overview","text":"<p>LeeQ follows a modular architecture with clear separation of concerns:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Experiments   \u2502    \u2502    Elements     \u2502    \u2502    Compiler     \u2502\n\u2502                 \u2502    \u2502                 \u2502    \u2502                 \u2502\n\u2502 - Calibrations  \u2502\u2500\u2500\u2500\u2500\u2502 - Qubits        \u2502\u2500\u2500\u2500\u2500\u2502 - Pulse Gen     \u2502\n\u2502 - Measurements  \u2502    \u2502 - Transmons     \u2502    \u2502 - Sequencing    \u2502\n\u2502 - Protocols     \u2502    \u2502 - Parameters    \u2502    \u2502 - Hardware API  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                       \u2502                       \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502     Engine      \u2502\n                    \u2502                 \u2502\n                    \u2502 - Execution     \u2502\n                    \u2502 - Data Flow     \u2502\n                    \u2502 - Logging       \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"guide/concepts/#core-components","title":"Core Components","text":""},{"location":"guide/concepts/#1-leeqobject-base-class","title":"1. LeeQObject Base Class","text":"<p>All LeeQ components inherit from <code>LeeQObject</code>, which provides:</p> <ul> <li>Persistence: Automatic logging through leeq.chronicle (integrated module)</li> <li>Configuration: Parameter management and serialization</li> <li>Tracking: Experiment history and reproducibility</li> </ul> <pre><code>from leeq.core.base import LeeQObject\n\nclass MyCustomComponent(LeeQObject):\n    def __init__(self, name, parameters):\n        super().__init__(name=name, parameters=parameters)\n</code></pre>"},{"location":"guide/concepts/#2-quantum-elements","title":"2. Quantum Elements","text":"<p>Elements represent physical or simulated quantum systems:</p>"},{"location":"guide/concepts/#basic-qubit","title":"Basic Qubit","text":"<pre><code>from leeq.core.elements.built_in.qudit_transmon import TransmonElement\n\n# Create a transmon qubit\nqubit = TransmonElement(\n    name=\"Q1\",\n    parameters={\n        'hrid': 'Q1',\n        'lpb_collections': {...},  # Pulse definitions\n        'measurement_primitives': {...}  # Measurement configs\n    }\n)\n</code></pre>"},{"location":"guide/concepts/#key-features","title":"Key Features:","text":"<ul> <li>Calibration Management: Store and retrieve calibrated parameters</li> <li>Pulse Collections: Define different types of control pulses (f01, f12, etc.)</li> <li>Measurement Primitives: Configure readout and state discrimination</li> </ul>"},{"location":"guide/concepts/#3-execution-engine","title":"3. Execution Engine","text":"<p>The engine manages experiment execution flow:</p> <pre><code>from leeq.core.engine.engine_base import EngineBase\n\n# Engines handle:\n# - Experiment scheduling\n# - Data collection\n# - Result processing\n# - Hardware synchronization\n</code></pre>"},{"location":"guide/concepts/#4-primitives","title":"4. Primitives","text":"<p>Primitives are the building blocks of quantum operations:</p>"},{"location":"guide/concepts/#logical-primitives","title":"Logical Primitives","text":"<pre><code>from leeq.core.primitives.logical_primitives import LogicalPrimitiveBlockSweep\n\n# Define parameter sweeps\nsweep = LogicalPrimitiveBlockSweep(\n    lpb_list=[...],  # List of primitive blocks\n    param_name=\"frequency\",\n    param_values=[4.8, 4.9, 5.0]  # GHz\n)\n</code></pre>"},{"location":"guide/concepts/#physical-primitives","title":"Physical Primitives","text":"<pre><code>from leeq.core.primitives.built_in.simple_drive import SimpleDrive\n\n# Single qubit gate\nx_gate = SimpleDrive(\n    channel=0,\n    frequency=4.85,  # GHz\n    amplitude=0.1,\n    width=0.05,  # \u03bcs\n    shape='gaussian'\n)\n</code></pre>"},{"location":"guide/concepts/#5-compiler","title":"5. Compiler","text":"<p>The compiler translates high-level operations to hardware instructions:</p> <pre><code>from leeq.compiler.compiler_base import CompilerBase\n\n# Compiler features:\n# - Pulse shape generation\n# - Timing optimization\n# - Hardware-specific adaptation\n# - Sequence validation\n</code></pre>"},{"location":"guide/concepts/#key-design-patterns","title":"Key Design Patterns","text":""},{"location":"guide/concepts/#1-setup-pattern","title":"1. Setup Pattern","text":"<p>LeeQ uses a setup pattern to abstract hardware differences:</p> <pre><code>from leeq.setups.setup_base import SetupBase\nfrom leeq.experiments import setup\n\n# Register your hardware configuration\nmy_setup = MyHardwareSetup()\nsetup().register_setup(my_setup)\n\n# Setup provides unified interface regardless of backend\n</code></pre>"},{"location":"guide/concepts/#2-collection-pattern","title":"2. Collection Pattern","text":"<p>Related primitives are grouped into collections:</p> <pre><code># Pulse collections for different transitions\nlpb_collections = {\n    'f01': {  # 0\u21921 transition\n        'type': 'SimpleDriveCollection',\n        'freq': 4.85,\n        'amp': 0.1\n    },\n    'f12': {  # 1\u21922 transition  \n        'type': 'SimpleDriveCollection',\n        'freq': 4.65,\n        'amp': 0.08\n    }\n}\n</code></pre>"},{"location":"guide/concepts/#3-sweep-pattern","title":"3. Sweep Pattern","text":"<p>Parameter sweeps are first-class objects:</p> <pre><code>from leeq.experiments.sweeper import Sweeper\n\n# Create parameter sweeps\nfreq_sweep = Sweeper(\n    parameter=dut.get_c1('f01')['freq'],\n    values=np.linspace(4.8, 4.9, 51)\n)\n\n# Combine multiple sweeps\namp_sweep = Sweeper(\n    parameter=dut.get_c1('f01')['amp'], \n    values=np.linspace(0.05, 0.15, 11)\n)\n\n# Grid sweep automatically generated\n</code></pre>"},{"location":"guide/concepts/#data-flow","title":"Data Flow","text":"<pre><code>Experiment Definition\n        \u2502\n        \u25bc\nParameter Sweeps \u2500\u2500\u2510\n        \u2502         \u2502\n        \u25bc         \u2502\nPrimitive Blocks  \u2502\n        \u2502         \u2502\n        \u25bc         \u2502\nCompiler \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u25bc\nHardware Execution\n        \u2502\n        \u25bc\nData Collection\n        \u2502\n        \u25bc\nResult Processing\n        \u2502\n        \u25bc\nLogging &amp; Storage\n</code></pre>"},{"location":"guide/concepts/#integration-with-aiml","title":"Integration with AI/ML","text":"<p>LeeQ includes built-in AI capabilities:</p>"},{"location":"guide/concepts/#experiment-generation","title":"Experiment Generation","text":"<pre><code>from leeq.utils.ai.experiment_generation import ExperimentGenerator\n\n# AI-assisted experiment design\ngenerator = ExperimentGenerator()\nexperiment_code = generator.generate_experiment(\n    description=\"Optimize qubit frequency with Ramsey fringes\",\n    qubit_params=qubit.get_parameters()\n)\n</code></pre>"},{"location":"guide/concepts/#translation-agent","title":"Translation Agent","text":"<pre><code>from leeq.utils.ai.translation_agent import TranslationAgent\n\n# Convert between different quantum languages\nagent = TranslationAgent()\nqiskit_code = agent.translate_to_qiskit(leeq_experiment)\n</code></pre>"},{"location":"guide/concepts/#best-practices","title":"Best Practices","text":""},{"location":"guide/concepts/#1-configuration-management","title":"1. Configuration Management","text":"<ul> <li>Store all parameters in structured dictionaries</li> <li>Use version control for configuration files</li> <li>Maintain separate configs for different setups</li> </ul>"},{"location":"guide/concepts/#2-calibration-workflow","title":"2. Calibration Workflow","text":"<ul> <li>Regularly save calibration states</li> <li>Track calibration history</li> <li>Automate recalibration procedures</li> </ul>"},{"location":"guide/concepts/#3-error-handling","title":"3. Error Handling","text":"<ul> <li>Implement proper exception handling</li> <li>Use logging for debugging</li> <li>Validate parameters before execution</li> </ul>"},{"location":"guide/concepts/#4-testing","title":"4. Testing","text":"<ul> <li>Write unit tests for custom components</li> <li>Use simulation backends for development</li> <li>Validate against known results</li> </ul>"},{"location":"guide/concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Follow the experiments guide to learn about built-in experiments</li> <li>Read the calibrations guide for calibration workflows</li> <li>Explore the API reference for detailed documentation</li> </ul>"},{"location":"guide/experiments/","title":"Experiments Guide","text":"<p>This guide covers how to use and create experiments in LeeQ with EPII v0.2.0 integration.</p>"},{"location":"guide/experiments/#epii-v020-integration","title":"EPII v0.2.0 Integration","text":"<p>LeeQ experiments now integrate seamlessly with EPII v0.2.0 for backend-aware discovery and execution.</p>"},{"location":"guide/experiments/#using-experimentrouter","title":"Using ExperimentRouter","text":"<pre><code>from leeq.epii.experiments import ExperimentRouter\n\n# Initialize router with your setup for backend-aware filtering\nrouter = ExperimentRouter(setup=my_setup)\n\n# Discover available experiments\nexperiments = router.list_experiments()\nprint(f\"Found {len(experiments)} experiments\")\n\n# Get experiment by canonical name\nexperiment_class = router.get_experiment(\"calibrations.NormalisedRabi\")\n</code></pre>"},{"location":"guide/experiments/#canonical-naming-convention","title":"Canonical Naming Convention","text":"<p>All experiments use module-qualified canonical names:</p> <ul> <li>Calibrations: <code>calibrations.NormalisedRabi</code>, <code>calibrations.SimpleRamseyMultilevel</code></li> <li>Characterizations: <code>characterizations.SimpleT1</code>, <code>characterizations.SpinEchoMultiLevel</code></li> <li>Multi-Qubit: <code>multi_qubit_gates.CrossResonanceCalibration</code></li> </ul>"},{"location":"guide/experiments/#constructor-only-execution-pattern","title":"Constructor-Only Execution Pattern","text":"<p>Important: Always pass parameters to the constructor - never call <code>run()</code> methods directly:</p> <pre><code># CORRECT: Constructor-only pattern\nexp = QubitSpectroscopyFrequency(\n    dut_qubit=qubit,\n    start=4900.0,\n    stop=5100.0,\n    step=2.0,\n    num_avs=1000\n)\n# Experiment automatically executes based on setup type\n\n# INCORRECT: Never do this\nexp = QubitSpectroscopyFrequency()\nexp.run_simulated(...)  # WRONG - never call run methods directly\n</code></pre>"},{"location":"guide/experiments/#built-in-experiments","title":"Built-in Experiments","text":"<p>LeeQ provides a comprehensive library of built-in experiments for quantum system characterization and calibration.</p>"},{"location":"guide/experiments/#basic-calibrations","title":"Basic Calibrations","text":""},{"location":"guide/experiments/#resonator-spectroscopy","title":"Resonator Spectroscopy","text":"<pre><code>from leeq.experiments.builtin.basic.calibrations.resonator_spectroscopy import *\n\n# Find resonator frequency\nexp = ResonatorSweepTransmissionWithExtraInitialLPB(\n    dut,                    # Your quantum element\n    start=9.98,            # Start frequency (GHz)\n    stop=10.02,            # Stop frequency (GHz) \n    step=0.001,            # Step size (GHz)\n    num_avs=1000,          # Number of averages\n    mp_width=8             # Measurement pulse width (\u03bcs)\n)\nresult = exp.run()\n</code></pre>"},{"location":"guide/experiments/#qubit-spectroscopy","title":"Qubit Spectroscopy","text":"<pre><code>from leeq.experiments.builtin.basic.calibrations.qubit_spectroscopy import *\n\n# Find qubit frequency\nexp = QubitSpectroscopy(\n    dut,\n    start=4.8,             # Start frequency (GHz)\n    stop=4.9,              # Stop frequency (GHz)\n    step=0.001,            # Step size (GHz)\n    num_avs=500\n)\nresult = exp.run()\n</code></pre>"},{"location":"guide/experiments/#rabi-oscillations","title":"Rabi Oscillations","text":"<pre><code>from leeq.experiments.builtin.basic.calibrations.rabi import *\n\n# Power Rabi - find \u03c0 pulse amplitude\nexp = PowerRabi(\n    dut,\n    start=0.0,             # Start amplitude\n    stop=0.3,              # Stop amplitude  \n    step=0.005,            # Step size\n    num_avs=500\n)\n\n# Time Rabi - find \u03c0 pulse width\nexp = TimeRabi(\n    dut,\n    start=0.01,            # Start width (\u03bcs)\n    stop=0.1,              # Stop width (\u03bcs)\n    step=0.001,            # Step size (\u03bcs)\n    num_avs=500\n)\n</code></pre>"},{"location":"guide/experiments/#ramsey-fringes","title":"Ramsey Fringes","text":"<pre><code>from leeq.experiments.builtin.basic.calibrations.ramsey import *\n\n# Ramsey experiment for frequency calibration\nexp = Ramsey(\n    dut,\n    start=0.0,             # Start delay (\u03bcs)\n    stop=10.0,             # Stop delay (\u03bcs)\n    step=0.1,              # Step size (\u03bcs)\n    detuning=0.5,          # Detuning frequency (MHz)\n    num_avs=500\n)\n</code></pre>"},{"location":"guide/experiments/#drag-calibration","title":"DRAG Calibration","text":"<pre><code>from leeq.experiments.builtin.basic.calibrations.drag import *\n\n# Calibrate DRAG coefficient\nexp = DragCalibration(\n    dut,\n    start=-2.0,            # Start DRAG coefficient\n    stop=2.0,              # Stop DRAG coefficient\n    step=0.1,              # Step size\n    num_avs=500\n)\n</code></pre>"},{"location":"guide/experiments/#characterization-experiments","title":"Characterization Experiments","text":""},{"location":"guide/experiments/#t1-energy-relaxation-time","title":"T1 (Energy Relaxation Time)","text":"<pre><code>from leeq.experiments.builtin.basic.characterizations.t1 import *\n\nexp = T1Measurement(\n    dut,\n    start=0.0,             # Start delay (\u03bcs)\n    stop=100.0,            # Stop delay (\u03bcs)\n    step=2.0,              # Step size (\u03bcs)\n    num_avs=500\n)\nresult = exp.run()\nprint(f\"T1 = {result.fit_params['T1']:.2f} \u03bcs\")\n</code></pre>"},{"location":"guide/experiments/#t2-dephasing-time","title":"T2 (Dephasing Time)","text":"<pre><code>from leeq.experiments.builtin.basic.characterizations.t2 import *\n\n# T2* measurement (free induction decay)\nexp = T2StarMeasurement(\n    dut,\n    start=0.0,             # Start delay (\u03bcs)\n    stop=50.0,             # Stop delay (\u03bcs)\n    step=0.5,              # Step size (\u03bcs)\n    num_avs=500\n)\n\n# T2 Echo measurement (Hahn echo)\nexp = T2EchoMeasurement(\n    dut,\n    start=0.0,\n    stop=100.0,\n    step=1.0,\n    num_avs=500\n)\n</code></pre>"},{"location":"guide/experiments/#randomized-benchmarking","title":"Randomized Benchmarking","text":"<pre><code>from leeq.experiments.builtin.basic.characterizations.randomized_benchmarking import *\n\n# Single qubit randomized benchmarking\nexp = SingleQubitRandomizedBenchmarking(\n    dut,\n    sequence_lengths=[1, 5, 10, 25, 50, 100, 200],\n    num_sequences=20,      # Number of random sequences per length\n    num_avs=500\n)\nresult = exp.run()\nprint(f\"Gate fidelity = {result.fit_params['fidelity']:.4f}\")\n</code></pre>"},{"location":"guide/experiments/#multi-qubit-experiments","title":"Multi-Qubit Experiments","text":""},{"location":"guide/experiments/#two-qubit-calibrations","title":"Two-Qubit Calibrations","text":"<pre><code>from leeq.experiments.builtin.multi_qubit_gates import *\n\n# Conditional Stark shift calibration\nexp = ConditionalStarkShiftContinuous(\n    control_qubit=dut1,\n    target_qubit=dut2,\n    start_frequency=4.85,\n    stop_frequency=4.87,\n    step=0.001,\n    num_avs=500\n)\n\n# Cross-resonance calibration  \nexp = CrossResonanceCalibration(\n    control_qubit=dut1,\n    target_qubit=dut2,\n    start_amplitude=0.0,\n    stop_amplitude=0.1,\n    step=0.002,\n    num_avs=500\n)\n</code></pre>"},{"location":"guide/experiments/#state-discrimination","title":"State Discrimination","text":""},{"location":"guide/experiments/#gaussian-mixture-model-gmm","title":"Gaussian Mixture Model (GMM)","text":"<pre><code>from leeq.experiments.builtin.basic.calibrations.state_discrimination import *\n\n# Calibrate measurement discrimination\nexp = MeasurementCalibrationMultilevelGMM(\n    dut,\n    mprim_index=0,         # Measurement primitive index\n    sweep_lpb_list=[       # States to prepare and measure\n        dut.get_c1('f01')['I'],  # |0\u27e9 state\n        dut.get_c1('f01')['X']   # |1\u27e9 state  \n    ],\n    num_avs=1000\n)\n</code></pre>"},{"location":"guide/experiments/#custom-experiments","title":"Custom Experiments","text":""},{"location":"guide/experiments/#creating-your-own-experiment","title":"Creating Your Own Experiment","text":"<p>All experiments inherit from the base experiment class:</p> <pre><code>from leeq.experiments.experiments import Experiment\n\nclass MyCustomExperiment(Experiment):\n    def __init__(self, dut, custom_param, **kwargs):\n        # Initialize experiment\n        super().__init__(dut, **kwargs)\n        self.custom_param = custom_param\n\n    def _build_sequence(self):\n        \"\"\"Define the pulse sequence\"\"\"\n        # Build your pulse sequence here\n        sequence = []\n\n        # Add initialization\n        sequence.append(dut.get_c1('f01')['I'])  # Identity\n\n        # Add custom operations\n        custom_pulse = dut.get_c1('f01')['X'].clone()\n        custom_pulse.set_parameter('amp', self.custom_param)\n        sequence.append(custom_pulse)\n\n        # Add measurement\n        sequence.append(dut.get_measurement_prim_intlist(0))\n\n        return sequence\n\n    def _analyze_data(self, data):\n        \"\"\"Analyze experimental data\"\"\"\n        # Process your data here\n        result = {\n            'signal': np.mean(data['I']),\n            'std': np.std(data['I'])\n        }\n        return result\n</code></pre>"},{"location":"guide/experiments/#parameter-sweeps","title":"Parameter Sweeps","text":"<p>Use the Sweeper class for parameter variations:</p> <pre><code>from leeq.experiments.sweeper import Sweeper\n\n# Single parameter sweep\nfreq_sweep = Sweeper(\n    parameter=dut.get_c1('f01')['freq'],\n    values=np.linspace(4.8, 4.9, 51)\n)\n\n# Multi-dimensional sweeps\namp_sweep = Sweeper(\n    parameter=dut.get_c1('f01')['amp'],\n    values=np.linspace(0.05, 0.15, 11)\n)\n\n# Grid sweep automatically handles combinations\n</code></pre>"},{"location":"guide/experiments/#advanced-features","title":"Advanced Features","text":""},{"location":"guide/experiments/#live-plotting","title":"Live Plotting","text":"<pre><code># Enable live monitoring\nfrom leeq.experiments import setup\nsetup().start_live_monitor()\n\n# Experiments automatically display live plots\nexp = PowerRabi(dut, start=0, stop=0.2, step=0.005)\nexp.run()  # Shows live plot as data arrives\n</code></pre>"},{"location":"guide/experiments/#data-persistence","title":"Data Persistence","text":"<pre><code>from leeq.chronicle import Chronicle\n\n# Start logging\nChronicle().start_log()\n\n# All experiments automatically logged\nexp = T1Measurement(dut, start=0, stop=100, step=2)\nresult = exp.run()\n\n# Access logged data later\nlog_entry = Chronicle().get_last_log_entry()\n</code></pre>"},{"location":"guide/experiments/#ai-assisted-experiments","title":"AI-Assisted Experiments","text":"<pre><code>from leeq.utils.ai.experiment_generation import ExperimentGenerator\n\n# Generate experiment from description\ngenerator = ExperimentGenerator()\ncode = generator.generate_experiment(\n    description=\"Measure T2* with varying echo delays\",\n    requirements=[\"high precision\", \"automated fitting\"]\n)\n</code></pre>"},{"location":"guide/experiments/#best-practices","title":"Best Practices","text":""},{"location":"guide/experiments/#1-parameter-organization","title":"1. Parameter Organization","text":"<ul> <li>Group related parameters in dictionaries</li> <li>Use descriptive parameter names</li> <li>Document units and ranges</li> </ul>"},{"location":"guide/experiments/#2-error-handling","title":"2. Error Handling","text":"<pre><code>try:\n    result = experiment.run()\n    if result.fit_quality &lt; 0.95:\n        print(\"Warning: Poor fit quality\")\nexcept ExperimentError as e:\n    print(f\"Experiment failed: {e}\")\n</code></pre>"},{"location":"guide/experiments/#3-calibration-tracking","title":"3. Calibration Tracking","text":"<pre><code># Save calibration after successful experiment\nif result.fit_quality &gt; 0.95:\n    dut.set_parameter('f01_frequency', result.fit_params['frequency'])\n    dut.save_calibration_log()\n</code></pre>"},{"location":"guide/experiments/#4-reproducibility","title":"4. Reproducibility","text":"<ul> <li>Always set random seeds for stochastic experiments</li> <li>Save exact parameter values used</li> <li>Include environmental conditions in logs</li> </ul>"},{"location":"guide/experiments/#5-performance-optimization","title":"5. Performance Optimization","text":"<ul> <li>Use appropriate number of averages</li> <li>Optimize measurement time vs. precision</li> <li>Consider parallel execution for multi-qubit systems</li> </ul>"},{"location":"guide/experiments/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/experiments/#common-issues","title":"Common Issues","text":"<p>Poor Signal-to-Noise: Increase averages or adjust measurement amplitude Calibration Drift: Regular recalibration, track environmental changes Timing Issues: Check pulse sequence timing and hardware limits Fitting Failures: Verify data quality and fitting bounds</p>"},{"location":"guide/experiments/#debugging-tools","title":"Debugging Tools","text":"<pre><code># Enable debug logging\nimport logging\nlogging.getLogger('leeq').setLevel(logging.DEBUG)\n\n# Inspect pulse sequences\nexperiment.sequence.plot()\n\n# Check data quality\nresult.plot_raw_data()\n</code></pre>"},{"location":"guide/experiments/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about calibration workflows</li> <li>Explore advanced theory</li> <li>Review the Tutorial for step-by-step examples</li> </ul>"},{"location":"notebooks/","title":"LeeQ Notebook Documentation","text":""},{"location":"notebooks/#overview","title":"Overview","text":"<p>This directory contains comprehensive Jupyter notebooks demonstrating LeeQ quantum experiment framework capabilities, from basic concepts to advanced calibration workflows.</p>"},{"location":"notebooks/#completed-notebooks","title":"Completed Notebooks","text":""},{"location":"notebooks/#tutorial-notebooks-tutorials","title":"Tutorial Notebooks (<code>tutorials/</code>)","text":"<p>Progressive learning path for quantum experiment automation:</p> <ol> <li>01_basics.ipynb \u2705</li> <li>Core LeeQ concepts and architecture</li> <li>Chronicle logging integration</li> <li>Virtual transmon configuration</li> <li> <p>Basic simulation setup</p> </li> <li> <p>02_single_qubit.ipynb \u2705</p> </li> <li>Single-qubit experiments (Rabi, Ramsey, T1/T2)</li> <li>Complete calibration workflow</li> <li>Parameter optimization</li> <li> <p>Coherence characterization</p> </li> <li> <p>03_multi_qubit.ipynb \u2705</p> </li> <li>Two-qubit gate implementations</li> <li>Entanglement creation and Bell states</li> <li>Crosstalk characterization</li> <li> <p>Multi-qubit calibration</p> </li> <li> <p>04_calibration.ipynb \u2705</p> </li> <li>Automated calibration workflows</li> <li>Measurement fidelity optimization</li> <li>Parameter persistence with Chronicle</li> <li> <p>Calibration data management</p> </li> <li> <p>05_ai_integration.ipynb \u23f8\ufe0f</p> </li> <li>(Placeholder for future AI integration features)</li> </ol>"},{"location":"notebooks/#shared-utilities-shared","title":"Shared Utilities (<code>shared/</code>)","text":"<p>Reusable components for notebook infrastructure:</p> <ul> <li>setup_templates.py: Standardized simulation configurations</li> <li>experiment_helpers.py: Common experiment patterns</li> <li>validation_utils.py: Notebook testing utilities</li> </ul>"},{"location":"notebooks/#validation-scripts-scripts","title":"Validation Scripts (<code>../../scripts/</code>)","text":"<p>Testing and validation infrastructure:</p> <ul> <li>validate_notebooks.py: Notebook execution validation</li> <li>check_outputs.py: Experiment result validation</li> <li>notebook_test_runner.py: Automated test orchestration</li> </ul>"},{"location":"notebooks/#usage","title":"Usage","text":""},{"location":"notebooks/#running-notebooks","title":"Running Notebooks","text":"<pre><code># Start Jupyter Lab\njupyter lab\n\n# Navigate to docs/notebooks/tutorials/\n# Open notebooks in sequence (01 \u2192 02 \u2192 03 \u2192 04)\n</code></pre>"},{"location":"notebooks/#validating-notebooks","title":"Validating Notebooks","text":"<pre><code># Validate single notebook\npython scripts/validate_notebooks.py docs/notebooks/tutorials/01_basics.ipynb\n\n# Validate all tutorials\npython scripts/validate_notebooks.py docs/notebooks/tutorials/*.ipynb\n\n# Run comprehensive test suite\npython scripts/notebook_test_runner.py --all\n</code></pre>"},{"location":"notebooks/#key-features-demonstrated","title":"Key Features Demonstrated","text":""},{"location":"notebooks/#quantum-device-control","title":"Quantum Device Control","text":"<ul> <li>Virtual transmon configuration</li> <li>Pulse parameter optimization</li> <li>Gate calibration sequences</li> <li>Measurement discrimination</li> </ul>"},{"location":"notebooks/#experiment-workflows","title":"Experiment Workflows","text":"<ul> <li>Automated calibration procedures</li> <li>Error handling and recovery</li> <li>Parameter persistence</li> <li>Data analysis and visualization</li> </ul>"},{"location":"notebooks/#leeq-framework-integration","title":"LeeQ Framework Integration","text":"<ul> <li>Chronicle logging system</li> <li>Experiment management</li> <li>High-level simulation backend</li> <li>Built-in calibration experiments</li> </ul>"},{"location":"notebooks/#prerequisites","title":"Prerequisites","text":""},{"location":"notebooks/#required-knowledge","title":"Required Knowledge","text":"<ul> <li>Basic quantum computing concepts</li> <li>Python programming</li> <li>Jupyter notebook usage</li> </ul>"},{"location":"notebooks/#required-packages","title":"Required Packages","text":"<ul> <li>LeeQ framework</li> <li>NumPy, SciPy</li> <li>Plotly for visualization</li> <li>IPython for display</li> </ul>"},{"location":"notebooks/#implementation-status","title":"Implementation Status","text":"Phase Status Description Phase 1: Foundation \u2705 Complete Core tutorials (01-02), shared utilities, validation Phase 2: Advanced \u2705 Complete Multi-qubit (03), calibration (04) notebooks Phase 3: Examples \u23f8\ufe0f Skipped Per user request Phase 4: Workflows \u23f8\ufe0f Skipped Per user request"},{"location":"notebooks/#architecture","title":"Architecture","text":"<pre><code>notebooks/\n\u251c\u2500\u2500 tutorials/           # Progressive learning notebooks\n\u2502   \u251c\u2500\u2500 01_basics       # Core concepts\n\u2502   \u251c\u2500\u2500 02_single_qubit # Single-qubit experiments\n\u2502   \u251c\u2500\u2500 03_multi_qubit  # Two-qubit operations\n\u2502   \u2514\u2500\u2500 04_calibration  # Complete workflows\n\u251c\u2500\u2500 shared/             # Reusable utilities\n\u2502   \u251c\u2500\u2500 setup_templates # Simulation configurations\n\u2502   \u2514\u2500\u2500 experiment_helpers # Common patterns\n\u2514\u2500\u2500 README.md          # This file\n</code></pre>"},{"location":"notebooks/#best-practices","title":"Best Practices","text":"<ol> <li>Sequential Learning: Complete notebooks in order for best understanding</li> <li>Chronicle Logging: Always initialize Chronicle for data persistence</li> <li>Parameter Validation: Verify calibrated parameters are physically reasonable</li> <li>Error Handling: Use try-except blocks for robust experiment execution</li> <li>Visualization: Use Plotly for interactive data exploration</li> </ol>"},{"location":"notebooks/#troubleshooting","title":"Troubleshooting","text":""},{"location":"notebooks/#common-issues","title":"Common Issues","text":"<p>Import Errors - Ensure LeeQ is properly installed - Check Python path includes project root</p> <p>Execution Failures - Verify simulation setup is initialized - Check Chronicle logging is started - Ensure reasonable parameter ranges</p> <p>Performance Issues - Reduce sweep points for faster execution - Use simpler experiments for testing - Enable caching where available</p>"},{"location":"notebooks/#contributing","title":"Contributing","text":"<p>To add new notebooks: 1. Follow established patterns from existing notebooks 2. Use shared utilities for consistency 3. Include comprehensive markdown documentation 4. Validate with testing scripts 5. Update this README</p>"},{"location":"notebooks/#support","title":"Support","text":"<p>For issues or questions: - Check notebook markdown cells for detailed explanations - Review docstrings in experiment classes - Consult LeeQ API documentation - Open issues in project repository</p> <p>Last Updated: August 2024 LeeQ Version: Compatible with current main branch</p>"}]}