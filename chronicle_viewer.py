"""
Chronicle Log Viewer - Interactive visualization tool for LeeQ experiment data.

This module provides a web-based dashboard for loading and visualizing chronicle
log files from LeeQ experiments. It leverages Dash and Plotly to create an
interactive interface that can display various plots generated by experiment
browser functions.

Features:
    - Load chronicle log files (.hdf5) from file paths
    - Automatically discover available plot functions
    - Display experiment metadata and information
    - Generate and display interactive Plotly figures
    - Handle various error conditions gracefully
    - Provide visual feedback with loading states

Requirements:
    - dash >= 2.0.0
    - dash-bootstrap-components >= 1.0.0
    - plotly >= 5.0.0
    - leeq (with chronicle support)

Usage:
    Run as a standalone application:
        python chronicle_viewer.py
    
    Or import and customize:
        from chronicle_viewer import app
        app.run_server(debug=True)

Author: LeeQ Development Team
Version: 1.0.0
"""

import dash
from dash import dcc, html, Input, Output, State, callback_context, ALL
from dash.exceptions import PreventUpdate
import dash.dependencies
import dash_bootstrap_components as dbc
from leeq.chronicle import load_object
import plotly.graph_objects as go
import plotly.tools
import json
import argparse
import base64
import io

# Initialize Dash app with Bootstrap theme
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

def convert_figure_to_plotly(fig):
    """
    Convert various figure types to Plotly figures for display in Dash.
    
    Supports:
    - Plotly figures (returned as-is)
    - Matplotlib figures (converted to Plotly)
    - Other types (error message)
    
    Args:
        fig: Figure object of various types
        
    Returns:
        go.Figure: Plotly figure ready for display
    """
    if isinstance(fig, go.Figure):
        # Already a Plotly figure
        return fig
    
    # Check if it's a matplotlib figure
    try:
        import matplotlib.figure
        if isinstance(fig, matplotlib.figure.Figure):
            # Convert matplotlib figure to Plotly
            try:
                # Try using plotly.tools.mpl_to_plotly (if available)
                if hasattr(plotly.tools, 'mpl_to_plotly'):
                    plotly_fig = plotly.tools.mpl_to_plotly(fig)
                    return plotly_fig
                else:
                    # Fallback: save matplotlib figure as image and embed
                    img_buffer = io.BytesIO()
                    fig.savefig(img_buffer, format='png', bbox_inches='tight', dpi=150)
                    img_buffer.seek(0)
                    img_b64 = base64.b64encode(img_buffer.read()).decode()
                    
                    # Create Plotly figure with embedded image
                    plotly_fig = go.Figure()
                    plotly_fig.add_layout_image(
                        dict(
                            source=f"data:image/png;base64,{img_b64}",
                            xref="paper", yref="paper",
                            x=0, y=1, sizex=1, sizey=1,
                            xanchor="left", yanchor="top",
                            layer="below"
                        )
                    )
                    plotly_fig.update_layout(
                        xaxis=dict(visible=False),
                        yaxis=dict(visible=False),
                        margin=dict(l=0, r=0, t=0, b=0),
                        showlegend=False
                    )
                    
                    # Close matplotlib figure to free memory
                    import matplotlib.pyplot as plt
                    plt.close(fig)
                    
                    return plotly_fig
            except Exception as e:
                # Close matplotlib figure and return error
                try:
                    import matplotlib.pyplot as plt
                    plt.close(fig)
                except:
                    pass
                return go.Figure().add_annotation(
                    text=f"Error converting matplotlib figure: {str(e)[:100]}",
                    xref="paper", yref="paper",
                    x=0.5, y=0.5, showarrow=False
                )
    except ImportError:
        pass
    
    # Unsupported figure type
    return go.Figure().add_annotation(
        text=f"Unsupported figure type: {type(fig).__name__}. Supported: Plotly Figure, matplotlib Figure",
        xref="paper", yref="paper",
        x=0.5, y=0.5, showarrow=False
    )

# Main app layout with improved styling
app.layout = dbc.Container([
    # Header with improved styling
    dbc.Row([
        dbc.Col([
            html.H1("Chronicle Log Viewer", className="mb-2 text-primary"),
            html.P("Load and visualize LeeQ experiment chronicle files", className="text-muted mb-3"),
            html.Hr(className="mb-4"),
        ])
    ]),
    
    # File input with better visual feedback
    dbc.Row([
        dbc.Col([
            dbc.Label("Chronicle Log File Path:", className="fw-bold"),
            dbc.InputGroup([
                dbc.Input(
                    id="file-path",
                    placeholder="Enter full path to chronicle log file (e.g., /path/to/experiment.hdf5)",
                    type="text",
                    className="form-control"
                ),
                dbc.InputGroupText(
                    dbc.Spinner(
                        html.Span(id="loading-indicator", children=""),
                        size="sm",
                        spinner_style={"display": "none"},
                        id="file-spinner"
                    )
                ),
            ], className="mb-3"),
        ])
    ]),
    
    # Experiment selection dropdown
    dbc.Row([
        dbc.Col([
            html.Div(id="experiment-selector-container", children=[], className="mb-3"),
        ])
    ]),
    
    # Loading state wrapper for experiment info
    dbc.Row([
        dbc.Col([
            dcc.Loading(
                id="loading-exp-info",
                type="circle",
                children=html.Div(id="experiment-info", className="mb-3"),
                color="#0d6efd"
            ),
        ])
    ]),
    
    # Plot controls with loading state
    dbc.Row([
        dbc.Col([
            dcc.Loading(
                id="loading-plot-controls",
                type="dot",
                children=html.Div(id="plot-controls", className="mb-3"),
                color="#0d6efd"
            ),
        ])
    ]),
    
    # Plot display with loading overlay
    dbc.Row([
        dbc.Col([
            dcc.Loading(
                id="loading-plot",
                type="graph",
                children=dcc.Graph(
                    id="plot-display",
                    style={"height": "600px"},
                    config={"displayModeBar": True, "displaylogo": False}
                ),
                color="#0d6efd"
            ),
        ])
    ]),
    
    # Hidden storage for file path
    dcc.Store(id="file-store"),
], fluid=True, className="p-4", style={"maxWidth": "1400px"})


# Callback for populating experiment selector when file is loaded
@app.callback(
    Output("experiment-selector-container", "children"),
    Input("file-path", "value"),
    prevent_initial_call=True
)
def build_experiment_tree(file_path):
    """
    Build a hierarchical tree structure of experiments from the chronicle file.
    Returns experiments organized by their entry paths with timestamps.
    """
    try:
        from leeq.chronicle import Chronicle
        chronicle = Chronicle()
        record_book = chronicle.open_record_book(file_path.strip())
        record_ids = record_book.get_available_record_ids()
        
        if not record_ids:
            return []
        
        # Collect all experiments with their paths and timestamps
        experiments = []
        for record_id in record_ids:
            try:
                record = record_book.get_record_by_id(record_id)
                entry_path = str(record.get_path())
                timestamp = record.timestamp
                
                experiments.append({
                    'record_id': record_id,
                    'entry_path': entry_path,
                    'timestamp': timestamp,
                    'path_parts': entry_path.strip('/').split('/')[1:]  # Remove '/root' prefix
                })
            except Exception:
                continue
        
        # Sort by timestamp (older first)
        experiments.sort(key=lambda x: x['timestamp'])
        
        return experiments
        
    except Exception as e:
        raise e


def create_tree_view_items(experiments):
    """
    Create tree view items from the flat experiment list.
    Organizes experiments in a hierarchical structure based on entry paths.
    """
    if not experiments:
        return []
    
    # Group experiments by their hierarchy
    tree_nodes = {}
    
    for exp in experiments:
        path_parts = exp['path_parts']
        record_id = exp['record_id']
        timestamp = exp['timestamp']
        
        if not path_parts:
            continue
            
        # Create display name from the experiment path
        full_name = path_parts[-1].replace('.run', '')
        
        # Extract clean name (remove number prefix)
        if '-' in full_name and full_name.split('-')[0].isdigit():
            clean_name = '-'.join(full_name.split('-')[1:])
        else:
            clean_name = full_name
            
        # Build the tree path
        current_level = tree_nodes
        for i, part in enumerate(path_parts[:-1]):  # All parts except the last
            part_clean = part.replace('.run', '')
            if '-' in part_clean and part_clean.split('-')[0].isdigit():
                parent_name = '-'.join(part_clean.split('-')[1:])
            else:
                parent_name = part_clean
                
            if parent_name not in current_level:
                current_level[parent_name] = {
                    'children': {},
                    'experiments': [],
                    'is_parent': True
                }
            current_level = current_level[parent_name]['children']
        
        # Add the experiment to the appropriate level
        if clean_name not in current_level:
            current_level[clean_name] = {
                'children': {},
                'experiments': [],
                'is_parent': False
            }
        
        current_level[clean_name]['experiments'].append({
            'record_id': record_id,
            'display_name': f"{clean_name} ({record_id[:8]}...)",
            'timestamp': timestamp,
            'full_path': '/'.join(path_parts)
        })
    
    return tree_nodes


def render_tree_nodes(tree_nodes, level=0):
    """
    Recursively render tree nodes as HTML elements.
    """
    items = []
    
    for name, node in tree_nodes.items():
        indent_style = {"marginLeft": f"{level * 20}px"}
        
        if node['is_parent'] and node['children']:
            # Parent node with children
            items.append(
                html.Details([
                    html.Summary(
                        html.Strong(name),
                        style=indent_style
                    ),
                    html.Div([
                        render_tree_nodes(node['children'], level + 1),
                        # Add direct experiments of this parent
                        *[dbc.Button(
                            exp['display_name'],
                            id={"type": "experiment-btn", "index": exp['record_id']},
                            color="outline-primary",
                            size="sm",
                            className="me-2 mb-1",
                            style={"marginLeft": f"{(level + 1) * 20}px"}
                        ) for exp in node['experiments']]
                    ])
                ], open=True, className="mb-2")
            )
        else:
            # Leaf experiments
            for exp in node['experiments']:
                items.append(
                    dbc.Button(
                        exp['display_name'],
                        id={"type": "experiment-btn", "index": exp['record_id']},
                        color="outline-primary",
                        size="sm",
                        className="me-2 mb-1",
                        style=indent_style
                    )
                )
    
    return items


def populate_experiment_selector(file_path):
    """
    Populate experiment selector with a tree view when a file is loaded.
    Returns a tree structure with all available experiments organized hierarchically.
    """
    if not file_path:
        return []
    
    try:
        experiments = build_experiment_tree(file_path)
        
        if not experiments:
            return [
                dbc.Alert(
                    "No experiments found in this chronicle file.",
                    color="warning",
                    className="mb-3"
                )
            ]
        
        # Create tree structure
        tree_nodes = create_tree_view_items(experiments)
        tree_items = render_tree_nodes(tree_nodes)
        
        return [
            dbc.Label("Select Experiment (ordered by timestamp):", className="fw-bold mb-2"),
            html.Div(
                tree_items,
                className="experiment-tree border rounded p-3",
                style={
                    "maxHeight": "400px",
                    "overflowY": "auto",
                    "backgroundColor": "#f8f9fa"
                }
            ),
            html.Small(f"Found {len(experiments)} experiments in this file", 
                      className="text-muted mt-2 d-block")
        ]
        
    except Exception as e:
        return [
            dbc.Alert(
                f"Error loading experiments: {str(e)[:200]}",
                color="danger",
                className="mb-3"
            )
        ]

# Callback for loading selected experiment and displaying info
@app.callback(
    [Output("experiment-info", "children"),
     Output("plot-controls", "children"),
     Output("file-store", "data")],
    [Input({"type": "experiment-btn", "index": ALL}, "n_clicks")],
    [State("file-path", "value")],
    prevent_initial_call=True
)
def load_selected_experiment(n_clicks_list, file_path):
    """
    Load the selected chronicle experiment from the file and extract metadata.
    
    This callback is triggered when the user clicks an experiment button in the tree view.
    It loads the specific experiment using the record ID and prepares UI components.
    
    Args:
        n_clicks_list (list): List of n_clicks values from experiment buttons
        file_path (str): Path to the chronicle log file
    
    Returns:
        tuple: A 3-element tuple containing:
            - experiment_info (Dash component): Card or Alert with experiment details
            - plot_controls (Dash component): Buttons for available plots or alert message
            - file_store (str or None): The validated file path for storage
    
    Handles:
        - Empty or invalid file paths
        - File not found errors
        - Permission errors
        - Corrupted HDF5 files
        - Experiments without browser functions
        - Generic loading errors
    
    Note:
        The function provides detailed error messages with visual indicators
        using Bootstrap icons for better user experience.
    """
    # Determine which button was clicked
    ctx = callback_context
    if not ctx.triggered:
        raise PreventUpdate
    
    # Extract record_id from the triggered button
    triggered_id = ctx.triggered[0]['prop_id']
    if not triggered_id or 'experiment-btn' not in triggered_id:
        raise PreventUpdate
    
    # Parse the button ID to get the record_id
    import json
    button_id = json.loads(triggered_id.split('.')[0])
    selected_record_id = button_id['index']
    
    if not selected_record_id or not file_path or file_path.strip() == "":
        return (
            dbc.Alert(
                [
                    html.I(className="bi bi-info-circle-fill me-2"),
                    "Select an experiment from the dropdown to view details"
                ],
                color="info",
                className="d-flex align-items-center"
            ),
            [],
            None
        )
    
    try:
        # Load the specific experiment using the selected record ID
        experiment = load_object(file_path.strip(), record_id=selected_record_id)
        
        # Create experiment info display with improved styling
        exp_type = type(experiment).__name__
        
        # Try to get additional experiment attributes if available
        exp_attrs = []
        exp_attrs.append(html.P(f"Record ID: {selected_record_id[:8]}...", className="mb-1 small"))
        exp_attrs.append(html.P(f"File: {file_path}", className="mb-1 small text-truncate"))
        
        if hasattr(experiment, '__dict__'):
            for attr in ['name', 'description', 'timestamp', 'date']:
                if hasattr(experiment, attr):
                    value = getattr(experiment, attr)
                    if value:
                        exp_attrs.append(html.P(f"{attr.title()}: {str(value)[:100]}", className="mb-1 small"))
        
        info_card = dbc.Card([
            dbc.CardBody([
                html.H5([
                    html.I(className="bi bi-check-circle-fill text-success me-2"),
                    "Experiment Loaded Successfully"
                ], className="card-title text-success"),
                html.Hr(className="my-2"),
                html.P([
                    html.Strong("Type: "),
                    html.Span(exp_type, className="font-monospace")
                ], className="mb-1"),
                html.P([
                    html.Strong("File: "),
                    html.Span(file_path.strip(), className="text-muted small font-monospace")
                ], className="mb-1"),
                *exp_attrs  # Include any additional attributes found
            ])
        ], color="success", outline=True, className="shadow-sm")
        
        # Get available plot functions using built-in method
        try:
            plot_functions = experiment.get_browser_functions()
        except AttributeError:
            # Experiment doesn't have get_browser_functions method
            store_data = {"file_path": file_path.strip(), "record_id": selected_record_id}
            return (
                info_card,
                dbc.Alert(
                    [
                        html.I(className="bi bi-exclamation-triangle-fill me-2"),
                        "This experiment does not have browser functions available. ",
                        html.Small("(Missing get_browser_functions method)", className="text-muted")
                    ],
                    color="warning",
                    className="d-flex align-items-center"
                ),
                store_data
            )
        
        if plot_functions:
            # Create buttons for each plot function
            buttons = []
            for name, method in plot_functions:
                btn = dbc.Button(
                    name.replace("_", " ").title(),
                    id={"type": "plot-btn", "index": name},
                    color="primary",
                    className="me-2 mb-2",
                    size="sm"
                )
                buttons.append(btn)
            
            plot_control_div = dbc.Card([
                dbc.CardBody([
                    html.H5([
                        html.I(className="bi bi-graph-up me-2"),
                        f"Available Plots ({len(plot_functions)})"
                    ], className="card-title mb-3 text-primary"),
                    html.P("Click a button below to generate and display the plot:", className="text-muted small mb-3"),
                    html.Div(buttons, className="d-flex flex-wrap")
                ])
            ], color="primary", outline=True, className="shadow-sm")
            
            # Store both file path and record ID for plot callbacks
            store_data = {"file_path": file_path.strip(), "record_id": selected_record_id}
            return info_card, plot_control_div, store_data
        else:
            store_data = {"file_path": file_path.strip(), "record_id": selected_record_id}
            return (
                info_card,
                dbc.Alert("No plots available for this experiment", color="info"),
                store_data
            )
            
    except FileNotFoundError:
        return (
            dbc.Alert(
                [
                    html.I(className="bi bi-x-circle-fill me-2"),
                    html.Strong("File Not Found"),
                    html.Br(),
                    html.Small(f"Path: {file_path}", className="font-monospace")
                ],
                color="danger",
                className="d-flex align-items-start"
            ),
            [],
            {"file_path": file_path, "record_id": selected_record_id} if selected_record_id else None
        )
    except PermissionError:
        return (
            dbc.Alert(
                [
                    html.I(className="bi bi-shield-x me-2"),
                    html.Strong("Permission Denied"),
                    html.Br(),
                    html.Small(f"Cannot access: {file_path}", className="font-monospace")
                ],
                color="danger",
                className="d-flex align-items-start"
            ),
            [],
            {"file_path": file_path, "record_id": selected_record_id} if selected_record_id else None
        )
    except Exception as e:
        # Generic error handling for other issues (corrupted files, etc.)
        error_msg = str(e)
        if "HDF5" in error_msg or "h5py" in error_msg:
            return (
                dbc.Alert(
                    [
                        html.I(className="bi bi-file-earmark-x me-2"),
                        html.Strong("Invalid Chronicle File"),
                        html.Br(),
                        html.Small("The file appears to be corrupted or is not a valid HDF5 chronicle file."),
                        html.Br(),
                        html.Details([
                            html.Summary("Technical Details", className="text-muted small mt-2"),
                            html.Pre(error_msg[:200], className="mt-2 p-2 bg-light small")
                        ])
                    ],
                    color="danger"
                ),
                [],
                {"file_path": file_path, "record_id": selected_record_id} if selected_record_id else None
            )
        else:
            return (
                dbc.Alert(
                    [
                        html.I(className="bi bi-exclamation-octagon-fill me-2"),
                        html.Strong("Error Loading Experiment"),
                        html.Br(),
                        html.Small("An unexpected error occurred while loading the file."),
                        html.Br(),
                        html.Details([
                            html.Summary("Error Details", className="text-muted small mt-2"),
                            html.Pre(error_msg[:200], className="mt-2 p-2 bg-light small")
                        ])
                    ],
                    color="danger"
                ),
                [],
                {"file_path": file_path, "record_id": selected_record_id} if selected_record_id else None
            )


# Callback for displaying plots
@app.callback(
    Output("plot-display", "figure"),
    Input({"type": "plot-btn", "index": dash.dependencies.ALL}, "n_clicks"),
    State("file-store", "data"),
    prevent_initial_call=True
)
def display_plot(n_clicks, store_data):
    """
    Generate and display a plot based on the selected browser function.
    
    This callback is triggered when any plot button is clicked. It identifies
    which button was clicked, reloads the experiment, calls the corresponding
    browser function, and returns the generated Plotly figure.
    
    Args:
        n_clicks (list): List of click counts for all plot buttons.
                        Used with pattern-matching callbacks.
        store_data (dict): Dictionary containing file_path and record_id from dcc.Store.
    
    Returns:
        plotly.graph_objects.Figure: The plot to display, or an error figure
                                     with an annotation if something goes wrong.
    
    Process:
        1. Validates that a file is loaded
        2. Identifies which button was clicked using callback context
        3. Reloads the experiment from the stored file path
        4. Finds and executes the selected plot method
        5. Validates the returned figure
        6. Returns the figure or an error message
    
    Error Handling:
        - No file loaded: Shows "No experiment loaded" message
        - Plot generation errors: Shows error details
        - Invalid return type: Shows type mismatch message
        - Method not found: Shows "Plot method not found" message
    
    Note:
        The experiment is reloaded for each plot to ensure consistency
        and handle any potential state changes.
    """
    if not store_data:
        return go.Figure().add_annotation(
            text="No experiment loaded",
            xref="paper", yref="paper",
            x=0.5, y=0.5, showarrow=False
        )
    
    file_path = store_data.get("file_path")
    record_id = store_data.get("record_id")
    
    if not file_path or not record_id:
        return go.Figure().add_annotation(
            text="Invalid experiment data",
            xref="paper", yref="paper", 
            x=0.5, y=0.5, showarrow=False
        )
    
    # Get which button was clicked
    ctx = callback_context
    if not ctx.triggered:
        return go.Figure()
    
    # Extract the button ID that was clicked
    button_id = ctx.triggered[0]['prop_id']
    if '"index":' not in button_id:
        return go.Figure()
    
    # Parse the method name from the button ID
    button_dict = json.loads(button_id.split('.')[0])
    method_name = button_dict['index']
    
    try:
        # Load the specific experiment using the selected record ID
        experiment = load_object(file_path, record_id=record_id)
        
        plot_functions = experiment.get_browser_functions()
        
        # Find and call the selected plot method
        for name, method in plot_functions:
            if name == method_name:
                try:
                    fig = method()
                    # Convert figure to Plotly format (supports both Plotly and matplotlib)
                    plotly_fig = convert_figure_to_plotly(fig)
                    return plotly_fig
                except Exception as plot_error:
                    return go.Figure().add_annotation(
                        text=f"Error generating plot: {str(plot_error)[:200]}",
                        xref="paper", yref="paper",
                        x=0.5, y=0.5, showarrow=False
                    )
        
        return go.Figure().add_annotation(
            text=f"Plot method '{method_name}' not found",
            xref="paper", yref="paper",
            x=0.5, y=0.5, showarrow=False
        )
        
    except Exception as e:
        return go.Figure().add_annotation(
            text=f"Error loading experiment: {str(e)[:200]}",
            xref="paper", yref="paper",
            x=0.5, y=0.5, showarrow=False
        )


def main():
    """
    Main entry point for the chronicle viewer app.
    
    Starts the Dash server with configurable options.
    By default runs on http://localhost:8050 in debug mode.
    
    Command line arguments:
        --host: Host to run the server on (default: 0.0.0.0)
        --port: Port to run the server on (default: 8050)
        --no-debug: Disable debug mode
        --help: Show help message
    
    Example:
        python chronicle_viewer.py
        python chronicle_viewer.py --port 8080 --no-debug
    """
    parser = argparse.ArgumentParser(
        description="Chronicle Log Viewer - Visualize LeeQ experiment chronicle files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Usage Examples:
  Start the viewer on default port (8050):
    python chronicle_viewer.py
    
  Start on a different port:
    python chronicle_viewer.py --port 8080
    
  Start in production mode (no debug):
    python chronicle_viewer.py --no-debug
    
  View this help:
    python chronicle_viewer.py --help

Once started, open your browser to http://localhost:8050 (or the specified port)
and enter the path to a chronicle log file to visualize.
        """
    )
    parser.add_argument("--host", default="0.0.0.0", help="Host to run the server on")
    parser.add_argument("--port", type=int, default=8050, help="Port to run the server on")
    parser.add_argument("--no-debug", action="store_true", help="Disable debug mode")
    
    args = parser.parse_args()
    
    debug = not args.no_debug
    
    print(f"Starting Chronicle Log Viewer...")
    print(f"Server will be available at http://localhost:{args.port}")
    if debug:
        print("Debug mode is ON - auto-reload enabled")
    
    app.run(debug=debug, host=args.host, port=args.port)


if __name__ == "__main__":
    main()