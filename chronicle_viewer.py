"""
Chronicle Log Viewer - Interactive visualization tool for LeeQ experiment data.

This module provides a web-based dashboard for loading and visualizing chronicle
log files from LeeQ experiments. It leverages Dash and Plotly to create an
interactive interface that can display various plots generated by experiment
browser functions.

Features:
    - Load chronicle log files (.hdf5) from file paths
    - Automatically discover available plot functions
    - Display experiment metadata and information
    - Generate and display interactive Plotly figures
    - Handle various error conditions gracefully
    - Provide visual feedback with loading states

Requirements:
    - dash >= 2.0.0
    - dash-bootstrap-components >= 1.0.0
    - plotly >= 5.0.0
    - leeq (with chronicle support)

Usage:
    Run as a standalone application:
        python chronicle_viewer.py
    
    Or import and customize:
        from chronicle_viewer import app
        app.run_server(debug=True)

Author: LeeQ Development Team
Version: 1.0.0
"""

import dash
from dash import dcc, html, Input, Output, State, callback_context
import dash.dependencies
import dash_bootstrap_components as dbc
from leeq.chronicle import load_object
import plotly.graph_objects as go
import plotly.tools
import json
import argparse
import base64
import io

# Initialize Dash app with Bootstrap theme
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

def convert_figure_to_plotly(fig):
    """
    Convert various figure types to Plotly figures for display in Dash.
    
    Supports:
    - Plotly figures (returned as-is)
    - Matplotlib figures (converted to Plotly)
    - Other types (error message)
    
    Args:
        fig: Figure object of various types
        
    Returns:
        go.Figure: Plotly figure ready for display
    """
    if isinstance(fig, go.Figure):
        # Already a Plotly figure
        return fig
    
    # Check if it's a matplotlib figure
    try:
        import matplotlib.figure
        if isinstance(fig, matplotlib.figure.Figure):
            # Convert matplotlib figure to Plotly
            try:
                # Try using plotly.tools.mpl_to_plotly (if available)
                if hasattr(plotly.tools, 'mpl_to_plotly'):
                    plotly_fig = plotly.tools.mpl_to_plotly(fig)
                    return plotly_fig
                else:
                    # Fallback: save matplotlib figure as image and embed
                    img_buffer = io.BytesIO()
                    fig.savefig(img_buffer, format='png', bbox_inches='tight', dpi=150)
                    img_buffer.seek(0)
                    img_b64 = base64.b64encode(img_buffer.read()).decode()
                    
                    # Create Plotly figure with embedded image
                    plotly_fig = go.Figure()
                    plotly_fig.add_layout_image(
                        dict(
                            source=f"data:image/png;base64,{img_b64}",
                            xref="paper", yref="paper",
                            x=0, y=1, sizex=1, sizey=1,
                            xanchor="left", yanchor="top",
                            layer="below"
                        )
                    )
                    plotly_fig.update_layout(
                        xaxis=dict(visible=False),
                        yaxis=dict(visible=False),
                        margin=dict(l=0, r=0, t=0, b=0),
                        showlegend=False
                    )
                    
                    # Close matplotlib figure to free memory
                    import matplotlib.pyplot as plt
                    plt.close(fig)
                    
                    return plotly_fig
            except Exception as e:
                # Close matplotlib figure and return error
                try:
                    import matplotlib.pyplot as plt
                    plt.close(fig)
                except:
                    pass
                return go.Figure().add_annotation(
                    text=f"Error converting matplotlib figure: {str(e)[:100]}",
                    xref="paper", yref="paper",
                    x=0.5, y=0.5, showarrow=False
                )
    except ImportError:
        pass
    
    # Unsupported figure type
    return go.Figure().add_annotation(
        text=f"Unsupported figure type: {type(fig).__name__}. Supported: Plotly Figure, matplotlib Figure",
        xref="paper", yref="paper",
        x=0.5, y=0.5, showarrow=False
    )

# Main app layout with improved styling
app.layout = dbc.Container([
    # Header with improved styling
    dbc.Row([
        dbc.Col([
            html.H1("Chronicle Log Viewer", className="mb-2 text-primary"),
            html.P("Load and visualize LeeQ experiment chronicle files", className="text-muted mb-3"),
            html.Hr(className="mb-4"),
        ])
    ]),
    
    # File input with better visual feedback
    dbc.Row([
        dbc.Col([
            dbc.Label("Chronicle Log File Path:", className="fw-bold"),
            dbc.InputGroup([
                dbc.Input(
                    id="file-path",
                    placeholder="Enter full path to chronicle log file (e.g., /path/to/experiment.hdf5)",
                    type="text",
                    className="form-control"
                ),
                dbc.InputGroupText(
                    dbc.Spinner(
                        html.Span(id="loading-indicator", children=""),
                        size="sm",
                        spinner_style={"display": "none"},
                        id="file-spinner"
                    )
                ),
            ], className="mb-3"),
        ])
    ]),
    
    # Loading state wrapper for experiment info
    dbc.Row([
        dbc.Col([
            dcc.Loading(
                id="loading-exp-info",
                type="circle",
                children=html.Div(id="experiment-info", className="mb-3"),
                color="#0d6efd"
            ),
        ])
    ]),
    
    # Plot controls with loading state
    dbc.Row([
        dbc.Col([
            dcc.Loading(
                id="loading-plot-controls",
                type="dot",
                children=html.Div(id="plot-controls", className="mb-3"),
                color="#0d6efd"
            ),
        ])
    ]),
    
    # Plot display with loading overlay
    dbc.Row([
        dbc.Col([
            dcc.Loading(
                id="loading-plot",
                type="graph",
                children=dcc.Graph(
                    id="plot-display",
                    style={"height": "600px"},
                    config={"displayModeBar": True, "displaylogo": False}
                ),
                color="#0d6efd"
            ),
        ])
    ]),
    
    # Hidden storage for file path
    dcc.Store(id="file-store"),
], fluid=True, className="p-4", style={"maxWidth": "1400px"})


# Callback for loading experiment and displaying info
@app.callback(
    [Output("experiment-info", "children"),
     Output("plot-controls", "children"),
     Output("file-store", "data")],
    Input("file-path", "value"),
    prevent_initial_call=True
)
def load_experiment(file_path):
    """
    Load a chronicle experiment from the specified file path and extract metadata.
    
    This callback is triggered when the user enters a file path in the input field.
    It attempts to load the experiment using LeeQ's load_object function, extracts
    available browser functions, and prepares the UI components for display.
    
    Args:
        file_path (str): Path to the chronicle log file (.hdf5 format).
                        Can be absolute or relative path.
    
    Returns:
        tuple: A 3-element tuple containing:
            - experiment_info (Dash component): Card or Alert with experiment details
            - plot_controls (Dash component): Buttons for available plots or alert message
            - file_store (str or None): The validated file path for storage
    
    Handles:
        - Empty or invalid file paths
        - File not found errors
        - Permission errors
        - Corrupted HDF5 files
        - Experiments without browser functions
        - Generic loading errors
    
    Note:
        The function provides detailed error messages with visual indicators
        using Bootstrap icons for better user experience.
    """
    if not file_path or file_path.strip() == "":
        return (
            dbc.Alert(
                [
                    html.I(className="bi bi-info-circle-fill me-2"),
                    "Please enter a file path to load an experiment"
                ],
                color="info",
                className="d-flex align-items-center"
            ),
            [],
            None
        )
    
    try:
        # Try to open record book and get record IDs
        try:
            from leeq.chronicle import Chronicle
            chronicle = Chronicle()
            record_book = chronicle.open_record_book(file_path.strip())
            record_ids = record_book.get_available_record_ids()
            
            if not record_ids:
                return dbc.Alert("No experiments found in this chronicle file.", color="warning"), [], None
            
            # Use the first record ID
            first_record_id = record_ids[0]
            # Attempt to load the experiment object
            experiment = load_object(file_path.strip(), record_id=first_record_id)
        except Exception:
            # Fallback: try to load without record_id (old behavior)
            try:
                experiment = load_object(file_path.strip())
                record_ids = []  # No record ID info available
                first_record_id = None
            except Exception as e:
                # This is the original error handling
                raise e
        
        # Create experiment info display with improved styling
        exp_type = type(experiment).__name__
        
        # Try to get additional experiment attributes if available
        exp_attrs = []
        if first_record_id:
            exp_attrs.append(html.P(f"Record ID: {first_record_id[:8]}...", className="mb-1 small"))
            exp_attrs.append(html.P(f"Total records in file: {len(record_ids)}", className="mb-1 small"))
        else:
            exp_attrs.append(html.P("Loaded using legacy method", className="mb-1 small"))
        
        if hasattr(experiment, '__dict__'):
            for attr in ['name', 'description', 'timestamp', 'date']:
                if hasattr(experiment, attr):
                    value = getattr(experiment, attr)
                    if value:
                        exp_attrs.append(html.P(f"{attr.title()}: {str(value)[:100]}", className="mb-1 small"))
        
        info_card = dbc.Card([
            dbc.CardBody([
                html.H5([
                    html.I(className="bi bi-check-circle-fill text-success me-2"),
                    "Experiment Loaded Successfully"
                ], className="card-title text-success"),
                html.Hr(className="my-2"),
                html.P([
                    html.Strong("Type: "),
                    html.Span(exp_type, className="font-monospace")
                ], className="mb-1"),
                html.P([
                    html.Strong("File: "),
                    html.Span(file_path.strip(), className="text-muted small font-monospace")
                ], className="mb-1"),
                *exp_attrs  # Include any additional attributes found
            ])
        ], color="success", outline=True, className="shadow-sm")
        
        # Get available plot functions using built-in method
        try:
            plot_functions = experiment.get_browser_functions()
        except AttributeError:
            # Experiment doesn't have get_browser_functions method
            return (
                info_card,
                dbc.Alert(
                    [
                        html.I(className="bi bi-exclamation-triangle-fill me-2"),
                        "This experiment does not have browser functions available. ",
                        html.Small("(Missing get_browser_functions method)", className="text-muted")
                    ],
                    color="warning",
                    className="d-flex align-items-center"
                ),
                file_path.strip()
            )
        
        if plot_functions:
            # Create buttons for each plot function
            buttons = []
            for name, method in plot_functions:
                btn = dbc.Button(
                    name.replace("_", " ").title(),
                    id={"type": "plot-btn", "index": name},
                    color="primary",
                    className="me-2 mb-2",
                    size="sm"
                )
                buttons.append(btn)
            
            plot_control_div = dbc.Card([
                dbc.CardBody([
                    html.H5([
                        html.I(className="bi bi-graph-up me-2"),
                        f"Available Plots ({len(plot_functions)})"
                    ], className="card-title mb-3 text-primary"),
                    html.P("Click a button below to generate and display the plot:", className="text-muted small mb-3"),
                    html.Div(buttons, className="d-flex flex-wrap")
                ])
            ], color="primary", outline=True, className="shadow-sm")
            
            return info_card, plot_control_div, file_path.strip()
        else:
            return (
                info_card,
                dbc.Alert("No plots available for this experiment", color="info"),
                file_path.strip()
            )
            
    except FileNotFoundError:
        return (
            dbc.Alert(
                [
                    html.I(className="bi bi-x-circle-fill me-2"),
                    html.Strong("File Not Found"),
                    html.Br(),
                    html.Small(f"Path: {file_path}", className="font-monospace")
                ],
                color="danger",
                className="d-flex align-items-start"
            ),
            [],
            None
        )
    except PermissionError:
        return (
            dbc.Alert(
                [
                    html.I(className="bi bi-shield-x me-2"),
                    html.Strong("Permission Denied"),
                    html.Br(),
                    html.Small(f"Cannot access: {file_path}", className="font-monospace")
                ],
                color="danger",
                className="d-flex align-items-start"
            ),
            [],
            None
        )
    except Exception as e:
        # Generic error handling for other issues (corrupted files, etc.)
        error_msg = str(e)
        if "HDF5" in error_msg or "h5py" in error_msg:
            return (
                dbc.Alert(
                    [
                        html.I(className="bi bi-file-earmark-x me-2"),
                        html.Strong("Invalid Chronicle File"),
                        html.Br(),
                        html.Small("The file appears to be corrupted or is not a valid HDF5 chronicle file."),
                        html.Br(),
                        html.Details([
                            html.Summary("Technical Details", className="text-muted small mt-2"),
                            html.Pre(error_msg[:200], className="mt-2 p-2 bg-light small")
                        ])
                    ],
                    color="danger"
                ),
                [],
                None
            )
        else:
            return (
                dbc.Alert(
                    [
                        html.I(className="bi bi-exclamation-octagon-fill me-2"),
                        html.Strong("Error Loading Experiment"),
                        html.Br(),
                        html.Small("An unexpected error occurred while loading the file."),
                        html.Br(),
                        html.Details([
                            html.Summary("Error Details", className="text-muted small mt-2"),
                            html.Pre(error_msg[:200], className="mt-2 p-2 bg-light small")
                        ])
                    ],
                    color="danger"
                ),
                [],
                None
            )


# Callback for displaying plots
@app.callback(
    Output("plot-display", "figure"),
    Input({"type": "plot-btn", "index": dash.dependencies.ALL}, "n_clicks"),
    State("file-store", "data"),
    prevent_initial_call=True
)
def display_plot(n_clicks, file_path):
    """
    Generate and display a plot based on the selected browser function.
    
    This callback is triggered when any plot button is clicked. It identifies
    which button was clicked, reloads the experiment, calls the corresponding
    browser function, and returns the generated Plotly figure.
    
    Args:
        n_clicks (list): List of click counts for all plot buttons.
                        Used with pattern-matching callbacks.
        file_path (str): Stored path to the chronicle file from dcc.Store.
    
    Returns:
        plotly.graph_objects.Figure: The plot to display, or an error figure
                                     with an annotation if something goes wrong.
    
    Process:
        1. Validates that a file is loaded
        2. Identifies which button was clicked using callback context
        3. Reloads the experiment from the stored file path
        4. Finds and executes the selected plot method
        5. Validates the returned figure
        6. Returns the figure or an error message
    
    Error Handling:
        - No file loaded: Shows "No experiment loaded" message
        - Plot generation errors: Shows error details
        - Invalid return type: Shows type mismatch message
        - Method not found: Shows "Plot method not found" message
    
    Note:
        The experiment is reloaded for each plot to ensure consistency
        and handle any potential state changes.
    """
    if not file_path:
        return go.Figure().add_annotation(
            text="No experiment loaded",
            xref="paper", yref="paper",
            x=0.5, y=0.5, showarrow=False
        )
    
    # Get which button was clicked
    ctx = callback_context
    if not ctx.triggered:
        return go.Figure()
    
    # Extract the button ID that was clicked
    button_id = ctx.triggered[0]['prop_id']
    if '"index":' not in button_id:
        return go.Figure()
    
    # Parse the method name from the button ID
    button_dict = json.loads(button_id.split('.')[0])
    method_name = button_dict['index']
    
    try:
        # Try to reload with record ID, fallback to legacy method
        try:
            from leeq.chronicle import Chronicle
            chronicle = Chronicle()
            record_book = chronicle.open_record_book(file_path)
            record_ids = record_book.get_available_record_ids()
            
            if not record_ids:
                return go.Figure().add_annotation(text="No experiments found in chronicle file")
            
            first_record_id = record_ids[0]
            experiment = load_object(file_path, record_id=first_record_id)
        except Exception:
            # Fallback: try to load without record_id
            experiment = load_object(file_path)
        
        plot_functions = experiment.get_browser_functions()
        
        # Find and call the selected plot method
        for name, method in plot_functions:
            if name == method_name:
                try:
                    fig = method()
                    # Convert figure to Plotly format (supports both Plotly and matplotlib)
                    plotly_fig = convert_figure_to_plotly(fig)
                    return plotly_fig
                except Exception as plot_error:
                    return go.Figure().add_annotation(
                        text=f"Error generating plot: {str(plot_error)[:200]}",
                        xref="paper", yref="paper",
                        x=0.5, y=0.5, showarrow=False
                    )
        
        return go.Figure().add_annotation(
            text=f"Plot method '{method_name}' not found",
            xref="paper", yref="paper",
            x=0.5, y=0.5, showarrow=False
        )
        
    except Exception as e:
        return go.Figure().add_annotation(
            text=f"Error loading experiment: {str(e)[:200]}",
            xref="paper", yref="paper",
            x=0.5, y=0.5, showarrow=False
        )


def main():
    """
    Main entry point for the chronicle viewer app.
    
    Starts the Dash server with configurable options.
    By default runs on http://localhost:8050 in debug mode.
    
    Command line arguments:
        --host: Host to run the server on (default: 0.0.0.0)
        --port: Port to run the server on (default: 8050)
        --no-debug: Disable debug mode
        --help: Show help message
    
    Example:
        python chronicle_viewer.py
        python chronicle_viewer.py --port 8080 --no-debug
    """
    parser = argparse.ArgumentParser(
        description="Chronicle Log Viewer - Visualize LeeQ experiment chronicle files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Usage Examples:
  Start the viewer on default port (8050):
    python chronicle_viewer.py
    
  Start on a different port:
    python chronicle_viewer.py --port 8080
    
  Start in production mode (no debug):
    python chronicle_viewer.py --no-debug
    
  View this help:
    python chronicle_viewer.py --help

Once started, open your browser to http://localhost:8050 (or the specified port)
and enter the path to a chronicle log file to visualize.
        """
    )
    parser.add_argument("--host", default="0.0.0.0", help="Host to run the server on")
    parser.add_argument("--port", type=int, default=8050, help="Port to run the server on")
    parser.add_argument("--no-debug", action="store_true", help="Disable debug mode")
    
    args = parser.parse_args()
    
    debug = not args.no_debug
    
    print(f"Starting Chronicle Log Viewer...")
    print(f"Server will be available at http://localhost:{args.port}")
    if debug:
        print("Debug mode is ON - auto-reload enabled")
    
    app.run(debug=debug, host=args.host, port=args.port)


if __name__ == "__main__":
    main()