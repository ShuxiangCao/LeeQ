"""
Chronicle Log Viewer - Interactive visualization tool for LeeQ experiment data.

This module provides a web-based dashboard for loading and visualizing chronicle
log files from LeeQ experiments. It leverages Dash and Plotly to create an
interactive interface that can display various plots generated by experiment
browser functions.

Features:
    - Load chronicle log files (.hdf5) from file paths
    - Automatically discover available plot functions
    - Display experiment metadata and information
    - Generate and display interactive Plotly figures
    - Handle various error conditions gracefully
    - Provide visual feedback with loading states

Requirements:
    - dash >= 2.0.0
    - dash-bootstrap-components >= 1.0.0
    - plotly >= 5.0.0
    - leeq (with chronicle support)

Usage:
    Run as a standalone application:
        python chronicle_viewer.py
    
    Or import and customize:
        from chronicle_viewer import app
        app.run_server(debug=True)

Author: LeeQ Development Team
Version: 1.0.0
"""

import dash
from dash import dcc, html, Input, Output, State, callback_context, ALL
from dash.exceptions import PreventUpdate
import dash.dependencies
import dash_bootstrap_components as dbc
from leeq.chronicle import load_object
import plotly.graph_objects as go
import plotly.tools
import json
import argparse
import base64
import io

# Initialize Dash app with Bootstrap theme and custom CSS
app = dash.Dash(__name__, external_stylesheets=[
    dbc.themes.BOOTSTRAP,
    "https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css"
])

# Custom CSS for sidebar layout
custom_css = """
<style>
body {
    height: 100vh;
    overflow: hidden;
}

.main-container {
    height: 100vh;
    display: flex;
    flex-direction: column;
}

.content-row {
    flex: 1;
    min-height: 0;
}

.sidebar-column {
    height: 100%;
    display: flex;
    flex-direction: column;
}

.sidebar-card {
    flex: 1;
    display: flex;
    flex-direction: column;
    height: 100%;
    min-height: 0;
}

.main-content-column {
    height: 100%;
    display: flex;
    flex-direction: column;
}

.main-content-card {
    flex: 1;
    display: flex;
    flex-direction: column;
    height: 100%;
    min-height: 0;
}

.main-content-card .card-body {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

.attributes-column {
    height: 100%;
    display: flex;
    flex-direction: column;
}

.attributes-card {
    flex: 1;
    display: flex;
    flex-direction: column;
    height: 100%;
    min-height: 0;
}

.attributes-card .card-body {
    flex: 1;
    overflow-y: auto;
    min-height: 0;
}

.sidebar-card .card-body {
    flex: 1;
    overflow-y: auto;
    min-height: 0;
    display: flex;
    flex-direction: column;
}

.file-input-section {
    flex-shrink: 0;
}

.experiment-section {
    flex: 1;
    min-height: 0;
    display: flex;
    flex-direction: column;
}

.experiment-tree {
    flex: 1;
    min-height: 0;
    overflow-y: auto !important;
}

.experiment-tree details summary {
    cursor: pointer;
    padding: 4px 0;
}

.experiment-tree details summary:hover {
    background-color: rgba(0, 123, 255, 0.1);
    border-radius: 3px;
}

.experiment-tree .btn-outline-primary {
    border-width: 1px;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
}

.experiment-tree .btn-outline-primary:hover {
    background-color: rgba(0, 123, 255, 0.1);
    border-color: #0d6efd;
}

.main-content {
    height: 100%;
    overflow-y: auto;
}

/* Resizable panel styles */
.resizable-container {
    display: flex;
    height: 100%;
    position: relative;
}

.sidebar-resizable {
    min-width: 200px;
    max-width: 60%;
    width: 25%;
    position: relative;
    flex-shrink: 0;
}

.resize-handle {
    width: 6px;
    background: #ced4da;
    cursor: col-resize;
    position: absolute;
    top: 0;
    right: -3px;
    bottom: 0;
    z-index: 100;
    transition: all 0.2s;
    border-radius: 0 3px 3px 0;
}

.resize-handle:hover,
.resize-handle.resizing {
    background: #0d6efd;
    width: 8px;
    right: -4px;
}

.resize-handle:hover::after,
.resize-handle.resizing::after {
    content: '';
    position: absolute;
    left: -3px;
    right: -3px;
    top: 0;
    bottom: 0;
    background: rgba(13, 110, 253, 0.15);
    border-radius: 3px;
}

.main-content-resizable {
    flex: 1;
    min-width: 300px;
    padding-left: 10px;
}

/* Prevent text selection during resize */
.resizing * {
    user-select: none !important;
    pointer-events: none !important;
}

/* Resize cursor for the entire document during resize */
body.resizing {
    cursor: col-resize !important;
}
</style>
"""

# Add custom CSS to app layout
app.index_string = """<!DOCTYPE html>
<html>
    <head>
        {%metas%}
        <title>{%title%}</title>
        {%favicon%}
        {%css%}
        """ + custom_css + """
    </head>
    <body>
        {%app_entry%}
        <footer>
            {%config%}
            {%scripts%}
            {%renderer%}
        </footer>
        <script>
        // Resizable panel functionality with better Dash compatibility
        function initializeResize() {
            const resizeHandle = document.querySelector('.resize-handle');
            const sidebar = document.querySelector('.sidebar-resizable');
            const container = document.querySelector('.resizable-container');
            
            if (!resizeHandle || !sidebar || !container) {
                // Retry after a short delay if elements aren't found
                setTimeout(initializeResize, 100);
                return;
            }
            
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;
            
            // Remove any existing event listeners
            resizeHandle.onmousedown = null;
            
            resizeHandle.onmousedown = function(e) {
                isResizing = true;
                startX = e.clientX;
                startWidth = parseInt(document.defaultView.getComputedStyle(sidebar).width, 10);
                
                document.body.classList.add('resizing');
                resizeHandle.classList.add('resizing');
                
                e.preventDefault();
                e.stopPropagation();
            };
            
            document.onmousemove = function(e) {
                if (!isResizing) return;
                
                const width = startWidth + e.clientX - startX;
                const containerWidth = container.offsetWidth;
                const minWidth = 200;
                const maxWidth = containerWidth * 0.6;
                
                if (width >= minWidth && width <= maxWidth) {
                    const percentage = (width / containerWidth) * 100;
                    sidebar.style.width = percentage + '%';
                }
                
                e.preventDefault();
            };
            
            document.onmouseup = function() {
                if (isResizing) {
                    isResizing = false;
                    document.body.classList.remove('resizing');
                    resizeHandle.classList.remove('resizing');
                }
            };
            
            // Handle window resize
            window.onresize = function() {
                const containerWidth = container.offsetWidth;
                const currentWidth = sidebar.offsetWidth;
                const percentage = (currentWidth / containerWidth) * 100;
                
                if (percentage > 60) {
                    sidebar.style.width = '60%';
                } else if (percentage < 15) {
                    sidebar.style.width = '200px';
                }
            };
            
            console.log('Resize functionality initialized');
        }
        
        // Initialize immediately and also after Dash renders
        document.addEventListener('DOMContentLoaded', initializeResize);
        setTimeout(initializeResize, 500);
        setTimeout(initializeResize, 1000);
        </script>
    </body>
</html>"""

def convert_figure_to_plotly(fig):
    """
    Convert various figure types to Plotly figures for display in Dash.
    
    Supports:
    - Plotly figures (returned as-is)
    - Matplotlib figures (converted to Plotly)
    - Other types (error message)
    
    Args:
        fig: Figure object of various types
        
    Returns:
        go.Figure: Plotly figure ready for display
    """
    if isinstance(fig, go.Figure):
        # Already a Plotly figure
        return fig
    
    # Check if it's a matplotlib figure
    try:
        import matplotlib.figure
        if isinstance(fig, matplotlib.figure.Figure):
            # Convert matplotlib figure to Plotly
            try:
                # Try using plotly.tools.mpl_to_plotly (if available)
                if hasattr(plotly.tools, 'mpl_to_plotly'):
                    plotly_fig = plotly.tools.mpl_to_plotly(fig)
                    return plotly_fig
                else:
                    # Fallback: save matplotlib figure as image and embed
                    img_buffer = io.BytesIO()
                    fig.savefig(img_buffer, format='png', bbox_inches='tight', dpi=150)
                    img_buffer.seek(0)
                    img_b64 = base64.b64encode(img_buffer.read()).decode()
                    
                    # Create Plotly figure with embedded image
                    plotly_fig = go.Figure()
                    plotly_fig.add_layout_image(
                        dict(
                            source=f"data:image/png;base64,{img_b64}",
                            xref="paper", yref="paper",
                            x=0, y=1, sizex=1, sizey=1,
                            xanchor="left", yanchor="top",
                            layer="below"
                        )
                    )
                    plotly_fig.update_layout(
                        xaxis=dict(visible=False),
                        yaxis=dict(visible=False),
                        margin=dict(l=0, r=0, t=0, b=0),
                        showlegend=False
                    )
                    
                    # Close matplotlib figure to free memory
                    import matplotlib.pyplot as plt
                    plt.close(fig)
                    
                    return plotly_fig
            except Exception as e:
                # Close matplotlib figure and return error
                try:
                    import matplotlib.pyplot as plt
                    plt.close(fig)
                except:
                    pass
                return go.Figure().add_annotation(
                    text=f"Error converting matplotlib figure: {str(e)[:100]}",
                    xref="paper", yref="paper",
                    x=0.5, y=0.5, showarrow=False
                )
    except ImportError:
        pass
    
    # Unsupported figure type
    return go.Figure().add_annotation(
        text=f"Unsupported figure type: {type(fig).__name__}. Supported: Plotly Figure, matplotlib Figure",
        xref="paper", yref="paper",
        x=0.5, y=0.5, showarrow=False
    )

# Main app layout with full-height sidebar design
app.layout = dbc.Container([
    # Header
    dbc.Row([
        dbc.Col([
            html.H1("Chronicle Log Viewer", className="mb-2 text-primary"),
            html.P("Load and visualize LeeQ experiment chronicle files", className="text-muted mb-3"),
            html.Hr(className="mb-3"),
        ])
    ], className="flex-shrink-0"),
    
    # Main layout with resizable three panels
    html.Div([
        # Left Sidebar - File & Experiment Selection (Resizable)
        html.Div([
            dbc.Card([
                dbc.CardHeader([
                    html.I(className="bi bi-folder-open me-2"),
                    html.Strong("File & Experiment Selection"),
                    html.Small(" (drag right edge to resize)", className="text-muted ms-2")
                ]),
                dbc.CardBody([
                    # File input section
                    html.Div([
                        dbc.Label("Chronicle Log File:", className="fw-bold mb-2"),
                        dbc.InputGroup([
                            dbc.Input(
                                id="file-path",
                                placeholder="Enter file path...",
                                type="text",
                                className="form-control",
                                size="sm"
                            ),
                            dbc.InputGroupText(
                                dbc.Spinner(
                                    html.Span(id="loading-indicator", children=""),
                                    size="sm",
                                    spinner_style={"display": "none"},
                                    id="file-spinner"
                                )
                            ),
                        ], className="mb-3"),
                    ], className="file-input-section"),
                    
                    # Experiment selection section
                    html.Div([
                        html.Hr(className="my-3"),
                        html.Div(id="experiment-selector-container", children=[], className=""),
                    ], className="experiment-section")
                ])
            ], className="sidebar-card"),
            # Resize handle
            html.Div(className="resize-handle", title="Drag to resize sidebar")
        ], className="sidebar-resizable"),
        
        # Right Content Area - Plot & Attributes
        html.Div([
            dbc.Row([
                # Main Content Area - Plot & Controls
                dbc.Col([
                    dbc.Card([
                        dbc.CardBody([
                            # Experiment info section
                            dcc.Loading(
                                id="loading-exp-info",
                                type="circle",
                                children=html.Div(id="experiment-info", className="mb-3"),
                                color="#0d6efd"
                            ),
                            
                            # Plot controls section
                            dcc.Loading(
                                id="loading-plot-controls",
                                type="dot",
                                children=html.Div(id="plot-controls", className="mb-3"),
                                color="#0d6efd"
                            ),
                            
                            # Plot display section
                            dcc.Loading(
                                id="loading-plot",
                                type="graph",
                                children=dcc.Graph(
                                    id="plot-display",
                                    style={"height": "100%", "minHeight": "400px"},
                                    config={"displayModeBar": True, "displaylogo": False}
                                ),
                                color="#0d6efd"
                            ),
                        ])
                    ], className="main-content-card")
                ], width=8, className="main-content-column pe-2"),
                
                # Right Panel - Experiment Attributes
                dbc.Col([
                    dbc.Card([
                        dbc.CardHeader([
                            html.I(className="bi bi-info-circle me-2"),
                            html.Strong("Experiment Attributes")
                        ]),
                        dbc.CardBody([
                            dcc.Loading(
                                id="loading-attributes",
                                type="dot",
                                children=html.Div(
                                    id="experiment-attributes", 
                                    children=[
                                        dbc.Alert(
                                            [
                                                html.I(className="bi bi-arrow-left me-2"),
                                                "Select an experiment to view its attributes"
                                            ],
                                            color="info",
                                            className="text-center"
                                        )
                                    ],
                                    className=""
                                ),
                                color="#0d6efd"
                            )
                        ])
                    ], className="attributes-card")
                ], width=4, className="attributes-column"),
            ], className="h-100")
        ], className="main-content-resizable")
    ], className="resizable-container content-row"),
    
    # Hidden storage for file path
    dcc.Store(id="file-store"),
], fluid=True, className="p-4 main-container", style={"maxWidth": "1600px"})


# Callback for populating experiment selector when file is loaded
@app.callback(
    Output("experiment-selector-container", "children"),
    Input("file-path", "value"),
    prevent_initial_call=True
)
def populate_experiment_selector(file_path):
    """
    Populate experiment selector with a tree view when a file is loaded.
    Returns a tree structure with all available experiments organized hierarchically.
    """
    if not file_path:
        return []
    
    try:
        experiments = build_experiment_tree(file_path)
        
        if not experiments:
            return [
                dbc.Alert(
                    "No experiments found in this chronicle file.",
                    color="warning",
                    className="mb-3"
                )
            ]
        
        # Create tree structure
        tree_nodes = create_tree_view_items(experiments)
        tree_items = render_tree_nodes(tree_nodes)
        
        return [
            dbc.Label("Select Experiment:", className="fw-bold mb-2"),
            html.Small(f"({len(experiments)} experiments, ordered by timestamp)", 
                      className="text-muted mb-2 d-block"),
            html.Div(
                tree_items,
                className="experiment-tree border rounded p-2",
                style={
                    "backgroundColor": "#f8f9fa",
                    "fontSize": "0.9rem"
                }
            )
        ]
        
    except Exception as e:
        return [
            dbc.Alert(
                f"Error loading experiments: {str(e)[:200]}",
                color="danger",
                className="mb-3"
            )
        ]


def build_experiment_tree(file_path):
    """
    Build a hierarchical tree structure of experiments from the chronicle file.
    Returns experiments organized by their entry paths with timestamps.
    """
    try:
        from leeq.chronicle import Chronicle
        chronicle = Chronicle()
        record_book = chronicle.open_record_book(file_path.strip())
        record_ids = record_book.get_available_record_ids()
        
        if not record_ids:
            return []
        
        # Collect all experiments with their paths and timestamps
        experiments = []
        for record_id in record_ids:
            try:
                record = record_book.get_record_by_id(record_id)
                entry_path = str(record.get_path())
                timestamp = record.timestamp
                
                experiments.append({
                    'record_id': record_id,
                    'entry_path': entry_path,
                    'timestamp': timestamp,
                    'path_parts': entry_path.strip('/').split('/')[1:]  # Remove '/root' prefix
                })
            except Exception:
                continue
        
        # Sort by timestamp (older first)
        experiments.sort(key=lambda x: x['timestamp'])
        
        return experiments
        
    except Exception as e:
        raise e


def create_tree_view_items(experiments):
    """
    Create tree view items from the flat experiment list.
    Organizes experiments in a hierarchical structure based on entry paths.
    Also identifies which parent nodes have their own experiment records.
    """
    if not experiments:
        return []
    
    # Group experiments by their hierarchy
    tree_nodes = {}
    # Track parent experiments that have their own records
    parent_experiments = {}
    
    # First pass: identify all parent experiments
    for exp in experiments:
        # Check if this experiment is a parent experiment (could have children)
        # by looking for other experiments that start with this path
        is_potential_parent = any(
            other_exp['entry_path'].startswith(exp['entry_path'] + '/') 
            for other_exp in experiments if other_exp != exp
        )
        
        if is_potential_parent:
            path_parts = exp['path_parts']
            full_name = path_parts[-1].replace('.run', '')
            
            # Extract clean name (remove number prefix)
            if '-' in full_name and full_name.split('-')[0].isdigit():
                clean_name = '-'.join(full_name.split('-')[1:])
            else:
                clean_name = full_name
            
            parent_key = exp['entry_path']
            parent_experiments[parent_key] = {
                'record_id': exp['record_id'],
                'display_name': f"{clean_name} ({exp['record_id']})",
                'timestamp': exp['timestamp'],
                'clean_name': clean_name,
                'full_path': '/'.join(path_parts)
            }
    
    # Second pass: build the tree structure
    for exp in experiments:
        path_parts = exp['path_parts']
        record_id = exp['record_id']
        timestamp = exp['timestamp']
        
        if not path_parts:
            continue
            
        # Create display name from the experiment path
        full_name = path_parts[-1].replace('.run', '')
        
        # Extract clean name (remove number prefix)
        if '-' in full_name and full_name.split('-')[0].isdigit():
            clean_name = '-'.join(full_name.split('-')[1:])
        else:
            clean_name = full_name
            
        # Build the tree path
        current_level = tree_nodes
        for i, part in enumerate(path_parts[:-1]):  # All parts except the last
            part_clean = part.replace('.run', '')
            if '-' in part_clean and part_clean.split('-')[0].isdigit():
                parent_name = '-'.join(part_clean.split('-')[1:])
            else:
                parent_name = part_clean
                
            if parent_name not in current_level:
                # Check if this parent has its own experiment record
                parent_path = '/root/' + '/'.join(path_parts[:i+1])
                parent_exp_data = parent_experiments.get(parent_path)
                
                current_level[parent_name] = {
                    'children': {},
                    'experiments': [],
                    'is_parent': True,
                    'parent_experiment': parent_exp_data  # Store parent experiment data if exists
                }
            else:
                # Update existing parent node with experiment data if we found some
                parent_path = '/root/' + '/'.join(path_parts[:i+1])
                parent_exp_data = parent_experiments.get(parent_path)
                if parent_exp_data and not current_level[parent_name]['parent_experiment']:
                    current_level[parent_name]['parent_experiment'] = parent_exp_data
                    
            current_level = current_level[parent_name]['children']
        
        # Add the experiment to the appropriate level
        if clean_name not in current_level:
            current_level[clean_name] = {
                'children': {},
                'experiments': [],
                'is_parent': False,
                'parent_experiment': None
            }
        
        current_level[clean_name]['experiments'].append({
            'record_id': record_id,
            'display_name': f"{clean_name} ({record_id})",
            'timestamp': timestamp,
            'full_path': '/'.join(path_parts)
        })
    
    return tree_nodes


def render_tree_nodes(tree_nodes, level=0):
    """
    Recursively render tree nodes as HTML elements.
    """
    items = []
    
    for name, node in tree_nodes.items():
        indent_style = {"marginLeft": f"{level * 20}px"}
        
        if node['is_parent'] and node['children']:
            # Parent node with children
            # Check if this parent has its own experiment data
            parent_exp = node.get('parent_experiment')
            
            # Create the summary content with optional SELECT button
            if parent_exp:
                # Parent has its own experiment - add SELECT button
                summary_content = html.Div([
                    html.Strong(name, className="me-2"),
                    dbc.Button(
                        "SELECT",
                        id={"type": "experiment-btn", "index": parent_exp['record_id']},
                        color="primary",
                        size="sm",
                        className="ms-auto",
                        style={"fontSize": "0.7rem", "padding": "2px 8px"}
                    )
                ], className="d-flex align-items-center w-100")
            else:
                # Parent is just organizational - no SELECT button
                summary_content = html.Strong(name)
            
            items.append(
                html.Details([
                    html.Summary(
                        summary_content,
                        style=indent_style,
                        className="mb-1"
                    ),
                    html.Div([
                        *render_tree_nodes(node['children'], level + 1),
                        # Add direct experiments of this parent
                        *[dbc.Button(
                            exp['display_name'],
                            id={"type": "experiment-btn", "index": exp['record_id']},
                            color="outline-primary",
                            size="sm",
                            className="mb-1 w-100 text-start",
                            style={"marginLeft": f"{(level + 1) * 15}px", "fontSize": "0.85rem"}
                        ) for exp in node['experiments']]
                    ])
                ], open=True, className="mb-2")
            )
        else:
            # Leaf experiments
            for exp in node['experiments']:
                items.append(
                    dbc.Button(
                        exp['display_name'],
                        id={"type": "experiment-btn", "index": exp['record_id']},
                        color="outline-primary",
                        size="sm",
                        className="mb-1 w-100 text-start",
                        style={**indent_style, "fontSize": "0.85rem"}
                    )
                )
    
    return items


def create_experiment_attributes_panel(experiment=None, record_id=None, error_msg=None):
    """Create the experiment attributes panel content."""
    if error_msg:
        return dbc.Alert(
            [
                html.I(className="bi bi-exclamation-triangle me-2"),
                f"Error loading attributes: {error_msg}"
            ],
            color="warning"
        )
    
    if not experiment:
        return dbc.Alert(
            [
                html.I(className="bi bi-arrow-left me-2"),
                "Select an experiment to view its attributes"
            ],
            color="info",
            className="text-center"
        )
    
    # Extract experiment attributes
    attributes = []
    
    # Basic information
    attributes.append(
        html.Div([
            html.H6("Basic Information", className="text-primary mb-2 border-bottom pb-1"),
            html.P([html.Strong("Type: "), html.Span(type(experiment).__name__, className="font-monospace")], className="mb-1 small"),
            html.P([html.Strong("Record ID: "), html.Span(record_id, className="font-monospace")], className="mb-1 small"),
        ], className="mb-3")
    )
    
    # Run Arguments and Kwargs section
    def format_argument_value(arg):
        """Helper function to format argument values for display."""
        if isinstance(arg, (int, float, bool)):
            return str(arg)
        elif isinstance(arg, str):
            return f'"{arg}"' if len(arg) < 50 else f'"{arg[:47]}..."'
        elif isinstance(arg, (list, tuple)):
            return f"{type(arg).__name__}[{len(arg)}]"
        elif isinstance(arg, dict):
            return f"dict[{len(arg)} keys]"
        elif hasattr(arg, '__name__'):
            return f"{type(arg).__name__}: {arg.__name__}"
        else:
            return str(type(arg).__name__)
    
    def get_run_function_params(experiment):
        """Extract parameter names from the experiment's run function."""
        import inspect
        try:
            # Look for run method
            if hasattr(experiment, 'run') and callable(experiment.run):
                sig = inspect.signature(experiment.run)
                params = list(sig.parameters.keys())
                # Remove 'self' if present
                if params and params[0] == 'self':
                    params = params[1:]
                return params
        except Exception:
            pass
        return []
    
    # Get parameter names from run function
    run_param_names = get_run_function_params(experiment)
    
    # Display run_args
    if hasattr(experiment, 'run_args') and experiment.run_args is not None:
        try:
            run_args = experiment.run_args
            run_args_items = []
            
            if isinstance(run_args, tuple):
                # Unpack tuple elements with parameter names if available
                for i, arg in enumerate(run_args):
                    display_value = format_argument_value(arg)
                    
                    # Use parameter name if available, otherwise use index
                    if i < len(run_param_names):
                        param_label = f"{run_param_names[i]}:"
                    else:
                        param_label = f"Arg {i}:"
                    
                    run_args_items.append(
                        html.P([
                            html.Strong(param_label + " "), 
                            html.Span(display_value, className="text-muted small font-monospace")
                        ], className="mb-1 small", style={"wordBreak": "break-word"})
                    )
            else:
                # Handle non-tuple run_args
                display_value = str(run_args)[:100] + "..." if len(str(run_args)) > 100 else str(run_args)
                run_args_items.append(
                    html.P([
                        html.Strong("Value: "), 
                        html.Span(display_value, className="text-muted small font-monospace")
                    ], className="mb-1 small", style={"wordBreak": "break-word"})
                )
            
            if run_args_items:
                attributes.append(
                    html.Div([
                        html.H6("Run Arguments", className="text-primary mb-2 border-bottom pb-1"),
                        html.Small(f"Type: {type(run_args).__name__}" + (f", Length: {len(run_args)}" if hasattr(run_args, '__len__') else ""), 
                                  className="text-muted d-block mb-2"),
                        html.Div(run_args_items)
                    ], className="mb-3")
                )
        except Exception as e:
            # If there's an error processing run_args, show a brief error message
            attributes.append(
                html.Div([
                    html.H6("Run Arguments", className="text-primary mb-2 border-bottom pb-1"),
                    html.P(f"Error processing run_args: {str(e)[:50]}...", className="text-muted small")
                ], className="mb-3")
            )
    
    # Display run_kwargs
    if hasattr(experiment, 'run_kwargs') and experiment.run_kwargs is not None:
        try:
            run_kwargs = experiment.run_kwargs
            run_kwargs_items = []
            
            if isinstance(run_kwargs, dict):
                # Display each key-value pair
                for key, value in run_kwargs.items():
                    display_value = format_argument_value(value)
                    
                    run_kwargs_items.append(
                        html.P([
                            html.Strong(f"{key}: "), 
                            html.Span(display_value, className="text-muted small font-monospace")
                        ], className="mb-1 small", style={"wordBreak": "break-word"})
                    )
            else:
                # Handle non-dict run_kwargs (unusual case)
                display_value = str(run_kwargs)[:100] + "..." if len(str(run_kwargs)) > 100 else str(run_kwargs)
                run_kwargs_items.append(
                    html.P([
                        html.Strong("Value: "), 
                        html.Span(display_value, className="text-muted small font-monospace")
                    ], className="mb-1 small", style={"wordBreak": "break-word"})
                )
            
            if run_kwargs_items:
                attributes.append(
                    html.Div([
                        html.H6("Run Keyword Arguments", className="text-primary mb-2 border-bottom pb-1"),
                        html.Small(f"Type: {type(run_kwargs).__name__}" + (f", Length: {len(run_kwargs)}" if hasattr(run_kwargs, '__len__') else ""), 
                                  className="text-muted d-block mb-2"),
                        html.Div(run_kwargs_items)
                    ], className="mb-3")
                )
        except Exception as e:
            # If there's an error processing run_kwargs, show a brief error message
            attributes.append(
                html.Div([
                    html.H6("Run Keyword Arguments", className="text-primary mb-2 border-bottom pb-1"),
                    html.P(f"Error processing run_kwargs: {str(e)[:50]}...", className="text-muted small")
                ], className="mb-3")
            )
    
    # Experiment-specific attributes
    exp_attrs = []
    if hasattr(experiment, '__dict__'):
        for attr_name in sorted(dir(experiment)):
            if not attr_name.startswith('_') and not callable(getattr(experiment, attr_name)):
                try:
                    attr_value = getattr(experiment, attr_name)
                    if attr_value is not None and str(attr_value) != "":
                        # Format the attribute value
                        if isinstance(attr_value, (int, float)):
                            display_value = str(attr_value)
                        elif isinstance(attr_value, str):
                            display_value = attr_value[:100] + "..." if len(attr_value) > 100 else attr_value
                        elif hasattr(attr_value, '__len__') and not isinstance(attr_value, str):
                            display_value = f"{type(attr_value).__name__} (length: {len(attr_value)})"
                        else:
                            display_value = str(type(attr_value).__name__)
                        
                        exp_attrs.append(
                            html.P([
                                html.Strong(f"{attr_name}: "), 
                                html.Span(display_value, className="text-muted small")
                            ], className="mb-1 small", style={"wordBreak": "break-word"})
                        )
                except:
                    continue
    
    if exp_attrs:
        attributes.append(
            html.Div([
                html.H6("Experiment Attributes", className="text-primary mb-2 border-bottom pb-1"),
                html.Div(exp_attrs[:20])  # Limit to first 20 attributes to avoid overwhelming UI
            ], className="mb-3")
        )
    else:
        attributes.append(
            html.Div([
                html.H6("Experiment Attributes", className="text-primary mb-2 border-bottom pb-1"),
                html.P("No public attributes found", className="text-muted small")
            ], className="mb-3")
        )
    
    # Methods/Functions info
    if hasattr(experiment, 'get_browser_functions'):
        try:
            plot_functions = experiment.get_browser_functions()
            if plot_functions:
                func_list = [html.Li(name, className="small") for name, _ in plot_functions]
                attributes.append(
                    html.Div([
                        html.H6("Available Plot Functions", className="text-primary mb-2 border-bottom pb-1"),
                        html.Ul(func_list, className="small mb-0")
                    ], className="mb-3")
                )
        except:
            pass
    
    return html.Div(attributes, style={"fontSize": "0.9rem"})


# Callback for loading selected experiment and displaying info
@app.callback(
    [Output("experiment-info", "children"),
     Output("plot-controls", "children"),
     Output("experiment-attributes", "children"),
     Output("file-store", "data")],
    [Input({"type": "experiment-btn", "index": ALL}, "n_clicks")],
    [State("file-path", "value")],
    prevent_initial_call=True
)
def load_selected_experiment(n_clicks_list, file_path):
    """
    Load the selected chronicle experiment from the file and extract metadata.
    
    This callback is triggered when the user clicks an experiment button in the tree view.
    It loads the specific experiment using the record ID and prepares UI components.
    
    Args:
        n_clicks_list (list): List of n_clicks values from experiment buttons
        file_path (str): Path to the chronicle log file
    
    Returns:
        tuple: A 3-element tuple containing:
            - experiment_info (Dash component): Card or Alert with experiment details
            - plot_controls (Dash component): Buttons for available plots or alert message
            - file_store (str or None): The validated file path for storage
    
    Handles:
        - Empty or invalid file paths
        - File not found errors
        - Permission errors
        - Corrupted HDF5 files
        - Experiments without browser functions
        - Generic loading errors
    
    Note:
        The function provides detailed error messages with visual indicators
        using Bootstrap icons for better user experience.
    """
    # Determine which button was clicked
    ctx = callback_context
    if not ctx.triggered:
        raise PreventUpdate
    
    # Extract record_id from the triggered button
    triggered_id = ctx.triggered[0]['prop_id']
    if not triggered_id or 'experiment-btn' not in triggered_id:
        raise PreventUpdate
    
    # Parse the button ID to get the record_id
    import json
    button_id = json.loads(triggered_id.split('.')[0])
    selected_record_id = button_id['index']
    
    if not selected_record_id or not file_path or file_path.strip() == "":
        return (
            dbc.Alert(
                [
                    html.I(className="bi bi-info-circle-fill me-2"),
                    "Select an experiment from the dropdown to view details"
                ],
                color="info",
                className="d-flex align-items-center"
            ),
            [],
            create_experiment_attributes_panel(),
            None
        )
    
    try:
        # Load the specific experiment using the selected record ID
        experiment = load_object(file_path.strip(), record_id=selected_record_id)
        
        # Create experiment info display with improved styling
        exp_type = type(experiment).__name__
        
        # Try to get additional experiment attributes if available
        exp_attrs = []
        exp_attrs.append(html.P(f"Record ID: {selected_record_id}", className="mb-1 small"))
        exp_attrs.append(html.P(f"File: {file_path}", className="mb-1 small text-truncate"))
        
        if hasattr(experiment, '__dict__'):
            for attr in ['name', 'description', 'timestamp', 'date']:
                if hasattr(experiment, attr):
                    value = getattr(experiment, attr)
                    if value:
                        exp_attrs.append(html.P(f"{attr.title()}: {str(value)[:100]}", className="mb-1 small"))
        
        info_card = dbc.Card([
            dbc.CardBody([
                html.H5([
                    html.I(className="bi bi-check-circle-fill text-success me-2"),
                    "Experiment Loaded Successfully"
                ], className="card-title text-success"),
                html.Hr(className="my-2"),
                html.P([
                    html.Strong("Type: "),
                    html.Span(exp_type, className="font-monospace")
                ], className="mb-1"),
                html.P([
                    html.Strong("File: "),
                    html.Span(file_path.strip(), className="text-muted small font-monospace")
                ], className="mb-1"),
                *exp_attrs  # Include any additional attributes found
            ])
        ], color="success", outline=True, className="shadow-sm")
        
        # Get available plot functions using built-in method
        try:
            plot_functions = experiment.get_browser_functions()
        except AttributeError:
            # Experiment doesn't have get_browser_functions method
            store_data = {"file_path": file_path.strip(), "record_id": selected_record_id}
            attributes_panel = create_experiment_attributes_panel(experiment, selected_record_id)
            return (
                info_card,
                dbc.Alert(
                    [
                        html.I(className="bi bi-exclamation-triangle-fill me-2"),
                        "This experiment does not have browser functions available. ",
                        html.Small("(Missing get_browser_functions method)", className="text-muted")
                    ],
                    color="warning",
                    className="d-flex align-items-center"
                ),
                attributes_panel,
                store_data
            )
        
        if plot_functions:
            # Create buttons for each plot function
            buttons = []
            for name, method in plot_functions:
                btn = dbc.Button(
                    name.replace("_", " ").title(),
                    id={"type": "plot-btn", "index": name},
                    color="primary",
                    className="me-2 mb-2",
                    size="sm"
                )
                buttons.append(btn)
            
            plot_control_div = dbc.Card([
                dbc.CardBody([
                    html.H5([
                        html.I(className="bi bi-graph-up me-2"),
                        f"Available Plots ({len(plot_functions)})"
                    ], className="card-title mb-3 text-primary"),
                    html.P("Click a button below to generate and display the plot:", className="text-muted small mb-3"),
                    html.Div(buttons, className="d-flex flex-wrap")
                ])
            ], color="primary", outline=True, className="shadow-sm")
            
            # Store both file path and record ID for plot callbacks
            store_data = {"file_path": file_path.strip(), "record_id": selected_record_id}
            attributes_panel = create_experiment_attributes_panel(experiment, selected_record_id)
            return (info_card, plot_control_div, attributes_panel, store_data)
        else:
            store_data = {"file_path": file_path.strip(), "record_id": selected_record_id}
            attributes_panel = create_experiment_attributes_panel(experiment, selected_record_id)
            return (
                info_card,
                dbc.Alert("No plots available for this experiment", color="info"),
                attributes_panel,
                store_data
            )
            
    except FileNotFoundError:
        return (
            dbc.Alert(
                [
                    html.I(className="bi bi-x-circle-fill me-2"),
                    html.Strong("File Not Found"),
                    html.Br(),
                    html.Small(f"Path: {file_path}", className="font-monospace")
                ],
                color="danger",
                className="d-flex align-items-start"
            ),
            [],
            create_experiment_attributes_panel(error_msg="File not found"),
            {"file_path": file_path, "record_id": selected_record_id} if selected_record_id else None
        )
    except PermissionError:
        return (
            dbc.Alert(
                [
                    html.I(className="bi bi-shield-x me-2"),
                    html.Strong("Permission Denied"),
                    html.Br(),
                    html.Small(f"Cannot access: {file_path}", className="font-monospace")
                ],
                color="danger",
                className="d-flex align-items-start"
            ),
            [],
            create_experiment_attributes_panel(error_msg="Permission denied"),
            {"file_path": file_path, "record_id": selected_record_id} if selected_record_id else None
        )
    except Exception as e:
        # Generic error handling for other issues (corrupted files, etc.)
        error_msg = str(e)
        if "HDF5" in error_msg or "h5py" in error_msg:
            return (
                dbc.Alert(
                    [
                        html.I(className="bi bi-file-earmark-x me-2"),
                        html.Strong("Invalid Chronicle File"),
                        html.Br(),
                        html.Small("The file appears to be corrupted or is not a valid HDF5 chronicle file."),
                        html.Br(),
                        html.Details([
                            html.Summary("Technical Details", className="text-muted small mt-2"),
                            html.Pre(error_msg[:200], className="mt-2 p-2 bg-light small")
                        ])
                    ],
                    color="danger"
                ),
                [],
                create_experiment_attributes_panel(error_msg="Invalid chronicle file"),
                {"file_path": file_path, "record_id": selected_record_id} if selected_record_id else None
            )
        else:
            return (
                dbc.Alert(
                    [
                        html.I(className="bi bi-exclamation-octagon-fill me-2"),
                        html.Strong("Error Loading Experiment"),
                        html.Br(),
                        html.Small("An unexpected error occurred while loading the file."),
                        html.Br(),
                        html.Details([
                            html.Summary("Error Details", className="text-muted small mt-2"),
                            html.Pre(error_msg[:200], className="mt-2 p-2 bg-light small")
                        ])
                    ],
                    color="danger"
                ),
                [],
                create_experiment_attributes_panel(error_msg="Loading error"),
                {"file_path": file_path, "record_id": selected_record_id} if selected_record_id else None
            )


# Callback for displaying plots
@app.callback(
    Output("plot-display", "figure"),
    Input({"type": "plot-btn", "index": dash.dependencies.ALL}, "n_clicks"),
    State("file-store", "data"),
    prevent_initial_call=True
)
def display_plot(n_clicks, store_data):
    """
    Generate and display a plot based on the selected browser function.
    
    This callback is triggered when any plot button is clicked. It identifies
    which button was clicked, reloads the experiment, calls the corresponding
    browser function, and returns the generated Plotly figure.
    
    Args:
        n_clicks (list): List of click counts for all plot buttons.
                        Used with pattern-matching callbacks.
        store_data (dict): Dictionary containing file_path and record_id from dcc.Store.
    
    Returns:
        plotly.graph_objects.Figure: The plot to display, or an error figure
                                     with an annotation if something goes wrong.
    
    Process:
        1. Validates that a file is loaded
        2. Identifies which button was clicked using callback context
        3. Reloads the experiment from the stored file path
        4. Finds and executes the selected plot method
        5. Validates the returned figure
        6. Returns the figure or an error message
    
    Error Handling:
        - No file loaded: Shows "No experiment loaded" message
        - Plot generation errors: Shows error details
        - Invalid return type: Shows type mismatch message
        - Method not found: Shows "Plot method not found" message
    
    Note:
        The experiment is reloaded for each plot to ensure consistency
        and handle any potential state changes.
    """
    if not store_data:
        return go.Figure().add_annotation(
            text="No experiment loaded",
            xref="paper", yref="paper",
            x=0.5, y=0.5, showarrow=False
        )
    
    file_path = store_data.get("file_path")
    record_id = store_data.get("record_id")
    
    if not file_path or not record_id:
        return go.Figure().add_annotation(
            text="Invalid experiment data",
            xref="paper", yref="paper", 
            x=0.5, y=0.5, showarrow=False
        )
    
    # Get which button was clicked
    ctx = callback_context
    if not ctx.triggered:
        return go.Figure()
    
    # Extract the button ID that was clicked
    button_id = ctx.triggered[0]['prop_id']
    if '"index":' not in button_id:
        return go.Figure()
    
    # Parse the method name from the button ID
    button_dict = json.loads(button_id.split('.')[0])
    method_name = button_dict['index']
    
    try:
        # Load the specific experiment using the selected record ID
        experiment = load_object(file_path, record_id=record_id)
        
        plot_functions = experiment.get_browser_functions()
        
        # Find and call the selected plot method
        for name, method in plot_functions:
            if name == method_name:
                try:
                    fig = method()
                    # Convert figure to Plotly format (supports both Plotly and matplotlib)
                    plotly_fig = convert_figure_to_plotly(fig)
                    return plotly_fig
                except Exception as plot_error:
                    return go.Figure().add_annotation(
                        text=f"Error generating plot: {str(plot_error)[:200]}",
                        xref="paper", yref="paper",
                        x=0.5, y=0.5, showarrow=False
                    )
        
        return go.Figure().add_annotation(
            text=f"Plot method '{method_name}' not found",
            xref="paper", yref="paper",
            x=0.5, y=0.5, showarrow=False
        )
        
    except Exception as e:
        return go.Figure().add_annotation(
            text=f"Error loading experiment: {str(e)[:200]}",
            xref="paper", yref="paper",
            x=0.5, y=0.5, showarrow=False
        )


def main():
    """
    Main entry point for the chronicle viewer app.
    
    Starts the Dash server with configurable options.
    By default runs on http://localhost:8050 in debug mode.
    
    Command line arguments:
        --host: Host to run the server on (default: 0.0.0.0)
        --port: Port to run the server on (default: 8050)
        --no-debug: Disable debug mode
        --help: Show help message
    
    Example:
        python chronicle_viewer.py
        python chronicle_viewer.py --port 8080 --no-debug
    """
    parser = argparse.ArgumentParser(
        description="Chronicle Log Viewer - Visualize LeeQ experiment chronicle files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Usage Examples:
  Start the viewer on default port (8050):
    python chronicle_viewer.py
    
  Start on a different port:
    python chronicle_viewer.py --port 8080
    
  Start in production mode (no debug):
    python chronicle_viewer.py --no-debug
    
  View this help:
    python chronicle_viewer.py --help

Once started, open your browser to http://localhost:8050 (or the specified port)
and enter the path to a chronicle log file to visualize.
        """
    )
    parser.add_argument("--host", default="0.0.0.0", help="Host to run the server on")
    parser.add_argument("--port", type=int, default=8050, help="Port to run the server on")
    parser.add_argument("--no-debug", action="store_true", help="Disable debug mode")
    
    args = parser.parse_args()
    
    debug = not args.no_debug
    
    print(f"Starting Chronicle Log Viewer...")
    print(f"Server will be available at http://localhost:{args.port}")
    if debug:
        print("Debug mode is ON - auto-reload enabled")
    
    app.run(debug=debug, host=args.host, port=args.port)


if __name__ == "__main__":
    main()